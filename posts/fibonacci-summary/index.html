<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>斐波那契数列总结 - 头头博客</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#fff"><meta name="application-name" content="头头博客"><meta name="msapplication-TileImage" content="/asset/favicon144.png"><meta name="msapplication-TileColor" content="#fff"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="头头博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><link rel="apple-touch-icon" sizes="96x96" href="/asset/favicon96.png"><link rel="apple-touch-icon" sizes="144x144" href="/asset/favicon144.png"><link rel="apple-touch-icon" sizes="192x192" href="/asset/favicon192.png"><meta name="description" content="斐波那契数列是从0，1开始，后面每一项都是由前面两项相加得到。开头几项是0、1、1、2、3、5、8、13……。在OEIS中是A000045数列。需要注意的是斐波那契数列的第零项是0，第一项是1。本文将探讨总结斐波那契数列的相关问题。 递归定义如下： $$ F_n &amp;#x3D;  \begin{cases} 0, &amp;amp; n &amp;#x3D; 0 \\ 1, &amp;amp; n &amp;#x3D; 1 \\ F_{n-1} + F_{n-2} &amp;amp; n &amp;gt;"><meta property="og:type" content="blog"><meta property="og:title" content="斐波那契数列总结"><meta property="og:url" content="https://blog.tootal.xyz/posts/fibonacci-summary/"><meta property="og:site_name" content="头头博客"><meta property="og:description" content="斐波那契数列是从0，1开始，后面每一项都是由前面两项相加得到。开头几项是0、1、1、2、3、5、8、13……。在OEIS中是A000045数列。需要注意的是斐波那契数列的第零项是0，第一项是1。本文将探讨总结斐波那契数列的相关问题。 递归定义如下： $$ F_n &amp;#x3D;  \begin{cases} 0, &amp;amp; n &amp;#x3D; 0 \\ 1, &amp;amp; n &amp;#x3D; 1 \\ F_{n-1} + F_{n-2} &amp;amp; n &amp;gt;"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.tootal.xyz/asset/fibonacci-summary.cover.png"><meta property="article:published_time" content="2020-12-05T07:23:41.000Z"><meta property="article:modified_time" content="2020-12-08T04:13:15.000Z"><meta property="article:author" content="黄智权"><meta property="article:tag" content="ACM"><meta property="article:tag" content="算法"><meta property="article:tag" content="斐波那契数列"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/asset/fibonacci-summary.cover.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.tootal.xyz/posts/fibonacci-summary/"},"headline":"头头博客","image":["https://blog.tootal.xyz/asset/fibonacci-summary.cover.png"],"datePublished":"2020-12-05T07:23:41.000Z","dateModified":"2020-12-08T04:13:15.000Z","author":{"@type":"Person","name":"黄智权"},"description":"斐波那契数列是从0，1开始，后面每一项都是由前面两项相加得到。开头几项是0、1、1、2、3、5、8、13……。在OEIS中是A000045数列。需要注意的是斐波那契数列的第零项是0，第一项是1。本文将探讨总结斐波那契数列的相关问题。 递归定义如下： $$ F_n &#x3D;  \\begin{cases} 0, &amp; n &#x3D; 0 \\\\ 1, &amp; n &#x3D; 1 \\\\ F_{n-1} + F_{n-2} &amp; n &gt;"}</script><link rel="canonical" href="https://blog.tootal.xyz/posts/fibonacci-summary/"><link rel="icon" href="/asset/favicon.png"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/5.15.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?a0752fdc3e7a9d538e1cb45af25201a4";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="头头博客" type="application/atom+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">头头博客</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">存档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" target="_blank" rel="noopener" href="https://note.tootal.xyz">笔记</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="View on GitHub" href="https://github.com/tootal/tootal.github.io"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/asset/fibonacci-summary.cover.png" alt="斐波那契数列总结"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-12-05T07:23:41.000Z" title="2020-12-05T07:23:41.000Z">2020-12-05</time>发表</span><span class="level-item"><time dateTime="2020-12-08T04:13:15.000Z" title="2020-12-08T04:13:15.000Z">2020-12-08</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a><span> / </span><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/">算法竞赛</a></span><span class="level-item">40 分钟读完 (大约5954个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span><span class="level-item"><a target="_blank" rel="noopener" href="https://github.com/tootal/blog/edit/master/source/_posts/fibonacci-summary.md"><i class="far fa-edit"></i></a></span></div></div><h1 class="title is-3 is-size-4-mobile">斐波那契数列总结</h1><div class="content"><p><a target="_blank" rel="noopener" href="https://oi-wiki.org/math/fibonacci/">斐波那契数列</a>是从0，1开始，后面每一项都是由前面两项相加得到。开头几项是0、1、1、2、3、5、8、13……。在OEIS中是<a target="_blank" rel="noopener" href="https://oeis.org/A000045">A000045</a>数列。需要注意的是斐波那契数列的<strong>第零项</strong>是0，第一项是1。本文将探讨总结斐波那契数列的相关问题。</p>
<p>递归定义如下：</p>
<div role="math">$$
F_n = 
\begin{cases}
0, & n = 0 \\
1, & n = 1 \\
F_{n-1} + F_{n-2} & n > 1 
\end{cases}
$$</div>
<a id="more"></a>
<h2 id="小范围求-span-role-math-f-n-span">小范围求<span role="math">$f(n)$</span><a class="header-anchor" href="#小范围求-span-role-math-f-n-span">#</a></h2>
<h3 id="span-role-math-n-le-39-span"><span role="math">$n \le 39$</span><a class="header-anchor" href="#span-role-math-n-le-39-span">#</a></h3>
<p>对应题目：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/c6c7742f5ba7442aada113136ddea0c3">牛客网 【编程题】斐波那契数列</a></p>
<p>在这个范围内的斐波那契数列可以很容易计算出来，速度也非常快(1秒以内)，根据定义可以写出下面的递归程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">return</span> f(n<span class="number">-1</span>) + f(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f(<span class="number">39</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Time: &quot;</span> &lt;&lt; (<span class="keyword">double</span>)clock() / CLOCKS_PER_SEC &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">63245986</span><br><span class="line">Time: 0.184</span><br></pre></td></tr></table></figure>
<p>注意：提交时需要改成类的版本。</p>
<h3 id="span-role-math-n-le-46-span"><span role="math">$n \le 46$</span><a class="header-anchor" href="#span-role-math-n-le-46-span">#</a></h3>
<p>对应题目：<a target="_blank" rel="noopener" href="https://nanti.jisuanke.com/t/T1066">计蒜客T1066 斐波那契数列</a></p>
<p>看似数据范围仅仅增大了7，但我们继续使用上面的程序计算<span role="math">$f(46)$</span>时，会得到如下结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1836311903</span><br><span class="line">Time: 4.946</span><br></pre></td></tr></table></figure>
<p>时间已经超出了1秒的限制，考虑优化一下计算方法。实际上在递归调用的过程中，有很多值被重复计算了。我们可以记录下已经算过的值，当下次需要时直接读取，不再重复计算。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> fib[<span class="number">47</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fib[n]) <span class="keyword">return</span> fib[n]; <span class="comment">// 已经算过</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fib[n] = f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">46</span>;</span><br><span class="line">    <span class="comment">// cin &gt;&gt; n;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f(n) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Time: &quot;</span> &lt;&lt; (<span class="keyword">double</span>)clock() / CLOCKS_PER_SEC &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次测试<span role="math">$f(46)$</span>，发现这次计算的非常快！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1836311903</span><br><span class="line">Time: 0.001</span><br></pre></td></tr></table></figure>
<h3 id="span-role-math-n-le-100-span"><span role="math">$n \le 100$</span><a class="header-anchor" href="#span-role-math-n-le-100-span">#</a></h3>
<p>对应题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">力扣 剑指 Offer 10- I. 斐波那契数列</a></p>
<p>注意到答案开始需要对<span role="math">$10^9+7$</span>取模了，但我们仍然可以使用上面的写法（加个取模）即可通过此题。</p>
<figure class="highlight cpp"><figcaption><span>点击展开代码 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> fib[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fib[n]) <span class="keyword">return</span> fib[n]; <span class="comment">// 已经算过</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fib[n] = (f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>)) % M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// cin &gt;&gt; n;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f(n) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Time: &quot;</span> &lt;&lt; (<span class="keyword">double</span>)clock() / CLOCKS_PER_SEC &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// 687995182</span></span><br><span class="line"><span class="comment">// Time: 0.001</span></span><br></pre></td></tr></table></figure>
<p>这次我们尝试换一种写法，不使用数组，利用两个变量递推得出结果。时间复杂度和上面的代码一样，但空间复杂度更加优秀。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100</span>, a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// cin &gt;&gt; n;</span></span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        a = (a + b) % M;</span><br><span class="line">        swap(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Time: &quot;</span> &lt;&lt; (<span class="keyword">double</span>)clock() / CLOCKS_PER_SEC &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// 687995182</span></span><br><span class="line"><span class="comment">// Time: 0</span></span><br></pre></td></tr></table></figure>
<p>一开始<code>a</code>代表<span role="math">$f(0)$</span>，每循环一次，a表示的数就往后一位，所以循环n次后，a就表示<span role="math">$f(n)$</span>。</p>
<h3 id="span-role-math-n-le-4786-span"><span role="math">$n \le 4786$</span><a class="header-anchor" href="#span-role-math-n-le-4786-span">#</a></h3>
<p>对应题目：<a target="_blank" rel="noopener" href="http://acm.hhu.edu.cn/problem.php?id=1387">HHUOJ-1387 大斐波那契数</a><br>
注：题目仅给出结果不超过1000位。</p>
<p>容易发现C++中的<code>int</code>甚至<code>long long</code>都无法保存这么大的数了，但好在评测系统是支持Python的，考虑到Python写法简单且自带大数，我们可以尝试使用Python来写这题。</p>
<p>前面提到，斐波那契数列后面每一项都是由前面两项相加得到。我们可以根据这条规则来写代码。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> count</span><br><span class="line">f = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> count(<span class="number">2</span>):</span><br><span class="line">    f.append(f[-<span class="number">1</span>] + f[-<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">str</span>(f[i])) &gt; <span class="number">1000</span>: <span class="keyword">break</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> [*<span class="built_in">open</span>(<span class="number">0</span>)]:</span><br><span class="line">    print(f[<span class="built_in">int</span>(n)])</span><br></pre></td></tr></table></figure>
<p>其中<code>f[-1]</code>表示取序列<code>f</code>中最后一个元素，<code>count(2)</code>产生一个从2开始的无限序列，<code>[*open(0)]</code>表示打开标准输入文件并按行分割成列表。</p>
<h3 id="其他写法">其他写法<a class="header-anchor" href="#其他写法">#</a></h3>
<p>还有很多有趣的写法来求小范围的斐波那契数列，这里列举几种，就不详细展开了。</p>
<ul>
<li>Python 生成器</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    i, a, b = 0, 0, 1</span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        yield a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">print(<span class="built_in">list</span>(fib(<span class="number">10</span>)))</span><br></pre></td></tr></table></figure>
<h2 id="大范围求-span-role-math-f-n-span">大范围求<span role="math">$f(n)$</span><a class="header-anchor" href="#大范围求-span-role-math-f-n-span">#</a></h2>
<p>前面提到的算法的时间复杂度是<span role="math">$O(n)$</span>的，理论上来说可以在1秒以内求出<span role="math">$10^8$</span>以内的值，所以这里的大范围肯定是要比<span role="math">$10^8$</span>还大的。</p>
<h3 id="span-role-math-n-le-10-9-span"><span role="math">$n \le 10^9$</span><a class="header-anchor" href="#span-role-math-n-le-10-9-span">#</a></h3>
<p>对应题目：<a target="_blank" rel="noopener" href="http://poj.org/problem?id=3070">POJ-3070 Fibonacci</a><br>
注意此题的模数是10000。</p>
<p>题目中已经给出了关于Fibonacci数列的另一个很重要的公式：</p>
<div role="math">$$
\begin{pmatrix}
F_{n+1} & F_n \\
F_n & F_{n-1}
\end{pmatrix}=
\begin{pmatrix}
1 & 1\\
1 & 0
\end{pmatrix}
^n
$$</div>
<p>考虑到n比较大，可以使用<strong>矩阵快速幂</strong>求解。矩阵快速幂是<a target="_blank" rel="noopener" href="https://oi-wiki.org/math/quick-pow/">快速幂算法</a>的变形，仍然是利用如下原理：</p>
<div role="math">$$
x^y = 
\begin{cases}
x \cdot x^{y-1}, & y为奇数 \\
x^{y/2} \cdot x^{y/2}, & y为偶数 
\end{cases}
$$</div>
<p>通常我习惯把它写成<code>while</code>循环结合<strong>位运算</strong>的形式。时间复杂度为<span role="math">$O(\log(n))$</span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e4</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> mat[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i, n) for(int i = 0; i &lt; n; i++)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">muleq</span><span class="params">(mat &amp;a, mat &amp;b)</span> </span>&#123;</span><br><span class="line">    mat c&#123;&#125;;</span><br><span class="line">    FOR(i, <span class="number">2</span>) FOR(j, <span class="number">2</span>) FOR(k, <span class="number">2</span>)</span><br><span class="line">        c[i][j] = (c[i][j] + a[i][k] * b[k][j] % M) % M;</span><br><span class="line">    <span class="built_in">memcpy</span>(a, c, <span class="keyword">sizeof</span>(a));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        mat a&#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        mat ans&#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>) muleq(ans, a);</span><br><span class="line">            muleq(a, a);</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[<span class="number">1</span>][<span class="number">0</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于POJ的编译器比较老，采用了不那么直观的写法。<code>muleq(a, b)</code>的含义是<code>a = a * b</code>，其中<code>a</code>、<code>b</code>均为矩阵，<code>*</code>为矩阵乘法。</p>
<h3 id="span-role-math-n-le-10-18-span"><span role="math">$n \le 10^{18}$</span><a class="header-anchor" href="#span-role-math-n-le-10-18-span">#</a></h3>
<p>对应题目：<a target="_blank" rel="noopener" href="https://www.51nod.com/Challenge/Problem.html#problemId=1242">51Nod 1242 斐波那契数列的第N项</a><br>
利用上面的做法同样可以通过此题，这里利用运算符重载给出更直观一点的代码。<br>
注意：此题的模数为<span role="math">$10^9+9$</span>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> ll M = <span class="number">1e9</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">using</span> Mat = <span class="built_in">array</span>&lt;<span class="built_in">array</span>&lt;ll, <span class="number">2</span>&gt;, <span class="number">2</span>&gt;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i, n) for(int i = 0; i &lt; n; i++)</span></span><br><span class="line">Mat <span class="keyword">operator</span>*(<span class="keyword">const</span> Mat &amp;a, <span class="keyword">const</span> Mat &amp;b) &#123;</span><br><span class="line">    Mat c&#123;&#125;;</span><br><span class="line">    FOR(i, <span class="number">2</span>) FOR(j, <span class="number">2</span>) FOR(k, <span class="number">2</span>)</span><br><span class="line">        c[i][j] = (c[i][j] + a[i][k] * b[k][j]) % M;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Mat <span class="title">Pow</span><span class="params">(Mat x, ll y)</span> </span>&#123;</span><br><span class="line">    Mat ans&#123;&#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;&#125;;</span><br><span class="line">    <span class="keyword">while</span> (y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ans = ans * x;</span><br><span class="line">        x = x * x;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n = <span class="number">1e18</span>;</span><br><span class="line">    <span class="comment">// cin &gt;&gt; n;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Pow(Mat&#123;&#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;&#125;, n)[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Time: &quot;</span> &lt;&lt; (<span class="keyword">double</span>)clock() / CLOCKS_PER_SEC &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// 209762233</span></span><br><span class="line"><span class="comment">// Time: 0.001</span></span><br></pre></td></tr></table></figure>
<h3 id="span-role-math-n-le-10-10-6-span"><span role="math">$n \le 10^{10^{6}}$</span><a class="header-anchor" href="#span-role-math-n-le-10-10-6-span">#</a></h3>
<p>类似题目：<a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/885/B">2019牛客多校5B generator 1</a><br>
对于这个范围的数，其实上面的算法也是可以解决的，就是实现上需要一些技巧。由于给定的n是一个十进制的数，将他转换成二进制需要花费大量时间，因此我们可以直接使用<strong>十进制下的快速幂</strong>来计算。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> ll M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> Mat = <span class="built_in">array</span>&lt;<span class="built_in">array</span>&lt;ll, <span class="number">2</span>&gt;, <span class="number">2</span>&gt;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i, n) for(int i = 0; i &lt; n; i++)</span></span><br><span class="line"><span class="built_in">string</span> n;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line">Mat <span class="keyword">operator</span>*(<span class="keyword">const</span> Mat &amp;a, <span class="keyword">const</span> Mat &amp;b) &#123;</span><br><span class="line">    Mat c&#123;&#125;;</span><br><span class="line">    FOR(i, <span class="number">2</span>) FOR(j, <span class="number">2</span>) FOR(k, <span class="number">2</span>)</span><br><span class="line">        c[i][j] = (c[i][j] + a[i][k] * b[k][j]) % M;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Mat <span class="title">Pow</span><span class="params">(Mat x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    Mat ans&#123;&#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;&#125;;</span><br><span class="line">    FOR(t, y) ans = ans * x;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ans = ans * x % M;</span><br><span class="line">        x = x * x % M;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Mat <span class="title">Pow</span><span class="params">(Mat x)</span> </span>&#123;</span><br><span class="line">    Mat ans&#123;&#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;&#125;;</span><br><span class="line">    FOR(i, len) &#123;</span><br><span class="line">        ans = ans*Pow(x, n[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        x = Pow(x, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="string">&quot;1&quot;</span> + <span class="built_in">string</span>(<span class="number">1e6</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    len = (<span class="keyword">int</span>)n.length();</span><br><span class="line">    reverse(n.begin(), n.end());</span><br><span class="line">    Mat A = Pow(Mat&#123;&#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;&#125;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; A[<span class="number">1</span>][<span class="number">0</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他写法-2">其他写法<a class="header-anchor" href="#其他写法-2">#</a></h3>
<ul>
<li>不使用矩阵的矩阵快速幂。由于斐波那契数列的矩阵递推式非常小（<span role="math">$2\times 2$</span>），我们可以利用函数参数在递归时巧妙的计算。（对应题目：<a target="_blank" rel="noopener" href="https://www.51nod.com/Challenge/Problem.html#problemId=1242">51Nod 1242 斐波那契数列的第N项</a>）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> ll M = <span class="number">1e9</span> + <span class="number">9</span>;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll n, ll a = <span class="number">1</span>, ll b = <span class="number">0</span>, ll p = <span class="number">0</span>, ll q = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">1</span>) <span class="keyword">return</span> f(n<span class="number">-1</span>, (b*q+a*q+a*p)%M, (b*p+a*q)%M, p, q);</span><br><span class="line">    <span class="keyword">return</span> f(n/<span class="number">2</span>, a, b, (p*p+q*q)%M, (q*q+<span class="number">2</span>*q*p)%M);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n = <span class="number">1e18</span>;</span><br><span class="line">    <span class="comment">// cin &gt;&gt; n;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f(n) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Time: &quot;</span> &lt;&lt; (<span class="keyword">double</span>)clock() / CLOCKS_PER_SEC &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// 209762233</span></span><br><span class="line"><span class="comment">// Time: 0.002</span></span><br></pre></td></tr></table></figure>
<ul>
<li>利用循环节计算。当模数给定且n的范围远大于模数时，可以采用找循环节的做法，相比于十进制快速幂会好写很多，但有时循环节是不固定的。</li>
</ul>
<p>如果不知道或者忘记了如何求斐波那契数列在给定模数下的循环节，可以写一个暴力程序求出。参考下面的代码：</p>
<figure class="highlight cpp"><figcaption><span>点击展开代码 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function">ll <span class="title">fib</span><span class="params">(ll m)</span> </span>&#123;</span><br><span class="line">    ll a = <span class="number">1</span>, b = <span class="number">1</span>, c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!(a == <span class="number">0</span> &amp;&amp; b == <span class="number">1</span>)) &#123;</span><br><span class="line">        c++;</span><br><span class="line">        a = (a + b) % m;</span><br><span class="line">        swap(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>)(<span class="number">1e4</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; fib(<span class="number">1e4</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>)(<span class="number">1e9</span>+<span class="number">7</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; fib(<span class="number">1e9</span>+<span class="number">7</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>)(<span class="number">1e9</span>+<span class="number">9</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; fib(<span class="number">1e9</span>+<span class="number">9</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Time: &quot;</span> &lt;&lt; (<span class="keyword">double</span>)clock() / CLOCKS_PER_SEC &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// 10000 15000</span></span><br><span class="line"><span class="comment">// 1000000007 2000000016</span></span><br><span class="line"><span class="comment">// 1000000009 333333336</span></span><br><span class="line"><span class="comment">// Time: 7.443</span></span><br></pre></td></tr></table></figure>
<h2 id="斐波那契相关问题">斐波那契相关问题<a class="header-anchor" href="#斐波那契相关问题">#</a></h2>
<p>对于其他和斐波那契数列相关的问题，如广义斐波那契数列、斐波那契数列前缀和等，这里归类为斐波那契相关问题。通常需要用到一些斐波那契数列的性质，参考文章：<a href="/asset/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0_%E5%AD%99%E6%99%BA%E5%AE%8F.pdf">斐波那契数_孙智宏</a>。</p>
<h3 id="广义斐波那契数列">广义斐波那契数列<a class="header-anchor" href="#广义斐波那契数列">#</a></h3>
<p>对应题目：<a target="_blank" rel="noopener" href="https://www.51nod.com/Challenge/Problem.html#problemId=1126">51Nod-1126 求递推序列的第N项</a><br>
注意：此题下标从1开始。<br>
广义斐波那契数列是斐波那契数列的推广，定义如下：</p>
<div role="math">$$
F_n = 
\begin{cases}
A, & n = 0 \\
B, & n = 1 \\
C\cdot F_{n-1} + D \cdot F_{n-2}, & n > 1 
\end{cases}
$$</div>
<p>当A=0，B=C=D=1是变成普通的斐波那契数列，A=2，B=C=D=1时，变成卢卡斯序列。</p>
<p>广义斐波那契数列的处理方式基本一样。我们可以推一下这个序列的矩阵递推式：</p>
<div role="math">$$
\begin{aligned}
\begin{pmatrix}
f_{n+1} \\
f_n 
\end{pmatrix}
& =  
\begin{pmatrix}
C & D\\
1 & 0
\end{pmatrix}
\begin{pmatrix}
f_n \\
f_{n-1}
\end{pmatrix}\\
 & =  
\begin{pmatrix}
C & D\\
1 & 0
\end{pmatrix}^{n}
\begin{pmatrix}
B \\
A
\end{pmatrix}
\end{aligned}
$$</div>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> ll M = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> Mat = <span class="built_in">array</span>&lt;<span class="built_in">array</span>&lt;ll, <span class="number">2</span>&gt;, <span class="number">2</span>&gt;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i, n) for(int i = 0; i &lt; n; i++)</span></span><br><span class="line">Mat <span class="keyword">operator</span>*(<span class="keyword">const</span> Mat &amp;a, <span class="keyword">const</span> Mat &amp;b) &#123;</span><br><span class="line">    Mat c&#123;&#125;;</span><br><span class="line">    FOR(i, <span class="number">2</span>) FOR(j, <span class="number">2</span>) FOR(k, <span class="number">2</span>)</span><br><span class="line">        c[i][j] = (c[i][j] + a[i][k] * b[k][j]) % M;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; n;</span><br><span class="line">    Mat m&#123;&#123;&#123;a, b&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;&#125;;</span><br><span class="line">    Mat ans&#123;&#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (n--; n; n &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) ans = ans * m;</span><br><span class="line">        m = m * m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ((ans[<span class="number">1</span>][<span class="number">0</span>] + ans[<span class="number">1</span>][<span class="number">1</span>]) % M + M) % M &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求区间和">求区间和<a class="header-anchor" href="#求区间和">#</a></h3>
<p>对应题目：<a target="_blank" rel="noopener" href="http://acm.hit.edu.cn/problemset/2060">HITOJ-2060 Fibonacci Problem Again</a>。<br>
注意：此题斐波那契数列前两项为1，模数为<span role="math">$10^9$</span>。</p>
<p>考虑一般的斐波那契数列区间和，可以直接转化成斐波那契数列求解：<span role="math">$S(n)=f(n+2)-1$</span>，其中<span role="math">$S(n)=\sum\limits_{i=0}^n f(i)$</span>。</p>
<p>直接套用一个上面的代码，复杂度<span role="math">$O(log(n))$</span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> ll M = <span class="number">1e9</span>;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll n, ll a = <span class="number">1</span>, ll b = <span class="number">0</span>, ll p = <span class="number">0</span>, ll q = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">1</span>) <span class="keyword">return</span> f(n<span class="number">-1</span>, (b*q+a*q+a*p)%M, (b*p+a*q)%M, p, q);</span><br><span class="line">    <span class="keyword">return</span> f(n/<span class="number">2</span>, a, b, (p*p+q*q)%M, (q*q+<span class="number">2</span>*q*p)%M);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll a, b;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span> &amp;&amp; b == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (f(b+<span class="number">3</span>)-f(a+<span class="number">2</span>)+M)%M &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环节加速">循环节加速<a class="header-anchor" href="#循环节加速">#</a></h3>
<p>对应题目：<a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=1021">Fibonacci Again</a></p>
<p>实际上广义斐波那契数列也是有循环节的。利用之前提到的方法，可以直接算出这个序列的循环节为8。而该序列的前8项为<code>[7, 11, 18, 29, 47, 76, 123, 199]</code>，其中能被3整除的有<code>[2, 6]</code> 项，即<code>n % 4 == 2</code>是为<code>yes</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ((n % <span class="number">4</span> == <span class="number">2</span>) ? <span class="string">&quot;yes&quot;</span> : <span class="string">&quot;no&quot;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小范围求循环节">小范围求循环节<a class="header-anchor" href="#小范围求循环节">#</a></h3>
<p>对应题目：<a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=3977">HDU3977 Evil teacher</a></p>
<p>对于一个给定的模数，如何求出循环节呢？利用枚举的方法显然太慢了，我们可以利用这篇论文：<a href="/asset/The%20Period%20of%20the%20Fibonacci%20Sequence%20Modulo%20j.pdf">The Period of the Fibonacci Sequence Modulo j.pdf</a>中提到的一些性质来加速求解。</p>
<blockquote>
<p>(定理3) 设<span role="math">$j$</span>是一个正数，且<span role="math">$j=\prod\limits_{i=1}^s p_i^{k_i}$</span>，其中<span role="math">$p_i$</span>是素数，设<span role="math">$m_i$</span>表示<span role="math">$F_n(\mod p_i^{k_i})$</span>的循环节，<span role="math">$m$</span>表示<span role="math">$F_n(\mod j)$</span>的循环节，则有<span role="math">$m=lcm(m_1, m_2, …, m_s)$</span>。</p>
</blockquote>
<p>利用这条性质，我们可以先把模数P质因数分解，转换为求模数为<span role="math">$p^k$</span>的情况。</p>
<p>再根据这条推论：</p>
<blockquote>
<p>设<span role="math">$G( p )$</span>表示<span role="math">$F_n(\mod p)$</span>的循环节，其中<span role="math">$p$</span>为质数，则有<span role="math">$G(p^k)=G( p )\cdot p^{k-1}$</span>。</p>
</blockquote>
<p>（详细证明可以参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/yicongli/p/9800705.html">这篇博客</a>）</p>
<p>此外还有一个小性质：<span role="math">$G( p ) \le 6p$</span>（证明参考<a target="_blank" rel="noopener" href="https://www.mathpages.com/home/kmath078/kmath078.htm">这里</a>）可以帮助我们估算复杂度。</p>
<p>注意到P的最大素因子不超过<span role="math">$10^6$</span>，且只有20组，估算一下最坏情况下的复杂度完全可以通过此题。</p>
<figure class="highlight cpp"><figcaption><span>点击展开代码 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">lcm</span><span class="params">(ll a, ll b)</span> </span>&#123; <span class="keyword">return</span> a / __gcd(a, b) * b; &#125;</span><br><span class="line"><span class="function">ll <span class="title">fib_perd</span><span class="params">(ll m)</span> </span>&#123; <span class="comment">// 求Fn mod m 循环节</span></span><br><span class="line">    ll a = <span class="number">1</span>, b = <span class="number">1</span>, c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!(a == <span class="number">0</span> &amp;&amp; b == <span class="number">1</span>)) &#123;</span><br><span class="line">        c++;</span><br><span class="line">        a = (a + b) % m;</span><br><span class="line">        swap(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; is_prime;</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; prime;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_prime</span><span class="params">()</span> </span>&#123; <span class="comment">// 素数筛法</span></span><br><span class="line">    is_prime.resize(N, <span class="literal">true</span>);</span><br><span class="line">    is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!is_prime[i]) <span class="keyword">continue</span>;</span><br><span class="line">        prime.push_back(i);</span><br><span class="line">        <span class="keyword">for</span> (ll j = i * i; j &lt; N; j += i) is_prime[j] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    get_prime();</span><br><span class="line">    <span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++) &#123;</span><br><span class="line">        ll n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        ll ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : prime) &#123; <span class="comment">// 质因数分解</span></span><br><span class="line">            <span class="keyword">if</span> (n % p) <span class="keyword">continue</span>;</span><br><span class="line">            ll pk = <span class="number">1</span>; <span class="comment">// 保存p^k</span></span><br><span class="line">            <span class="keyword">while</span> (n % p == <span class="number">0</span>) pk *= p, n /= p;</span><br><span class="line">            ans = lcm(ans, pk / p * fib_perd(p));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通项公式">通项公式<a class="header-anchor" href="#通项公式">#</a></h3>
<p>上面已经得到了斐波那契数列公式的矩阵形式，要得到通项公式，还需要进一步变换。这里采用线性代数的方法。</p>
<div role="math">$$
\begin{aligned}
\begin{pmatrix}
F_{n+1} \\
F_n
\end{pmatrix}
& =  
\begin{pmatrix}
1 & 1\\
1 & 0
\end{pmatrix}^n
\begin{pmatrix}
1 \\
0
\end{pmatrix}
\end{aligned}
$$</div>
<p>利用对角化计算方阵的幂。</p>
<p>设矩阵<span role="math">$A=\begin{pmatrix} 1 &amp; 1\\ 1 &amp; 0 \end{pmatrix}$</span>，其特征方程为：<span role="math">$|\lambda E-A|$</span>，其中<span role="math">$E$</span>为单位矩阵。</p>
<p>计算得：</p>
<div role="math">$$
\begin{aligned}
|\lambda E-A| & =   
\left|
\begin{matrix}
\lambda-1 & -1\\
-1 & \lambda
\end{matrix}
\right| \\
& =   \lambda^2-\lambda-1
\end{aligned}
$$</div>
<p>解得<span role="math">$\lambda_1=\frac{1-\sqrt{5}}{2}$</span>，<span role="math">$\lambda_2=\frac{1+\sqrt{5}}{2}$</span>。</p>
<p>代入特征值<span role="math">$\lambda_1$</span>，解齐次线性方程组<span role="math">$(\lambda E - A)X=0$</span>：</p>
<div role="math">$$
\lambda E - A = 
\begin{pmatrix}
-\lambda_2 & -1 \\
-1 & \lambda_1
\end{pmatrix}
$$</div>
<p>将矩阵第一行乘以<span role="math">$\lambda_1$</span>加到第二行，矩阵变换为：</p>
<div role="math">$$
\begin{pmatrix}
-\lambda_2 & -1 \\
0 & 0
\end{pmatrix}
$$</div>
<p>即<span role="math">$x_2=-\lambda_2 x_1$</span>，取<span role="math">$x_1=1$</span>，则其基础解系为<span role="math">$X_1=\begin{pmatrix}1 \\ -\lambda_2\end{pmatrix}$</span>。</p>
<p>取特征向量为<span role="math">$\xi_1=\begin{pmatrix}1 \\ -\lambda_2\end{pmatrix}$</span>，对于<span role="math">$\lambda_2$</span>同理可得<span role="math">$\xi_2=\begin{pmatrix}1 \\ -\lambda_1\end{pmatrix}$</span>。</p>
<p>令</p>
<div role="math">$$
\begin{aligned}
P & =  (\xi_1, \xi_2)\\
  & = \begin{pmatrix}1 & 1\\ 
        -\lambda_2 & -\lambda_1\end{pmatrix}\\
  & = \begin{pmatrix}1 & 1\\ 
            \lambda_2 & \lambda_1\end{pmatrix}
\end{aligned}
$$</div>
<p>利用增广矩阵求逆。</p>
<div role="math">$$
\begin{aligned}
(P|E) & = 
\begin{pmatrix}
1 & 1 & 1 & 0\\ 
\lambda_2 & \lambda_1 & 0 & 1
\end{pmatrix} \\
& = 
\begin{pmatrix}
1 & 1 & 1 & 0\\ 
0 & -\sqrt{5} & -\lambda_2 & 1
\end{pmatrix} \\
& = 
\begin{pmatrix}
1 & 0 & \frac{\sqrt{5}-1}{2\sqrt{5}} & \frac{1}{\sqrt{5}}\\ 
0 & -\sqrt{5} & -\lambda_2 & 1
\end{pmatrix} \\
& = 
\begin{pmatrix}
1 & 0 & \frac{\sqrt{5}-1}{2\sqrt{5}} & \frac{1}{\sqrt{5}}\\ 
0 & 1 & \frac{1+\sqrt{5}}{2\sqrt{5}} & -\frac{1}{\sqrt{5}}
\end{pmatrix} \\
\end{aligned}
$$</div>
<p>依次进行的变换为：</p>
<ul>
<li>第一行乘以<span role="math">$-\lambda_2$</span>加到第二行</li>
<li>第二行乘以<span role="math">$\frac{1}{\sqrt{5}}$</span>加到第一行</li>
<li>第三行乘以<span role="math">$-\frac{1}{\sqrt{5}}$</span></li>
</ul>
<p>注：<a target="_blank" rel="noopener" href="https://www.wolframalpha.com/input/?i=inverse+%7B%7B1%2C1%7D%2C%7B%281%2Bsqrt%285%29%29%2F2%2C+%281-sqrt%285%29%29%2F2%7D%7D">Wolfram验算</a></p>
<p>可得<span role="math">$P^{-1}=\begin{pmatrix} \frac{\sqrt{5}-1}{2\sqrt{5}} &amp; \frac{1}{\sqrt{5}}\\ \frac{1+\sqrt{5}}{2\sqrt{5}} &amp; -\frac{1}{\sqrt{5}}\end{pmatrix}$</span>。</p>
<p>由于<span role="math">$P^{-1}AP=\begin{pmatrix}\lambda_1 &amp; 0 \\ 0 &amp; \lambda_2\end{pmatrix}$</span>，故<span role="math">$A^n=P\begin{pmatrix}\lambda_1^n &amp; 0 \\ 0 &amp; \lambda_2^n\end{pmatrix}P^{-1}$</span>，于是：</p>
<div role="math">$$
\begin{aligned}
\begin{pmatrix}
F_{n+1} \\
F_n
\end{pmatrix}
& = 
A^{n}
\begin{pmatrix}1 \\0\end{pmatrix}\\
& = 
\begin{pmatrix}1 & 1\\ \lambda_2 & \lambda_1\end{pmatrix}
\begin{pmatrix}(\lambda_1)^n & 0 \\ 0 & (\lambda_2)^n\end{pmatrix}
\begin{pmatrix} \frac{\sqrt{5}-1}{2\sqrt{5}}\\ \frac{1+\sqrt{5}}{2\sqrt{5}}\end{pmatrix}\\
& = 
\begin{pmatrix}1 & 1\\ \lambda_2 & \lambda_1\end{pmatrix}
\begin{pmatrix}\frac{\sqrt{5}-1}{2\sqrt{5}}(\lambda_1)^n \\ \frac{1+\sqrt{5}}{2\sqrt{5}}(\lambda_2)^n\end{pmatrix}
\end{aligned}
$$</div>
<p>因此：</p>
<div role="math">$$
\begin{aligned}
F_n
& = 
\lambda_2\cdot \frac{\sqrt{5}-1}{2\sqrt{5}}(\lambda_1)^n+\lambda_1\cdot\frac{1+\sqrt{5}}{2\sqrt{5}}(\lambda_2)^n\\
& = 
\frac{1}{\sqrt{5}}[(\lambda_2)^n-(\lambda_1)^n]
\end{aligned}
$$</div>
<p>参考：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/25217301/answer/158291644">斐波那契数列通项公式是怎样推导出来的？ - 面无表情的仔仔的回答 - 知乎</a></p>
<h3 id="利用通项公式计算">利用通项公式计算<a class="header-anchor" href="#利用通项公式计算">#</a></h3>
<p>这种方式本质上还是利用快速幂计算，不过不需要矩阵了。</p>
<p>首先考虑一下通项公式中的根号与分式如何处理，假设模数为<span role="math">$M$</span>，以<span role="math">$\frac{1+\sqrt{5}}{2}$</span>为例，假设<span role="math">$x\equiv\frac{1+\sqrt{5}}{2}\pmod{M}$</span>，则有<span role="math">$(2x-1)^2\equiv5\pmod{M}$</span>。</p>
<p>以<span role="math">$M=10^9+9$</span>为例，直接暴力求出x。（需要运行几分钟，其实有更快的算法，但是较为复杂，就先不讲了）</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">M = <span class="number">10</span>**<span class="number">9</span> + <span class="number">9</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, M):</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span>*x-<span class="number">1</span>)**<span class="number">2</span> % M == <span class="number">5</span>:</span><br><span class="line">        print(x)</span><br><span class="line"><span class="comment"># 运行结果：</span></span><br><span class="line"><span class="comment"># 308495997</span></span><br><span class="line"><span class="comment"># 691504013</span></span><br></pre></td></tr></table></figure>
<p>另一个解是<span role="math">$\frac{1-\sqrt{5}}{2}$</span>。同理计算出<span role="math">$\frac{1}{\sqrt{5}}$</span>的结果为<code>276601605</code>、<code>723398404</code>，通过<strong>尝试</strong>我们可以找出正确的组合。</p>
<p>对应题目：<a target="_blank" rel="noopener" href="https://www.51nod.com/Challenge/Problem.html#problemId=1242">51Nod1242 斐波那契数列的第N项</a></p>
<p>这样我们就可以写出非常简短的代码：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n, m, p, s = <span class="built_in">int</span>(<span class="built_in">input</span>()), <span class="number">10</span>**<span class="number">9</span>+<span class="number">9</span>, <span class="number">308495997</span>, <span class="number">723398404</span></span><br><span class="line">print(s*(<span class="built_in">pow</span>(p,n,m)-<span class="built_in">pow</span>(m-p+<span class="number">1</span>,n,m))%m)</span><br></pre></td></tr></table></figure>
<p>注：python的pow自带快速幂，时间复杂度仍然是<span role="math">$O(\log n)$</span>。python实现的取模运算保证结果为非负数，因此减法部分不用考虑负数问题。</p>
<h2 id="斐波那契数列相关难题">斐波那契数列相关难题<a class="header-anchor" href="#斐波那契数列相关难题">#</a></h2>
<p>部分题目来自：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/19980193">斐波那契数列的那些题</a>。</p>
<p>这些题目十分有难度，后续会慢慢补上。。。</p>
<h3 id="k次幂求和">k次幂求和<a class="header-anchor" href="#k次幂求和">#</a></h3>
<p>对应题目：<a target="_blank" rel="noopener" href="http://www.51nod.com/Challenge/Problem.html#problemId=1236">51Nod1236 序列求和 V3</a>、<a target="_blank" rel="noopener" href="https://zoj.pintia.cn/problem-sets/91827364500/problems/91827369735">ZOJ3774 Power of Fibonacci</a></p>
<p>不妨设<span role="math">$\phi=\frac{1+\sqrt{5}}{2}$</span>,<span role="math">$\bar\phi=\frac{1-\sqrt{5}}{2}$</span>。</p>
<p>则有<span role="math">$F_n=\frac{1}{\sqrt{5}}(\phi^n-\bar\phi^n)$</span>。</p>
<p>那么：<span role="math">$F_n^k=(\frac{1}{\sqrt{5}})^k(\phi^n-\bar\phi^n)^k$</span>。</p>
<p>利用二项式定理展开得：</p>
<div role="math">$$
F_n^k=(\frac{1}{\sqrt{5}})^k\sum_{i=0}^kC_k^i(\phi^n)^{k-i}(-\bar\phi^n)^i
$$</div>
<p>求前缀和计算得：</p>
<div role="math">$$
\begin{aligned}
S_n
& =  
\sum_{i=1}^nF_i^k\\
& =  
\sum_{i=1}^n(\frac{1}{\sqrt{5}})^k\sum_{j=0}^kC_k^j(\phi^i)^{k-j}(-\bar\phi^i)^j\\
& =  
(\frac{1}{\sqrt{5}})^k\sum_{i=1}^n\sum_{j=0}^k (-1)^j C_k^j \phi^{i(k-j)} \bar\phi^{ij}\\
\end{aligned}
$$</div>
<p>变换求值顺序（将j看成定值）有：</p>
<div role="math">$$
S_n = (\frac{1}{\sqrt{5}})^k\sum_{j=0}^k (-1)^j C_k^j \sum_{i=1}^n (\phi^{k-j} \bar\phi^j)^i\\
$$</div>
<p>不妨设<span role="math">$q=\phi^{k-j} \bar\phi^j$</span>，若<span role="math">$q=1$</span>，则<span role="math">$\sum\limits_{i=1}^n (\phi^{k-j} \bar\phi^j)^i=n$</span>，否则利用等比数列求和公式计算得<span role="math">$\frac{q\cdot (1-q^n)}{1-q}$</span>。<br>
于是我们预处理出阶乘、以及两个常量的幂次，即可计算，时间复杂度<span role="math">$O(K+TK\log n)$</span>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll M = <span class="number">1e9</span> + <span class="number">9</span>;</span><br><span class="line">ll phi[N], phj[N], fac[N];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i, a, b) for (int i = a; i &lt; b; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRE(arr, n) arr[0] = 1; FOR(i, 1, N) arr[i] = arr[i-1]*n%M</span></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ans = ans * x % M;</span><br><span class="line">        x = x * x % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">inv</span><span class="params">(ll x)</span> </span>&#123; <span class="keyword">return</span> qpow(x, M<span class="number">-2</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    PRE(fac, i); PRE(phi, <span class="number">691504013</span>); PRE(phj, <span class="number">308495997</span>);</span><br><span class="line">    <span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        ll n, k; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        FOR(j, <span class="number">0</span>, k+<span class="number">1</span>) &#123;</span><br><span class="line">            ll q = phi[k-j]*phj[j]%M;</span><br><span class="line">            ll com = fac[k]*inv(fac[j]*fac[k-j]%M)%M;</span><br><span class="line">            ll prod = (q==<span class="number">1</span>) ? (n%M) : (q*(qpow(q,n)<span class="number">-1</span>)%M*inv(q<span class="number">-1</span>)%M);</span><br><span class="line">            ans = (j&amp;<span class="number">1</span>) ? (ans-com*prod)%M : (ans+com*prod)%M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (ans*qpow(<span class="number">276601605</span>, k)%M+M)%M &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺带一提，我还尝试用Python写这题（理论复杂度应该没有问题），发现可以通过51Nod（时限为18s）但是无法通过ZOJ（时限为5s）。从51Nod的测试结果来看，上面的C++程序只跑了不到1s，而Python写法最多要跑10s。</p>
<blockquote>
<p>不同语言的时间限制和内存限制是相同的吗？<br>
是相同的，我们认为选择合适的编程语言也是一项必备技能，所以没有为不同语言设置不同的限制条件。（来自ZOJ）</p>
</blockquote>
<p>如果有知道如何优化Python时间的希望能留言告诉我一下。</p>
<figure class="highlight py"><figcaption><span>点击展开代码 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">t, m, fac = <span class="built_in">int</span>(<span class="built_in">input</span>()), <span class="number">10</span>**<span class="number">9</span>+<span class="number">9</span>, [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100001</span>): fac.append(fac[-<span class="number">1</span>]*i%m) <span class="comment"># 预处理阶乘</span></span><br><span class="line">inv = <span class="keyword">lambda</span> x: <span class="built_in">pow</span>(x, m-<span class="number">2</span>, m) <span class="comment"># 计算逆元</span></span><br><span class="line">phi, phibar = [<span class="number">1</span>], [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100001</span>): phi.append(phi[-<span class="number">1</span>]*<span class="number">691504013</span>%m)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100001</span>): phibar.append(phibar[-<span class="number">1</span>]*<span class="number">308495997</span>%m)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(t):</span><br><span class="line">    n, k = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>):</span><br><span class="line">        q = phi[k-j]*phibar[j]%m</span><br><span class="line">        com = fac[k]*inv(fac[j]*fac[k-j]%m)%m</span><br><span class="line">        prod = n <span class="keyword">if</span> q==<span class="number">1</span> <span class="keyword">else</span> q*(m+<span class="number">1</span>-<span class="built_in">pow</span>(q, n, m))%m*inv(m+<span class="number">1</span>-q)%m</span><br><span class="line">        sgn = <span class="number">1</span> <span class="keyword">if</span> j%<span class="number">2</span>==<span class="number">0</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        ans = (ans + com*sgn*prod + m) % m</span><br><span class="line">    print(ans*<span class="built_in">pow</span>(<span class="number">276601605</span>,k,m)%m)</span><br></pre></td></tr></table></figure>
<h3 id="大范围求循环节">大范围求循环节<a class="header-anchor" href="#大范围求循环节">#</a></h3>
<p>对应题目：<a target="_blank" rel="noopener" href="http://www.51nod.com/Challenge/Problem.html#problemId=1195">51Nod1195 斐波那契数列的循环节</a></p>
<p>这题是之前小范围求循环节的加强版，质数的范围最大可以到<span role="math">$10^9$</span>。可以再仔细阅读一下这篇论文：<a href="/asset/The%20Period%20of%20the%20Fibonacci%20Sequence%20Modulo%20j.pdf">The Period of the Fibonacci Sequence Modulo j.pdf</a>。</p>
<p>主要利用这条性质加速计算：</p>
<blockquote>
<p>对于质数<span role="math">$p &gt; 5$</span>，如果5是模p的二次剩余，那么模p意义下的循环节长度是(p-1)的因子，否则是(2p+2)的因子。</p>
</blockquote>
<p>利用<a target="_blank" rel="noopener" href="https://oi-wiki.org/math/quad-residue/#_4">欧拉判定准则</a>来判断<a target="_blank" rel="noopener" href="https://oi-wiki.org/math/quad-residue/">二次剩余</a>。</p>
<p>代码中还用到了一些数论方面的知识，例如<a target="_blank" rel="noopener" href="https://oi-wiki.org/math/sieve/#_2">素数筛法</a>、质因数分解、枚举因子、<a target="_blank" rel="noopener" href="https://oi-wiki.org/math/quad-residue/#_4">判二次剩余</a>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="comment">// 质数表大小以及小范围常量表</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>, pd[<span class="number">6</span>]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">20</span>&#125;; </span><br><span class="line"><span class="function">ll <span class="title">lcm</span><span class="params">(ll a, ll b)</span> </span>&#123; <span class="keyword">return</span> a / __gcd(a, b) * b; &#125;</span><br><span class="line"><span class="comment">// 矩阵快速幂求斐波那契数列</span></span><br><span class="line"><span class="function">ll <span class="title">fib</span><span class="params">(ll n, ll mod, ll a = <span class="number">1</span>, ll b = <span class="number">0</span>, ll p = <span class="number">0</span>, ll q = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">1</span>) <span class="keyword">return</span> fib(n<span class="number">-1</span>, mod, (b*q+a*q+a*p)%mod, (b*p+a*q)%mod, p, q);</span><br><span class="line">    <span class="keyword">return</span> fib(n/<span class="number">2</span>, mod, a, b, (p*p+q*q)%mod, (q*q+<span class="number">2</span>*q*p)%mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查mod下循环节是否为perd</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_perd</span><span class="params">(ll mod, ll perd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fib(perd, mod)==<span class="number">0</span> &amp;&amp; fib(perd+<span class="number">1</span>, mod)==<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; is_prime;</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; prime;</span><br><span class="line"><span class="comment">// 素数筛法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_prime</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    is_prime.resize(N, <span class="literal">true</span>);</span><br><span class="line">    is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!is_prime[i]) <span class="keyword">continue</span>;</span><br><span class="line">        prime.push_back(i);</span><br><span class="line">        <span class="keyword">for</span> (ll j = i * i; j &lt; N; j += i) is_prime[j] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 质因数分解</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;ll, ll&gt;&gt; get_factor(ll n) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;ll, ll&gt;&gt; factor;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p : prime) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &gt; n / p) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (n % p) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n % p == <span class="number">0</span>) cnt++, n /= p;</span><br><span class="line">        factor.emplace_back(p, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) factor.emplace_back(n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> factor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 快速幂</span></span><br><span class="line"><span class="function">ll <span class="title">pow</span><span class="params">(ll x, ll y, ll mod = <span class="number">9e18</span>, ll ans = <span class="number">1</span>)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (!y) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">if</span> (y&amp;<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">pow</span>(x, y<span class="number">-1</span>, mod, ans*x%mod);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">pow</span>(x*x%mod, y&gt;&gt;<span class="number">1</span>, mod, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断n是否为p的二次剩余</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_quad</span><span class="params">(ll n, ll p)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(n, (p<span class="number">-1</span>)&gt;&gt;<span class="number">1</span>, p) == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 枚举因子</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;ll&gt; <span class="title">perm_factor</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> factor = get_factor(n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; divisor;</span><br><span class="line">    function&lt;<span class="keyword">void</span>(ll, <span class="keyword">int</span>)&gt; dfs = [&amp;](ll d, <span class="keyword">int</span> i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == (<span class="keyword">int</span>)factor.size()) <span class="keyword">return</span> divisor.push_back(d);</span><br><span class="line">        <span class="keyword">for</span> (ll j = <span class="number">0</span>; j &lt;= factor[i].second; j++)</span><br><span class="line">            dfs(d * <span class="built_in">pow</span>(factor[i].first, j), i+<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">1</span>, <span class="number">0</span>), divisor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 求循环节</span></span><br><span class="line"><span class="function">ll <span class="title">fib_pred</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">5</span>) <span class="keyword">return</span> pd[n]; <span class="comment">// 小于等于5的数不满足该性质</span></span><br><span class="line">    ll t = is_quad(<span class="number">5</span>, n) ? (n<span class="number">-1</span>) : (<span class="number">2</span>*n+<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> d : perm_factor(t)) <span class="comment">// 枚举所有t的因子</span></span><br><span class="line">        <span class="keyword">if</span> (check_perd(n, d)) <span class="keyword">return</span> d;</span><br><span class="line">    <span class="keyword">return</span> assert(<span class="literal">false</span>), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理每一组数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n, ans = <span class="number">1</span>; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> f : get_factor(n))</span><br><span class="line">        ans = lcm(ans, <span class="built_in">pow</span>(f.first, f.second<span class="number">-1</span>) * fib_pred(f.first));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    get_prime();</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhuangmezhuang/article/details/52627308">参考博客</a></p>
<h3 id="最小公倍数">最小公倍数<a class="header-anchor" href="#最小公倍数">#</a></h3>
<p>对应题目：<a target="_blank" rel="noopener" href="http://www.51nod.com/Challenge/Problem.html#problemId=1355">51Nod1355 斐波那契的最小公倍数</a></p>
<h3 id="找位置">找位置<a class="header-anchor" href="#找位置">#</a></h3>
<p>对应题目：<a target="_blank" rel="noopener" href="http://www.51nod.com/Challenge/Problem.html#problemId=1145">51Nod1145 斐波那契数列</a></p>
<h3 id="求-span-role-math-f-n-mod-f-k-span">求<span role="math">$f(n)\mod f(k)$</span><a class="header-anchor" href="#求-span-role-math-f-n-mod-f-k-span">#</a></h3>
<p>对应题目：<a target="_blank" rel="noopener" href="http://www.51nod.com/Challenge/Problem.html#problemId=1194">51Nod1194 Fib(N) mod Fib(K)</a></p>
<h3 id="广义斐波那契数列求循环节">广义斐波那契数列求循环节<a class="header-anchor" href="#广义斐波那契数列求循环节">#</a></h3>
<p>对应题目：<a target="_blank" rel="noopener" href="http://www.51nod.com/Challenge/Problem.html#problemId=1263">1263 广义斐波那契数列</a></p>
<p>参考论文：<a href="/asset/PeriodRankOrderMMofficial.pdf">PeriodRankOrderMMofficial.pdf</a></p>
<h3 id="斐波那契字符串">斐波那契字符串<a class="header-anchor" href="#斐波那契字符串">#</a></h3>
<p>对应题目：<a target="_blank" rel="noopener" href="http://www.51nod.com/Challenge/Problem.html#problemId=1146">51Nod 1146 斐波那契字符串</a></p>
<h3 id="span-role-math-pi-span-斐波那契数列"><span role="math">$\pi$</span>斐波那契数列<a class="header-anchor" href="#span-role-math-pi-span-斐波那契数列">#</a></h3>
<p>对应题目：<a target="_blank" rel="noopener" href="http://www.51nod.com/Challenge/Problem.html#problemId=1149">51Nod1149 Pi的递推式</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>斐波那契数列总结</p><p><a href="https://blog.tootal.xyz/posts/fibonacci-summary/">https://blog.tootal.xyz/posts/fibonacci-summary/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>黄智权</p></div></div><div class="level-item is-narrow"><div><h6>本文发布于</h6><p>2020-12-05</p></div></div><div class="level-item is-narrow"><div><h6>本文更新于</h6><p>2020-12-08</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/ACM/">ACM</a><a class="link-muted mr-2" rel="tag" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="link-muted mr-2" rel="tag" href="/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/">斐波那契数列</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="http://afdian.net/@tootal" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/asset/alipay.webp" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/asset/wechat_pay.webp" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/posts/interview-2year/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">怎样花两年时间去面试一个人</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/posts/scutpc2020-summary/"><span class="level-item">2020 年「计算机科学与工程学院」新生赛总结</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content twikoo" id="twikoo"></div><script src="https://cdn.jsdelivr.net/npm/twikoo@1.2.0/dist/twikoo.all.min.js"></script><script>twikoo.init({
      envId: 'tootal-6g2y019v6b37e4be',
      region: 'ap-guangzhou',
      path: "'/posts/fibonacci-summary/'",
      katex: {
        delimiters: 
        [
          {left: "$$", right: "$$", display: true},
          {left: "$", right: "$", display: false}
        ],
        throwOnError: false
      }
    });</script></div></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#小范围求-span-role-math-f-n-span"><span class="level-left"><span class="level-item">小范围求$f(n)$</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#span-role-math-n-le-39-span"><span class="level-left"><span class="level-item">$n \le 39$</span></span></a></li><li><a class="level is-mobile" href="#span-role-math-n-le-46-span"><span class="level-left"><span class="level-item">$n \le 46$</span></span></a></li><li><a class="level is-mobile" href="#span-role-math-n-le-100-span"><span class="level-left"><span class="level-item">$n \le 100$</span></span></a></li><li><a class="level is-mobile" href="#span-role-math-n-le-4786-span"><span class="level-left"><span class="level-item">$n \le 4786$</span></span></a></li><li><a class="level is-mobile" href="#其他写法"><span class="level-left"><span class="level-item">其他写法</span></span></a></li></ul></li><li><a class="level is-mobile" href="#大范围求-span-role-math-f-n-span"><span class="level-left"><span class="level-item">大范围求$f(n)$</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#span-role-math-n-le-10-9-span"><span class="level-left"><span class="level-item">$n \le 10^9$</span></span></a></li><li><a class="level is-mobile" href="#span-role-math-n-le-10-18-span"><span class="level-left"><span class="level-item">$n \le 10^{18}$</span></span></a></li><li><a class="level is-mobile" href="#span-role-math-n-le-10-10-6-span"><span class="level-left"><span class="level-item">$n \le 10^{10^{6}}$</span></span></a></li><li><a class="level is-mobile" href="#其他写法-2"><span class="level-left"><span class="level-item">其他写法</span></span></a></li></ul></li><li><a class="level is-mobile" href="#斐波那契相关问题"><span class="level-left"><span class="level-item">斐波那契相关问题</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#广义斐波那契数列"><span class="level-left"><span class="level-item">广义斐波那契数列</span></span></a></li><li><a class="level is-mobile" href="#求区间和"><span class="level-left"><span class="level-item">求区间和</span></span></a></li><li><a class="level is-mobile" href="#循环节加速"><span class="level-left"><span class="level-item">循环节加速</span></span></a></li><li><a class="level is-mobile" href="#小范围求循环节"><span class="level-left"><span class="level-item">小范围求循环节</span></span></a></li><li><a class="level is-mobile" href="#通项公式"><span class="level-left"><span class="level-item">通项公式</span></span></a></li><li><a class="level is-mobile" href="#利用通项公式计算"><span class="level-left"><span class="level-item">利用通项公式计算</span></span></a></li></ul></li><li><a class="level is-mobile" href="#斐波那契数列相关难题"><span class="level-left"><span class="level-item">斐波那契数列相关难题</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#k次幂求和"><span class="level-left"><span class="level-item">k次幂求和</span></span></a></li><li><a class="level is-mobile" href="#大范围求循环节"><span class="level-left"><span class="level-item">大范围求循环节</span></span></a></li><li><a class="level is-mobile" href="#最小公倍数"><span class="level-left"><span class="level-item">最小公倍数</span></span></a></li><li><a class="level is-mobile" href="#找位置"><span class="level-left"><span class="level-item">找位置</span></span></a></li><li><a class="level is-mobile" href="#求-span-role-math-f-n-mod-f-k-span"><span class="level-left"><span class="level-item">求$f(n)\mod f(k)$</span></span></a></li><li><a class="level is-mobile" href="#广义斐波那契数列求循环节"><span class="level-left"><span class="level-item">广义斐波那契数列求循环节</span></span></a></li><li><a class="level is-mobile" href="#斐波那契字符串"><span class="level-left"><span class="level-item">斐波那契字符串</span></span></a></li><li><a class="level is-mobile" href="#span-role-math-pi-span-斐波那契数列"><span class="level-left"><span class="level-item">$\pi$斐波那契数列</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">头头博客</a><p class="is-size-7"><span>&copy; 2021 黄智权</span><span>&nbsp;&nbsp; 由 <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>&nbsp;&&nbsp;<a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a> 驱动</span><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span><br><a href="http://beian.miit.gov.cn/" target="_blank" rel="noopener">赣ICP备20007667号-1</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="View on GitHub" href="https://github.com/tootal/tootal.github.io"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/mhchem.js" defer></script><script>
    var katex_config = {
      delimiters: 
      [
        {left: "$$", right: "$$", display: true},
        {left: "$", right: "$", display: false}
      ],
      strict: false,
      throwOnError: false
    };
    window.addEventListener("load", function() {
      document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
        renderMathInElement(element, katex_config);
      });
      document.querySelectorAll('#toc .level-item').forEach(function(element) {
        renderMathInElement(element, katex_config);
      });
    });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>