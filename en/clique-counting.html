<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>The Power of Pivoting for Exact Clique Counting - 头头博客</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#fff"><meta name="application-name" content="头头博客"><meta name="msapplication-TileImage" content="/asset/favicon144.png"><meta name="msapplication-TileColor" content="#fff"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="头头博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><link rel="apple-touch-icon" sizes="96x96" href="/asset/favicon96.png"><link rel="apple-touch-icon" sizes="144x144" href="/asset/favicon144.png"><link rel="apple-touch-icon" sizes="192x192" href="/asset/favicon192.png"><meta name="description" content="ABSTRACT# Clique counting is a fundamental task in network analysis, and even the simplest setting of $3$-cliques (triangles) has been the center of much recent research.  Getting the count of $k$-cl"><meta property="og:type" content="blog"><meta property="og:title" content="The Power of Pivoting for Exact Clique Counting"><meta property="og:url" content="https://blog.tootal.xyz/en/clique-counting"><meta property="og:site_name" content="头头博客"><meta property="og:description" content="ABSTRACT# Clique counting is a fundamental task in network analysis, and even the simplest setting of $3$-cliques (triangles) has been the center of much recent research.  Getting the count of $k$-cl"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://blog.tootal.xyz/asset/timings-big4-maxk.png"><meta property="og:image" content="https://blog.tootal.xyz/asset/as-skitter-occurrences.png"><meta property="og:image" content="https://blog.tootal.xyz/asset/web-Stanford-occurrences-5.png"><meta property="og:image" content="https://blog.tootal.xyz/en/nCalls_vs_m.png"><meta property="og:image" content="https://blog.tootal.xyz/en/trends.png"><meta property="og:image" content="https://blog.tootal.xyz/en/trends-dblp.png"><meta property="article:published_time" content="2021-01-14T12:43:51.000Z"><meta property="article:modified_time" content="2021-01-14T12:43:51.000Z"><meta property="article:author" content="黄智权"><meta property="article:tag" content="算法"><meta property="article:tag" content="图论"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="../asset/timings-big4-maxk.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.tootal.xyz/en/clique-counting"},"headline":"头头博客","image":["https://blog.tootal.xyz/asset/timings-big4-maxk.png","https://blog.tootal.xyz/asset/as-skitter-occurrences.png","https://blog.tootal.xyz/asset/web-Stanford-occurrences-5.png","https://blog.tootal.xyz/en/nCalls_vs_m.png","https://blog.tootal.xyz/en/trends.png","https://blog.tootal.xyz/en/trends-dblp.png"],"datePublished":"2021-01-14T12:43:51.000Z","dateModified":"2021-01-14T12:43:51.000Z","author":{"@type":"Person","name":"黄智权"},"description":"ABSTRACT# Clique counting is a fundamental task in network analysis, and even the simplest setting of $3$-cliques (triangles) has been the center of much recent research.  Getting the count of $k$-cl"}</script><link rel="canonical" href="https://blog.tootal.xyz/en/clique-counting"><link rel="icon" href="/asset/favicon.png"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/5.15.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?a0752fdc3e7a9d538e1cb45af25201a4";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="头头博客" type="application/atom+xml">
</head><body class="is-1-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Tootal Blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Index</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" target="_blank" rel="noopener" href="https://note.tootal.xyz">Note</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="View on GitHub" href="https://github.com/tootal/tootal.github.io"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-12"><div class="card"><article class="card-content article" role="article"><h1 class="title is-3 is-size-4-mobile">The Power of Pivoting for Exact Clique Counting</h1><div class="content"><!--  author: Shweta Jain authornote: Shweta Jain and C. Seshadhri acknowledge the support of NSF Awards CCF-1740850, CCF-1813165, and ARO Award W911NF1910294. institution: University of California, Santa Cruz city: Santa Cruz, CA country: USA email: sjain12@ucsc.edu

author: C. Seshadhri institution: University of California, Santa Cruz city: Santa Cruz, CA country: USA email: sesh@ucsc.edu  -->
<h2 id="ABSTRACT">ABSTRACT<a class="header-anchor" href="#ABSTRACT">#</a></h2>
<p>Clique counting is a fundamental task in network analysis, and even the simplest setting of <span role="math">$3$</span>-cliques (triangles) has been the center of much recent research.  Getting the count of <span role="math">$k$</span>-cliques for larger <span role="math">$k$</span> is algorithmically challenging, due to the exponential blowup in the search space of large cliques. But a number of recent applications (especially for community detection or clustering) use larger clique counts.  Moreover, one often desires <em>local</em> counts, the number of <span role="math">$k$</span>-cliques per vertex/edge.</p>
<p>Our main result is PIVOTER, an algorithm that exactly counts the number of <span role="math">$k$</span>-cliques, <em>for all values of <span role="math">$k$</span></em>. It is surprisingly effective in practice, and is able to get clique counts of graphs that were beyond the reach of previous work. For example, PIVOTER gets all clique counts in a social network with a 100M edges within two hours on a commodity machine. Previous parallel algorithms do not terminate in days. PIVOTER can also feasibly get local per-vertex and per-edge <span role="math">$k$</span>-clique counts (for all <span role="math">$k$</span>) for many public data sets with tens of millions of edges. To the best of our knowledge, this is the first algorithm that achieves such results.</p>
<p>The main insight is the construction of a Succinct Clique Tree (SCT) that stores a compressed unique representation of all cliques in an input graph. It is built using a technique called <em>pivoting</em>, a classic approach by Bron-Kerbosch to reduce the  recursion tree of backtracking algorithms for maximal cliques. Remarkably, the SCT can be built without actually enumerating all cliques, and provides a succinct data structure from which exact clique statistics (<span role="math">$k$</span>-clique counts, local counts) can be read off efficiently.</p>
<a id="more"></a>
<div id="sec:intro"></div>
<h2 id="INTRODUCTION">INTRODUCTION<a class="header-anchor" href="#INTRODUCTION">#</a></h2>
<p>Subgraph counting (also known as motif counting, graphlet counting) is a fundamental algorithmic problem in network analysis, widely applied in domains such as social network analysis, bioinformatics, cybersecurity, and physics (refer to tutorial<span class="cite-container">[<a href="#cite:SeTi19" class="cite-label">27</a>]</span> and references within). One of the most important cases is that of <em>clique counting</em>. A <span role="math">$k$</span>-clique is a complete subgraph on <span role="math">$k$</span> vertices, and has great significance in network analysis (Chap. 11 of<span class="cite-container">[<a href="#cite:HR05" class="cite-label">16</a>]</span> and Chap. 2 of<span class="cite-container">[<a href="#cite:J10" class="cite-label">17</a>]</span>). Indeed, just the special case of <span role="math">$k=3$</span> (triangle counting) has a rich history in modern network science. General clique counting has received much attention in recent times <span class="cite-container">[<a href="#cite:AhNe+15" class="cite-label">2</a>,<a href="#cite:DBS18" class="cite-label">11</a>,<a href="#cite:Escape" class="cite-label">14</a>,<a href="#cite:FFF15" class="cite-label">15</a>,<a href="#cite:JS17" class="cite-label">18</a>,<a href="#cite:JhSePi15" class="cite-label">19</a>,<a href="#cite:MarcusS10" class="cite-label">21</a>]</span>. There is a line of recent work on exploiting clique counts for community detection and dense subgraph discovery <span class="cite-container">[<a href="#cite:BeGlLe16" class="cite-label">6</a>,<a href="#cite:SaSePi14" class="cite-label">25</a>,<a href="#cite:TPM17" class="cite-label">28</a>,<a href="#cite:Ts15" class="cite-label">30</a>,<a href="#cite:YiBiKe19" class="cite-label">35</a>,<a href="#cite:lu2018community" class="cite-label">37</a>]</span>.</p>
<p>Despite much effort on this problem, it has been challenging to get scalable algorithms for clique counting. There is a large literature for counting <span role="math">$3$</span>-cliques (triangles) and  some of these methods have been extended to counting cliques upto size <span role="math">$5$</span><span class="cite-container">[<a href="#cite:AhNe+15" class="cite-label">2</a>,<a href="#cite:Escape" class="cite-label">14</a>,<a href="#cite:JhSePi15" class="cite-label">19</a>,<a href="#cite:MarcusS10" class="cite-label">21</a>]</span>. However, practical algorithms for counting cliques beyond size <span role="math">$5$</span> have proven to be much harder, and the reason for this is combinatorial explosion. Essentially, as <span role="math">$k$</span> increases,  the number of <span role="math">$k$</span>-cliques blows up.  For large graphs, some recent practical algorithms have succeeded in counting up to (around) 10-cliques<span class="cite-container">[<a href="#cite:DBS18" class="cite-label">11</a>,<a href="#cite:FFF15" class="cite-label">15</a>,<a href="#cite:JS17" class="cite-label">18</a>]</span>. They either use randomized approximation or parallelism to speed up their counting. Besides the obvious problem that they do not scale for larger <span role="math">$k$</span>, it is difficult to obtain more refined clique counts (such  as counts for every vertex or every edge).</p>
<div class="justified-gallery"> <img src="../asset/timings-big4-maxk.png" title="Timings" alt="Timings" id="fig:timings" /><img src="../asset/as-skitter-occurrences.png" title="Frequency distribution" alt="Frequency distribution" id="fig:soc-pokec-occurrences" /><img src="../asset/web-Stanford-occurrences-5.png" title="Frequency distribution" alt="Frequency distribution" id="fig:web-Stanford-occurrences" /> </div>                 <div class="figure-more"> 
<p><a class="figure" title="Timings" href="#fig:timings" >Figure 1</a> shows the comparison of time taken (in seconds) by PIVOTER for 4 of our largest graphs to count <em>all</em> <span role="math">$k-$</span>cliques with the time taken by kClist40 (the parallel version of the state of the art algorithm kClist that uses 40 threads) to count the number of <span role="math">$k-$</span>cliques, where <span role="math">$k$</span> is the maximum clique size in each graph. For Stanford, BerkStan, as-skitter, orkut, the maximum clique sizes were 61, 201, 67 and 51 resp. PIVOTER terminated for most graphs in minutes, (except for orkut, for which it took about 2 hours) whereas kClist40 had not terminated even after 3 days, giving a speedup of 100x to 10000x. <a class="figure" title="Timings" href="#fig:timings" >Figure 1</a> also shows the time taken by PIVOTER to obtain the per-vertex and per-edge <span role="math">$k-$</span>clique counts. They were within a factor of the time taken to obtain global <span role="math">$k-$</span>clique counts. <a class="figure" title="Frequency distribution" href="#fig:soc-pokec-occurrences" >Figure 2</a> and  <a class="figure" title="Frequency distribution" href="#fig:web-Stanford-occurrences" >Figure 3</a> shows the frequency distribution of <span role="math">$k$</span>-cliques i.e. for every number <span role="math">$r$</span> on the x-axis, the y-axis shows the number of vertices that participate in <span role="math">$r$</span> <span role="math">$k$</span>-cliques, for <span role="math">$k \in [5, 10, 15, 20, 25]$</span> for as-skitter and web-Stanford graphs.</p>
 </div>
<div id="sec:problem"></div>
<h3 id="Problem-Statement">Problem Statement<a class="header-anchor" href="#Problem-Statement">#</a></h3>
<p>We are given an undirected, simple graph <span role="math">$G(V,E)$</span>. For <span role="math">$k \geq 3$</span>, a <span role="math">$k$</span>-clique  is a set of <span role="math">$k$</span> vertices that induce a complete subgraph (it contains all edges among the <span role="math">$k$</span> vertices). We will denote the number of <span role="math">$k$</span>-cliques as <span role="math">$C_k$</span>. For a vertex <span role="math">$v \in V$</span>, we use <span role="math">$c_k(v)$</span> to denote the number of <span role="math">$k$</span>-cliques that <span role="math">$v$</span> participates in. Analogously, we define <span role="math">$c_k(e)$</span> for edge <span role="math">$e \in E$</span>.</p>
<p>We focus on the following problems, in increasing order of difficulty.  We stress that <span role="math">$k$</span> is <em>not</em> part of the input, and we want results for all values of <span role="math">$k$</span>.</p>
<ul>
<li>Global clique counts: Output, <span role="math">$\forall k \geq 3$</span>, <span role="math">$C_k$</span>.</li>
<li>Per-vertex clique counts: Output, <span role="math">$\forall k$</span>, <span role="math">$\forall v \in V$</span>, the value <span role="math">$c_k(v)$</span>.</li>
<li>Per-edge clique counts: Output, <span role="math">$\forall k$</span>, <span role="math">$\forall e \in E$</span>, the value <span role="math">$c_k(e)$</span>.</li>
</ul>
<p>The per-vertex and per-edge counts are sometimes called <em>local counts</em>. In clustering applications, the local counts are used as vertex or edge weights, and are therefore even more useful than global counts<span class="cite-container">[<a href="#cite:BeGlLe16" class="cite-label">6</a>,<a href="#cite:SaSePi14" class="cite-label">25</a>,<a href="#cite:TPM17" class="cite-label">28</a>,<a href="#cite:Ts15" class="cite-label">30</a>,<a href="#cite:YiBiKe19" class="cite-label">35</a>,<a href="#cite:lu2018community" class="cite-label">37</a>]</span>.</p>
<p><strong>Challenges:</strong> Even the simplest problem of getting global  clique counts subsumes a number of recent results on clique counting <span class="cite-container">[<a href="#cite:DBS18" class="cite-label">11</a>,<a href="#cite:FFF15" class="cite-label">15</a>,<a href="#cite:JS17" class="cite-label">18</a>]</span>. The main challenge is combinatorial explosion: for example, the <em>web-Stanford</em> web graph with 2M edges has <em>3000 trillion</em> <span role="math">$15$</span>-cliques. These numbers are even more astronomical for larger graphs. Any method that tries to enumerate is doomed to failure.</p>
<p>Amazingly, recent work by Danisch-Balalau-Sozio uses parallel algorithms to count beyond trillions of cliques. But even their algorithm fails to get all global clique counts for a number of datasets. Randomized methods have been used with some success, but even they cannot estimate all clique counts<span class="cite-container">[<a href="#cite:FFF15" class="cite-label">15</a>,<a href="#cite:JS17" class="cite-label">18</a>]</span>.</p>
<p>Local counting, for all <span role="math">$k$</span>, is even harder, especially given the sheer size of the output. Parallel methods would eventually need to store local counts for every subproblem, which would increase the overall memory footprint. For local counts, sampling would require far too many random variables, each of which need to be sampled many times for convergence. (We give more explanation in <a href="#sec:related">§related</a>.)</p>
<p>This raises the main question:</p>
<p><em>Is there a scalable, exact algorithm for getting all global and local cliques counts, on real-world graphs with millions of edges?</em></p>
<p>To the best of our knowedge, there is no previous algorithm that can solve these problems on even moderate-sized graphs with a few million edges.</p>
<div id="sec:contri"></div>
<h3 id="Main-contributions">Main contributions<a class="header-anchor" href="#Main-contributions">#</a></h3>
<p>Our main contribution is a new practical algorithm PIVOTER for the global and local clique counting problems.</p>
<p><strong>Exact counting without enumeration:</strong> Current methods for exact clique counting perform an <em>enumeration</em>, in that the algorithm explicitly “visits” every clique. Thus, this method cannot scale to counting larger cliques, since the number of cliques is simply too large. Our main insight is that the method of <em>pivoting</em>, used<br>
to reduce recursion trees for maximal clique  enumeration<span class="cite-container">[<a href="#cite:BK73" class="cite-label">5</a>,<a href="#cite:ELS13" class="cite-label">12</a>]</span>, can be applied to counting cliques of all sizes.</p>
<p><strong>Succinct Clique Trees through Pivoting:</strong> We prove that pivoting can be used to construct a special data structure called the <em>Succinct Clique Tree</em> (SCT). The SCT stores a unique representation of all cliques, but is much smaller than the total number of cliques. It can also be built quite efficiently. Additionally, given the tree, one can easily “read off” the number of <span role="math">$k$</span>-cliques  and various local counts in the graph. Remarkably, we can get all counts without storing the entire tree and the storage required at any point is linear in the number of edges.</p>
<p><strong>Excellent practical performance:</strong> We implement PIVOTER on a commodity machine. For global clique counting, PIVOTER is able to process graphs of up to tens of millions of edges in <em>minutes</em>. Previous results either work only for small values of <span role="math">$k$</span> (typically up to <span role="math">$10$</span>) or take much longer. Consider <a class="figure" title="Timings" href="#fig:timings" >Figure 1</a>, where the time of PIVOTER is compared with that of kClist (the state of the art parallel algorithm for clique counting)<span class="cite-container">[<a href="#cite:DBS18" class="cite-label">11</a>]</span>.  In the instances shown kClist did not terminate even after running for 3 days. By contrast, for the largest <em>com-orkut</em> social network with more than 100M edges, PIVOTER gets all values of <span role="math">$C_k$</span> within two hours. (Typically, in this time, kClist gets <span role="math">$k-$</span>clique counts only up to <span role="math">$k \leq 13$</span>.)</p>
<p><strong>Feasible computation of local counts:</strong> PIVOTER is quite efficient for per-vertex counts, and runs in at most twice the time for global counts. The times for local clique counting are given in <a class="figure" title="Timings" href="#fig:timings" >Figure 1</a>. Even for the extremely challenging problem of per-edge counts, in most instances PIVOTER gets these numbers in a few hours. (For the <em>com-orkut</em> social network though, it takes a few days.)</p>
<p>This allows us to get data shown in <a class="figure" title="Frequency distribution" href="#fig:soc-pokec-occurrences" >Figure 2</a> and <a class="figure" title="Frequency distribution" href="#fig:web-Stanford-occurrences" >Figure 3</a>,  that plots the frequency distribution of <span role="math">$k$</span>-cliques. (In other words, for every number <span role="math">$r$</span>, we plot the number of vertices that participate in <span role="math">$r$</span> <span role="math">$k$</span>-cliques.) As mentioned earlier, this information is used for dense subgraph discovery<span class="cite-container">[<a href="#cite:SaSePi14" class="cite-label">25</a>,<a href="#cite:Ts15" class="cite-label">30</a>]</span>.  To the best of our knowledge, this is the first algorithm that is able to get such information for real-world graphs.</p>
<div id="sec:related"></div>
<h3 id="Related-Work">Related Work<a class="header-anchor" href="#Related-Work">#</a></h3>
<p>Subgraph counting has an immensely rich history in network science, ranging from applications across social network analysis, bioinformatics, recommendation systems, graph clustering (we refer the reader to the tutorial<span class="cite-container">[<a href="#cite:SeTi19" class="cite-label">27</a>]</span> and references within). We only describe work directly relevant to clique counting.</p>
<p>The simplest case of clique counting is <em>triangle counting</em>, which has  received much attention from the data mining and algorithms communities. Recent work has shown the relevance of counts of large subgraphs (4, 5 vertex patterns) <span class="cite-container">[<a href="#cite:BeHe+11" class="cite-label">7</a>,<a href="#cite:RKKS17" class="cite-label">23</a>,<a href="#cite:SGB16" class="cite-label">24</a>,<a href="#cite:UganderBK13" class="cite-label">31</a>,<a href="#cite:YiBiKe18" class="cite-label">34</a>]</span>. Local clique counts have played a significant role in a flurry of work on faster and better algorithms for dense subgraph discovery and community detection<span class="cite-container">[<a href="#cite:BeGlLe16" class="cite-label">6</a>,<a href="#cite:SaSePi14" class="cite-label">25</a>,<a href="#cite:TPM17" class="cite-label">28</a>,<a href="#cite:Ts15" class="cite-label">30</a>]</span>. The latter results define the “motif conductance”, where cuts are measured by the number of subgraphs (not just edges) cut. This has been related to higher order clustering coefficients<span class="cite-container">[<a href="#cite:YiBiKe18" class="cite-label">34</a>,<a href="#cite:YiBiKe19" class="cite-label">35</a>]</span>. These quantities are computed using local clique counts, underscoring the importance of these numbers.</p>
<p>The problem of counting cliques (and variants such as counting maximal cliques) has received much attention  both from the applied and theoretical computer science communities<span class="cite-container">[<a href="#cite:AlYuZw94" class="cite-label">3</a>,<a href="#cite:CHKX04" class="cite-label">9</a>,<a href="#cite:ChNi85" class="cite-label">10</a>,<a href="#cite:V09" class="cite-label">32</a>]</span>. Classic techniques like color-coding<span class="cite-container">[<a href="#cite:BetzlerBFKN11" class="cite-label">8</a>,<a href="#cite:ZhWaBu+12" class="cite-label">36</a>]</span> and path sampling<span class="cite-container">[<a href="#cite:JhSePi15" class="cite-label">19</a>,<a href="#cite:SePiKo14" class="cite-label">26</a>,<a href="#cite:WaZh+18" class="cite-label">33</a>]</span> have been employed for counting cliques up to size <span role="math">$5$</span>.</p>
<p>For larger cliques, Finocchi-Finocchi-Fusco gave a MapReduce algorithm that uses orientation and sampling techniques<span class="cite-container">[<a href="#cite:FFF15" class="cite-label">15</a>]</span>. Jain and Seshadhri use methods from extremal combinatorics to give a fast sampling algorithm<span class="cite-container">[<a href="#cite:JS17" class="cite-label">18</a>]</span>, that is arguably the fastest approximate clique counter to date. In a remarkable result, Danisch-Balalau-Sozio gave a parallel implementation (kClist) of a classic algorithm of Chiba-Nishizeki, which is able to enumerate upto trillions of cliques<span class="cite-container">[<a href="#cite:DBS18" class="cite-label">11</a>]</span>. For exact counting, we consider kClist as the state of the art. Despite the collection of clever techniques, none of these methods really scale beyond counting (say) 10-cliques for large graphs.</p>
<p><strong>Why local counting is hard:</strong> Note that either parallelism or sampling is used to tame the combinatorial explosion. Even though (at least for small <span role="math">$k$</span>), one can enumerate all cliques in parallel, local counting requires updating a potentially global data structure, the list of all <span role="math">$c_k(v)$</span> or <span role="math">$c_k(e)$</span> values. To get the benefits of parallelism, one would  either have to duplicate a large data structure or combine results for various threads to get all local counts. While this may be feasible, it adds an extra memory overhead.</p>
<p>Sampling methods typically require some overhead for convergence. For local counts, there are simply too many samples required to get accurate values for (say) all <span role="math">$c_k(v)$</span> values. For these reasons, we strongly believe that new ideas were required to get efficient local counting.</p>
<p><strong>Maximal clique enumeration:</strong> Extremely relevant to our approach is a line of work of maximal clique enumeration. A <em>maximal clique</em> is one that is not contained in a larger clique. Unlike the combinatorial explosion of <span role="math">$k$</span>-cliques, maximal cliques tend to be much fewer. The first algorithm for this problem is the classic Bron-Kerbosch backtracking procedure from the 70s<span class="cite-container">[<a href="#cite:A73" class="cite-label">1</a>,<a href="#cite:BK73" class="cite-label">5</a>]</span>. They also introduced an idea called <em>pivoting</em>, that prunes the recursion tree for efficiency. Tomita-Tanaka-Takahashi gave the first theoretical analysis of pivoting rules, and showed asymptotic improvements<span class="cite-container">[<a href="#cite:Tomita04" class="cite-label">29</a>]</span>. Eppstein-Löeffler- Strash combined these ideas with orientation methods to give a practical and provably fast algorithm for maximal clique enumeration<span class="cite-container">[<a href="#cite:ELS13" class="cite-label">12</a>,<a href="#cite:ES11" class="cite-label">13</a>]</span>. An important empirical observation of this line of work is that the underlying recursion tree created with pivoting is typically small for real-world graphs. This is the starting point  for our work.</p>
<div id="sec:ideas"></div>
<h2 id="MAIN-IDEAS">MAIN IDEAS<a class="header-anchor" href="#MAIN-IDEAS">#</a></h2>
<p>Inspired by the success of maximal clique enumeration through pivoting,  we design the Succinct Clique Tree (SCT) of a graph for clique counting.</p>
<p>To explain the SCT, it is useful to begin with  the simple backtracking algorithm for listing all cliques. For any vertex <span role="math">$v$</span>, let <span role="math">$N(v)$</span> denote the neighborhood of <span role="math">$v$</span>. Any clique containing <span role="math">$v$</span> is formed by adding <span role="math">$v$</span> to a clique contained in <span role="math">$N(v)$</span>.  Thus, we can find all cliques by this simple recursive procedure: for all <span role="math">$v$</span>, recursively enumerate all cliques in <span role="math">$N(v)$</span>. For each such clique, add <span role="math">$v$</span> to get a new clique. It is convenient to think of the recursion tree of this algorithm. Every node of the tree (corresponding to a recursive call) corresponds to a subset <span role="math">$S \subseteq V$</span>, and the subtree of calls enumerates all cliques contained in <span role="math">$S$</span>. A call to <span role="math">$S$</span> makes a recursive call corresponding to every <span role="math">$s \in S$</span>, which is over the set <span role="math">$N(s) \cap S$</span> (the neighbors of <span role="math">$v$</span> in <span role="math">$S$</span>). We can label every edge of the tree (call them <em>links</em> to distinguish from edges of <span role="math">$G$</span>) with a vertex, whose neighborhood leads to the next recursive call. It is not hard to see that the link labels, along any path from a root (that might not end at a leaf), give a clique. Moreover, every clique has such a representation.</p>
<p>Indeed, every permutation of clique forms such a path. A simple and classic method to eliminate multiple productions of a clique is <em>acyclic orientations</em>. Simply orient the graph as a DAG, and only make recursive calls on out-neighborhoods. Typically, an orientation is chosen by degeneracy/core decomposition or degree orderings, so that out-neighborhood sizes are minimized. This is a central technique in all recent applied algorithms on clique counting<span class="cite-container">[<a href="#cite:DBS18" class="cite-label">11</a>,<a href="#cite:FFF15" class="cite-label">15</a>,<a href="#cite:JS17" class="cite-label">18</a>]</span>. Yet it is not feasible to construct the recursion tree to completion, and it is typically truncated at some depth (<span role="math">$\leq 10$</span>) for large graphs.</p>
<p>Is it possible to somehow “compress” the tree, and get a unique (easily accessible) representation of all cliques?</p>
<p><strong>The power of pivoting:</strong> We discover a suprising answer,  in pivoting. This was discovered by Bron-Kerbosch in the context  of <em>maximal</em> cliques<span class="cite-container">[<a href="#cite:BK73" class="cite-label">5</a>]</span>.  We describe, at an intuitive level, how it can be applied for global and local clique counting. For the recursive call at <span role="math">$S$</span>, first pick a <em>pivot</em> vertex <span role="math">$p \in S$</span>.  Observe that the cliques in <span role="math">$S$</span> can be partitioned into three classes as follows. For clique <span role="math">$C$</span> contained in <span role="math">$S$</span>: (i) <span role="math">$p \in C$</span>, (ii) <span role="math">$C \subset N§$</span>, (iii) <span role="math">$C$</span> contains a non-neighbor of <span role="math">$p$</span>. There is 1-1 correspondence between cliques of type (i) and (ii), so we could hope to only enumerate type (ii) cliques.</p>
<p>Thus, from a recursive call for <span role="math">$S$</span>, we make recursive calls to find cliques in <span role="math">$N§ \cap S$</span>, and <span role="math">$N(u) \cap S$</span> for every <em>non-neighbor</em> <span role="math">$u$</span> of <span role="math">$p$</span> in <span role="math">$S$</span>. We avoid making recursive calls corresponding to vertices in <span role="math">$N§$</span>. This gives the main savings over the simple backtracking procedure. The natural choice of <span role="math">$p$</span> is the highest degree vertex in the graph induced on <span role="math">$S$</span>. The recursion tree obtained is  essentially the SCT. We stress that this is quite different from the Bron-Kerbosch recursion tree. The BK algorithm also maintains a set of excluded vertices since it only cares for maximal cliques. This excluded set is used to prune away branches that cannot be maximal; moreover, the pivots in BK are potentially chosen from outside <span role="math">$S$</span> to increase pruning. The SCT is constructed in this specific manner to ensure unique clique representations, which the BK tree does not provide.</p>
<p>The SCT is significantly smaller than recursion trees that use degeneracy orientations (which one cannot feasibly construct). In practice, it can be constructed efficiently for graphs with tens of millions of edges.  As before the nodes of the SCT are labeled with subsets (corresponding to the recursive calls), and links are labeled with vertices (corresponding to the vertex whose neighborhood is being processed). Abusing notation, in the following discussion, we refer to a path by the set of link labels in the path.</p>
<p>How can we count all cliques using the SCT? Every root to leaf path in the tree corresponds to a clique, but not all cliques correspond to paths. This is distinct from the standard recursion tree discussed earlier, where every clique corresponds to a path from the root. Indeed, this is why the standard recursion trees (even with degeneracy orientations) are large.</p>
<p>We prove the following remarkable “unique encoding” property. Within any root to leaf path <span role="math">$T$</span>, there is a subset of links <span role="math">$P$</span> corresponding to the pivot calls. Every clique <span role="math">$C$</span> in the graph can be <em>uniquely</em> expressed as <span role="math">$(T\setminus P) \cup Q$</span> for some <span role="math">$Q \subseteq P$</span> (for a specific path <span role="math">$T$</span>).  The uniqueness is critical for global and local counting, since we can simply write down formulas to extract all counts. Thus, the SCT gives a unique encoding for every clique in the graph.</p>
<p>Intuitively, the source of compression can be seen in two different ways. The simplest way is to see that pivoting prunes the tree, because recursive calls are only made for a subset of vertices. But also, not every clique is represented by (the link labels of) a path from the root. Thus, there are far fewer paths in the SCT.  The final algorithm is quite simple and the main work was coming up with the above insight. Despite this simplicity, it outperforms even parallel methods  for exact clique counting by orders of magnitude.</p>
<p>Our main theorem follows. Basically, clique counts can be obtained in time proportional to the size of the SCT.  All the technical terms will be formally defined in <a href="#sec:prelims">§prelims</a>.</p>
<div class="theorem" id="thm:main">THEOREM 1.  Let <span role="math">$G$</span> be an input graph with <span role="math">$n$</span> vertices, <span role="math">$m$</span> edges, and degeneracy <span role="math">$\alpha$</span>. Let <span role="math">$SCT(G)$</span> be the  Succinct Clique Tree of graph <span role="math">$G$</span>.
<p>The procedure PIVOTER<span role="math">$(G)$</span> correctly outputs all global and local counts. For global and per-vertex counts, the running time is <span role="math">$O(\alpha^2 |SCT(G)| + m + n)$</span>. For per-edge counts, the running time is <span role="math">$O(\alpha^3 |SCT(G)| + m + n)$</span>. The storage cost is <span role="math">$O(m+n)$</span>. </div></p>
<p>Empirically, we observe that the SCT is quite small. In the worst-case, <span role="math">$|SCT(G)|  = O(n 3^{\alpha/3})$</span>, which follows from arguments by Eppstein-Löeffler-Strash<span class="cite-container">[<a href="#cite:ELS13" class="cite-label">12</a>]</span> and Tomita-Tanaka-Takahashi<span class="cite-container">[<a href="#cite:Tomita04" class="cite-label">29</a>]</span> (an exponential dependence is necessary because of the NP-hardness of maximum clique). We give a detailed description in <a href="#sec:count">§count</a></p>
<div id="sec:prelims"></div>
<h2 id="PRELIMINARIES">PRELIMINARIES<a class="header-anchor" href="#PRELIMINARIES">#</a></h2>
<p>We start with the mathematical formalism required to describe the main algorithm and associated proofs. The input is a simple, undirected graph <span role="math">$G = (V,E)$</span>, where <span role="math">$|V| = n$</span> and <span role="math">$|E| = m$</span>. It is convenient to assume that <span role="math">$G$</span> is connected. We use vertices to denote the elements of <span role="math">$V$</span> (the term <em>nodes</em> will be used for a different construct). We use the following notation for neighborhoods.</p>
<ul>
<li><span role="math">$N(v)$</span>: This is the neighborhood of <span role="math">$v$</span>.</li>
<li><span role="math">$N(S,v)$</span>: For any subset of vertices <span role="math">$S$</span>, we use <span role="math">$N(S,v)$</span> to denote <span role="math">$N(v) \cap S$</span>. Alternately, this is the neighborhood of <span role="math">$v$</span> in <span role="math">$S$</span>.</li>
</ul>
<p>We will use <em>degeneracy orderings</em> (or core decompositions) to reduce the recursion tree. This is a standard technique for clique counting<span class="cite-container">[<a href="#cite:ChNi85" class="cite-label">10</a>,<a href="#cite:DBS18" class="cite-label">11</a>,<a href="#cite:FFF15" class="cite-label">15</a>,<a href="#cite:JS17" class="cite-label">18</a>]</span>. This ordering is obtained by iteratively removing the minimum degree vertex, and can be computed in linear time<span class="cite-container">[<a href="#cite:MB83" class="cite-label">20</a>]</span>. Typically, one uses this ordering to convert <span role="math">$G$</span> into a DAG. The largest <em>out-degree</em> is the  graph degeneracy, denoted <span role="math">$\alpha$</span>. We state this fact as a lemma, which is considered a classic fact in graph theory and network science.</p>
<div class="lemma" id="lem:degen">LEMMA 1.  <span class="cite-container">[<a href="#cite:MB83" class="cite-label">20</a>]</span> Given a graph <span role="math">$G = (V,E)$</span>, there is a  linear time algorithm that constructs an ayclic orientation of <span role="math">$G$</span> such that all outdegrees are at most <span role="math">$\alpha$</span>. </div>
<p>The most important construct we design is the <em>Succinct Clique Tree</em> (SCT) <span role="math">$\bm T$</span>. The SCT stores special node and link attributes that are key to getting global and local clique counts, for all values of <span role="math">$k$</span>. The construction and properties of the SCT are given in the next section. Here,  we list out technical notation associated with the SCT <span role="math">$\bm T$</span>.</p>
<p>Formally, <span role="math">$\bm T$</span> is a tree where nodes are labeled with subsets of <span role="math">$V$</span>, with the following properties.</p>
<ul>
<li>The root is labeled <span role="math">$V$</span>.</li>
<li>Parent labels are strict supersets of child labels.</li>
<li>Leaves are labeled with the empty set <span role="math">$\emptyset$</span>.</li>
</ul>
<p>An important aspect of <span role="math">$\bm T$</span> are <em>link labels</em>. A link label is a pair with a vertex of <span role="math">$V$</span> and a “call type”. The label is of the form <span role="math">$(v,\mathfrak{p})$</span> or <span role="math">$(v,\mathfrak{h})$</span>, where <span role="math">$\mathfrak{p}$</span> is shorthand for “pivot” and <span role="math">$\mathfrak{h}$</span> for “hold”. For a link label <span role="math">$(v,\cdot)$</span> of the link <span role="math">$(S,S’)$</span> (where <span role="math">$S \supset S’$</span> is the parent), <span role="math">$v$</span> will be an element of <span role="math">$S$</span>.</p>
<p>Consider a root to leaf path <span role="math">$T$</span> of <span role="math">$\bm T$</span>. We have the following associated set of vertices. It is convenient to think of <span role="math">$T$</span> as a set of tree links.</p>
<ul>
<li><span role="math">$H(T)$</span>: This is the set of vertices associated with “hold” call types, among the links of <span role="math">$T$</span>. Formally, <span role="math">$H(T)$</span> is <span role="math">$\{v | (v,\mathfrak{h})$</span> is label of link in <span role="math">$T \}$</span>.</li>
<li><span role="math">$P(T)$</span>: This is the set of vertices with “pivot” calls. Formally <span role="math">$P(T)$</span> is <span role="math">$\{v | (v,\mathfrak{p})$</span> is label of link in <span role="math">$T \}$</span>.</li>
</ul>
<p>We now describe our algorithm. We stress that the presentation here is different from the implementation. The following presentation is easier for mathematical formalization and proving correctness. The implementation is a recursive  version of the same algorithm, which is more space efficient. This is explained in the proof of <a class="theorem" href="#thm:main">Theorem 1</a>.</p>
<div id="sec:scr"></div>
<h2 id="BUILDING-THE-SCT">BUILDING THE SCT<a class="header-anchor" href="#BUILDING-THE-SCT">#</a></h2>
<p>We give the algorithm to construct the SCT.  We keep track of various attributes to appropriately label the edges. The algorithm will construct the SCT <span role="math">$\bm T$</span> in a breadth-first manner. Every time a node is processed, the algorithm creates its children and labels all the new nodes and links created.</p>
<div><table class="algorithm" id="algo:1"><thead><tr><th colspan="2"><p>SCTBuilder(<span role="math">$G$</span>)<br> Output: SCT of <span role="math">$G$</span></p> </th></tr></thead><tbody><tr><td><span  class="line">1</span></td><td style="padding-left: 0em"><p>Find degeneracy orientation of <span role="math">$G$</span>, and let <span role="math">$N^+(v)$</span> denote the outneighborhood of a vertex <span role="math">$v$</span>.</p> </td></tr><tr><td><span  class="line">2</span></td><td style="padding-left: 0em"><p>Initialize tree <span role="math">$\bm T$</span> with root labeled <span role="math">$V$</span>.</p> </td></tr><tr><td><span  class="line">3</span></td><td style="padding-left: 0em"><p>For every <span role="math">$v \in V$</span>, create a child of root with node label <span role="math">$N^+(v)$</span>. Set the edge label to <span role="math">$(v,\mathfrak{h})$</span>.</p> </td></tr><tr><td><span  class="line">4</span></td><td style="padding-left: 0em"><p>Insert all these child nodes into a queue <span role="math">$\bm Q$</span>.</p> </td></tr><tr><td><span  class="line">5</span></td><td style="padding-left: 0em"><p>While <span role="math">$\bm Q$</span> is non-empty:</p> </td></tr><tr><td><span  class="line">6</span></td><td style="padding-left: 2em"><p>Dequeue to get node <span role="math">$\gamma$</span>. Let node label be <span role="math">$S$</span>.</p> </td></tr><tr><td><span  class="line">7</span></td><td style="padding-left: 2em"><p>If <span role="math">$S = \emptyset$</span>, continue.</p> </td></tr><tr><td><span id="step:pivot" class="line">8</span></td><td style="padding-left: 2em"><p>Find <span role="math">$p \in S$</span> with largest <span role="math">$N(S,p)$</span> value.</p> </td></tr><tr><td><span id="step:pcall" class="line">9</span></td><td style="padding-left: 2em"><p>Create child node of <span role="math">$\gamma$</span> with vertex label <span role="math">$N(S,p)$</span>. Add this node to <span role="math">$\bm T$</span> and set the link label (of the new link) to <span role="math">$(p,\mathfrak{p})$</span>. Also, add this node to <span role="math">$\bm Q$</span>.</p> </td></tr><tr><td><span  class="line">10</span></td><td style="padding-left: 2em"><p>Let <span role="math">$S \setminus (p \cup N§) = \{v_1, v_2, \ldots, v_\ell\}$</span> (listed in arbitrary order).</p> </td></tr><tr><td><span  class="line">11</span></td><td style="padding-left: 2em"><p>For each <span role="math">$i \leq \ell$</span>: create child node of <span role="math">$\gamma$</span> labeled</p> </td></tr><tr><td><span  class="line">12</span></td><td style="padding-left: 0em"><p><span role="math">$N(S,v_i) \setminus \{v_1, v_2, \ldots, v_{i-1}\}$</span>. Add this node to <span role="math">$\bm T$</span> and set link label to <span role="math">$(v_i, \mathfrak{h})$</span>.</p> </td></tr><tr><td><span id="step:nncall" class="line">13</span></td><td style="padding-left: 0em"><p>Also add this node to <span role="math">$\bm Q$</span>.</p> </td></tr><tr><td><span  class="line">14</span></td><td style="padding-left: 0em"><p>Return <span role="math">$\bm T$</span>.</p> </td></tr></tbody></table></div>
<p>As mentioned earlier, the child of the node labeled <span role="math">$S$</span> has one child corresponding to the pivot vertex <span role="math">$p$</span>, and children for all non-neighbors of <span role="math">$p$</span>. Importantly, we label each “call” with <span role="math">$\mathfrak{p}$</span> or <span role="math">$\mathfrak{h}$</span>. This is central to getting unique representations of all the cliques.</p>
<p>Now for our main theorem about SCT.</p>
<div class="theorem" id="thm:scr">THEOREM 2.  Every clique <span role="math">$C$</span> (in <span role="math">$G$</span>) can be *uniquely* represented as <span role="math">$H(T) \cup Q$</span>, where <span role="math">$Q \subseteq P(T)$</span> and <span role="math">$T$</span> is a root to leaf path in <span role="math">$\bm T$</span>. (Meaning, for any other root to leaf path <span role="math">$T' \neq T$</span>, <span role="math">$\forall Q \subseteq P(T')$</span>, <span role="math">$C \neq H(T') \cup Q$</span>.) </div>
<p>We emphasize the significance of this theorem. Every root to leaf path <span role="math">$T$</span> represents a clique, given by the vertex set <span role="math">$H(T) \cup P(T)$</span>. Every clique <span role="math">$C$</span>  is a subset of potentially many such sets; and there is no obvious bound on this number. So one can think of <span role="math">$C$</span> “occurring” multiple times in the tree <span role="math">$\bm T$</span>. But <a class="theorem" href="#thm:scr">Theorem 2</a> asserts that  if we take the labels into account (<span role="math">$H(T)$</span> vs <span role="math">$P(T)$</span>), then there is a <em>unique</em> representation or “single occurrence” of <span role="math">$C$</span>.</p>
<div class="proof-container">
            <div class="proof-content"><p>(of <a class="theorem" href="#thm:scr">Theorem 2</a>)  Consider a node <span role="math">$\gamma$</span> of <span role="math">$\bm T$</span> labeled <span role="math">$S$</span>. We prove, by induction on <span role="math">$|S|$</span>, that every clique <span role="math">$C \subseteq S$</span> can be expressed as <span role="math">$H(T) \cup Q$</span>, where <span role="math">$T$</span> is a path from <span role="math">$\gamma$</span> to a leaf, and <span role="math">$Q \subseteq P(T)$</span>. The theorem follows by setting <span role="math">$\gamma$</span> to the root.</p>
<p>The base case is vacuously tree, since for empty <span role="math">$S$</span>, all relevant sets are empty. Now for the induction. We will have three cases. Let <span role="math">$p$</span> be the pivot chosen in <a href="#step:pivot">Step 8</a>. (If <span role="math">$S$</span> is the root, then there is no pivot. We will directly go to Case (iii) below.)</p>
<p><em>Case (i): <span role="math">$p \in C$</span>.</em> By construction, there is a link labeled <span role="math">$(p,\mathfrak{p})$</span> to a child of <span role="math">$\gamma$</span>. Denote the child <span role="math">$\beta$</span>. The child <span role="math">$\beta$</span> has label <span role="math">$N(S,p)$</span>. Observe that <span role="math">$C \setminus p$</span> is a clique in <span role="math">$N(S,p)$</span> (since by assumption, <span role="math">$C$</span> is a clique in <span role="math">$S$</span>.) By induction, there is a unique representation  <span role="math">$C\setminus p = H(T) \cup Q$</span>, for path <span role="math">$T$</span> from the child node to a leaf and <span role="math">$Q \subseteq P(T)$</span>. Moreover there cannot be a representation of <span role="math">$C$</span> by a path rooted at <span role="math">$\beta$</span>, since <span role="math">$N(S,p) \not\ni p$</span>. Consider the path <span role="math">$T’$</span> that contains <span role="math">$T$</span> and starts from <span role="math">$\gamma$</span>. Note that <span role="math">$H(T’) = H(T)$</span> and <span role="math">$P(T’) = P(T) \cup p$</span>. We can express <span role="math">$C = H(T’) \cup (Q \cup p)$</span>, noting that <span role="math">$Q \cup p \subseteq P(T’)$</span>. This proves the existence of a representation. Moreover, there is only one representation using a path through <span role="math">$\beta$</span>.</p>
<p>We need to argue that no other path can represent <span role="math">$C$</span>. The pivoting is critical for this step. Consider any path rooted at <span role="math">$\gamma$</span>, but not passing through <span role="math">$\beta$</span>. It must pass through some other child, with corresponding links labeled <span role="math">$(v_i,\mathfrak{h})$</span>, where <span role="math">$v_i$</span> is a <em>non-neighbor</em> of <span role="math">$p$</span>. Since <span role="math">$C \ni p$</span>, a non-neighbor <span role="math">$v_i$</span> cannot be in <span role="math">$C$</span>. Moreover, for any path <span role="math">$\hat{T}$</span> passing through these other children, <span role="math">$\hat{T}$</span> must contain some non-neighbor. Thus, <span role="math">$\hat{T}$</span> cannot represent <span role="math">$C$</span>.</p>
<p><em>Case (ii): <span role="math">$C \subseteq N(S,p)$</span>.</em> The argument is essentially identical to the one above. Note that <span role="math">$C\setminus p = C$</span>, and by induction <span role="math">$C\setminus p$</span> has a unique representation using a path through <span role="math">$\beta$</span>. For uniqueness, observe that <span role="math">$C$</span> does not contain a non-neighbor of <span role="math">$p$</span>. The previous argument goes through as is.</p>
<p><em>Case (iii): <span role="math">$C$</span> contains a non-neighbor of <span role="math">$p$</span>.</em> Recall that <span role="math">$S \setminus (N§ \cup p)$</span> (the set of non-neighbors in <span role="math">$S$</span>) is denoted <span role="math">$\{v_1, v_2, \ldots, v_\ell\}$</span>. Let <span role="math">$i$</span> be the smallest index <span role="math">$i$</span> such that <span role="math">$v_i \in C$</span>. For any <span role="math">$1 \leq j \leq \ell$</span>, let <span role="math">$N_j := N(S,v_j) \setminus \{v_1, v_2, \ldots, v_{j-1}\}$</span>. Observe that for all <span role="math">$j$</span>, there is a child labeled <span role="math">$N_j$</span>. Moreover, all the link labels have <span role="math">$\mathfrak{h}$</span>, so for path <span role="math">$T$</span> passing through <span role="math">$N_j$</span>, <span role="math">$H(T) \ni v_j$</span>. Thus, if <span role="math">$T$</span> can represent <span role="math">$C$</span>, it cannot pass through <span role="math">$N_j$</span> for <span role="math">$j &lt; i$</span>. Moreover, if <span role="math">$j &gt; i$</span>, then <span role="math">$N_j \not\ni v_i$</span> and no path passing through this node can represent <span role="math">$C$</span>.</p>
<p>Hence, if there is a path that can represent <span role="math">$C$</span>, it must pass through <span role="math">$N_i$</span>. Note that <span role="math">$C\setminus v_i$</span> is a clique contained in <span role="math">$N_i$</span>. By induction, there is a unique path <span role="math">$T$</span> rooted at <span role="math">$N_i$</span> such that <span role="math">$C \setminus v_i = H(T) \cup Q$</span>, for <span role="math">$Q \subseteq P(T)$</span>. Let <span role="math">$T’$</span> be the path that extends <span role="math">$T$</span> to <span role="math">$\gamma$</span>. Note that <span role="math">$H(T’) = H(T) \cup v_i$</span>, so <span role="math">$C = H(T’) \cup Q$</span>. The uniqueness of <span role="math">$T$</span> implies the uniquesness of <span role="math">$T’$</span>.</p>
</div>
            <div class="proof-qed"><div class="proof-qed-icon"></div></div>
          </div>
<div id="sec:count"></div>
<h2 id="GETTING-GLOBAL-AND-LOCAL-COUNTS">GETTING GLOBAL AND LOCAL COUNTS<a class="header-anchor" href="#GETTING-GLOBAL-AND-LOCAL-COUNTS">#</a></h2>
<p>The tree <span role="math">$\bm T$</span> is succinct and yet one can extract fine-grained information from it about all cliques.</p>
<div><table class="algorithm" id="algo:2"><thead><tr><th colspan="2"><p>PIVOTER(<span role="math">$G$</span>)<br> Output: Clique counts of <span role="math">$G$</span></p> </th></tr></thead><tbody><tr><td><span  class="line">1</span></td><td style="padding-left: 0em"><p>Let <span role="math">$\bm T = SCTBuilder(G)$</span>.</p> </td></tr><tr><td><span  class="line">2</span></td><td style="padding-left: 0em"><p>Initialize all clique counts to zero.</p> </td></tr><tr><td><span  class="line">3</span></td><td style="padding-left: 0em"><p>For every root to leaf path <span role="math">$T$</span> in <span role="math">$\bm T$</span>:</p> </td></tr><tr><td><span  class="line">4</span></td><td style="padding-left: 2em"><p>For every <span role="math">$0 \leq i \leq |P(T)|$</span>, increment <span role="math">$C_{|H(T)|+i}$</span> by <span role="math">${P(T) \choose i}$</span>.</p> </td></tr><tr><td><span id="step:ht" class="line">5</span></td><td style="padding-left: 2em"><p>For every <span role="math">$v \in H(T)$</span> and every <span role="math">$0 \leq i \leq |P(T)|$</span>, increment <span role="math">$c_{|H(T)|+i}(v)$</span> by <span role="math">${P(T) \choose i}$</span>.</p> </td></tr><tr><td><span id="step:pt" class="line">6</span></td><td style="padding-left: 2em"><p>For every <span role="math">$v \in P(T)$</span> and every <span role="math">$0 \leq i \leq |P(T)|-1$</span>, increment <span role="math">$c_{|H(T)|+i+1}(v)$</span> by <span role="math">${ {P(T)-1} \choose i}$</span>.</p> </td></tr><tr><td><span id="step:hht" class="line">7</span></td><td style="padding-left: 2em"><p>For every edge <span role="math">$e(u,v), u \in H(T), v \in H(T), u \neq v$</span> and every <span role="math">$0 \leq i \leq |P(T)|$</span>, increment <span role="math">$c_{|H(T)|+i}(e)$</span> by <span role="math">${ {P(T)} \choose i}$</span>.</p> </td></tr><tr><td><span id="step:pht" class="line">8</span></td><td style="padding-left: 2em"><p>For every edge <span role="math">$e(u,v), u \in P(T), v \in H(T)$</span> and every <span role="math">$0 \leq i \leq |P(T)|-1$</span>, increment <span role="math">$c_{|H(T)|+i+1}(e)$</span> by <span role="math">${ {P(T)-1} \choose i}$</span>.</p> </td></tr><tr><td><span id="step:ppt" class="line">9</span></td><td style="padding-left: 2em"><p>For every edge <span role="math">$e(u,v), u \in P(T), v \in P(T), u \neq v$</span> and every <span role="math">$0 \leq i \leq |P(T)|-2$</span>, increment <span role="math">$c_{|H(T)|+i+2}(e)$</span> by <span role="math">${ {P(T)-2} \choose i}$</span>.</p> </td></tr><tr><td><span  class="line">10</span></td><td style="padding-left: 0em"><p>Output the sets of values <span role="math">$\{C_k\}$</span>, <span role="math">$\{c_k(v)\}$</span> and <span role="math">$\{c_k(e)\}$</span>.</p> </td></tr></tbody></table></div>
<p>The storage complexity of the algorithm, as given, is potentially <span role="math">$O(\alpha^2 |SCT(G)|)$</span>, since this is required to store the tree. In the proof of <a class="theorem" href="#thm:main">Theorem 1</a>, we explain how to reduce the storage.</p>
<div class="proof-container">
            <div class="proof-content"><p>(of <a class="theorem" href="#thm:main">Theorem 1</a>) <strong>Correctness:</strong> By <a class="theorem" href="#thm:scr">Theorem 2</a>, a root to leaf path <span role="math">$T$</span> of <span role="math">$\bm T$</span> represents exactly <span role="math">$2^{P(T)}$</span> different cliques, with <span role="math">${P(T) \choose i}$</span> of size <span role="math">$|H(T)| + i$</span>. Moreover, over all <span role="math">$T$</span>, this accounts for all cliques in the graph. This proves the correctness of global counts.</p>
<p>Pick a vertex <span role="math">$v \in H(T)$</span>. For every subset of <span role="math">$P(T)$</span>, we get a different clique containing <span role="math">$v$</span> (that is uniquely represented by <a class="theorem" href="#thm:scr">Theorem 2</a>). This  proves the correctness of <a href="#step:ht">Step 5</a>. For a vertex <span role="math">$v \in P(T)$</span>, we look at all subsets containing <span role="math">$v$</span>. Equivalently, we get a different represented clique containing <span role="math">$v$</span> for every subset of <span role="math">$P(T)\setminus v$</span>. This  proves the correctness of <a href="#step:pt">Step 6</a>.</p>
<p>Pick an edge <span role="math">$e=(u,v), u \in H(T), v \in H(T)$</span>. For every subset of <span role="math">$P(T)$</span>, we get a different clique containing <span role="math">$e$</span> (that is uniquely represented by <a class="theorem" href="#thm:scr">Theorem 2</a>). This  proves the correctness of <a href="#step:hht">Step 7</a>. For an edge <span role="math">$e=(u,v), u \in P(T), v \in H(T)$</span>, we look at all subsets of <span role="math">$P(T)$</span> containing <span role="math">$u$</span>. Equivalently, we get a different represented clique containing <span role="math">$e$</span> for every subset of <span role="math">$P(T)\setminus u$</span>. This  proves the correctness of <a href="#step:pht">Step 8</a>. For an edge <span role="math">$e=(u,v), u \in P(T), v \in P(T)$</span>, we look at all subsets of <span role="math">$P(T)$</span> containing both <span role="math">$u$</span> and <span role="math">$v$</span>. Equivalently, we get a different represented clique containing <span role="math">$e$</span> for every subset of <span role="math">$P(T)\setminus v \setminus u$</span>. This  proves the correctness of <a href="#step:ppt">Step 9</a>.</p>
</div>
            <div class="proof-qed"><div class="proof-qed-icon"></div></div>
          </div>
<p><strong>Running time (in terms of <span role="math">$|SCT(G)|$</span>):</strong> Consider the procedure <span role="math">$SCTBuilder(G)$</span>. Note that the size of <span role="math">$\bm T$</span> is at least <span role="math">$n$</span>, so we can replace any running time dependence on <span role="math">$n$</span> by <span role="math">$|<strong>T</strong>|$</span>. The degeneracy orientation can be found in <span role="math">$O(m+n)$</span><span class="cite-container">[<a href="#cite:MB83" class="cite-label">20</a>]</span>. For the actual building of the tree, the main cost is in determining the pivot and constructing the children of a node. Suppose a non-root node labeled <span role="math">$S$</span> is processed. The above mentioned steps can be done by constructing the subgraph induced on <span role="math">$S$</span>. This can be done in <span role="math">$O(|S|^2)$</span> time. Since this is not a root node, <span role="math">$|S| \leq \alpha$</span> (this is the main utility of the degeneracy ordering). Thus, the running time of <span role="math">$SCTBuilder(G) = O(\alpha^2|\bm T|) = O(\alpha^2 |SCT(G)|)$</span>.</p>
<p>Now we look at PIVOTER. Note that the subsequent counting steps do <em>not</em> need the node labels in <span role="math">$\bm T$</span>; for all path <span role="math">$T$</span>, one only needs <span role="math">$P(T)$</span> and <span role="math">$H(T)$</span>. The paths can be looped over by a DFS from the root. For each path, there are precisely <span role="math">$|P(T)|+1$</span> updates to global clique counts, and at most <span role="math">$|H(T) \cup P(T)| \times (|P(T)|+1)$</span> updates to per-vertex clique counts. The length of <span role="math">$T$</span> is at most <span role="math">$\alpha$</span>, and thus both these quantities are <span role="math">$O(\alpha^2)$</span>. Thus, the total running time is <span role="math">$O(\alpha^2 |SCT(G)|)$</span> for global and per-vertex clique counting.</p>
<p>Similarly, for each path, at most <span role="math">$|H(T) \cup P(T)|^2 \times (|P(T)|+1)$</span> updates are made to per-edge clique counts. This quantity is <span role="math">$O(\alpha^3)$</span>. Thus, the total running time is <span role="math">$O(\alpha^3 |SCT(G)|)$</span>.</p>
<p><strong>Running time (in terms of <span role="math">$n$</span> and <span role="math">$\alpha$</span>):</strong> One crucial difference between the algorithm of Bron-Kerbosch and <span role="math">$SCTBUILDER$</span> is that in Bron-Kerbosch, the pivot vertex can be chosen not only from <span role="math">$S$</span> but also from a set of already processed vertices. Hence, the tree obtained in Bron-Kerbosch can potentially be smaller than that of PIVOTER. Despite this difference, the recurrence and bound on the worst case running time of <span role="math">$SCTBUILDER$</span> is the same as Bron-Kerbosch.</p>
<div class="theorem" id="thm:main-BK">THEOREM 3.  Worst case running time of <span role="math">$SCTBUILDER$</span> is <span role="math">$O(n3^{\alpha/3})$</span>.  </div>
<div class="proof-container">
            <div class="proof-content"><p>Let <span role="math">$T(s)$</span> be the worst case running time required by <span role="math">$SCTBUILDER$</span> to process <span role="math">$S$</span> where <span role="math">$s=|S|$</span>.</p>
<p>Let <span role="math">$R=S \setminus N§$</span>. Let <span role="math">$T_r(s)$</span> be the worst case running time of processing <span role="math">$S$</span> when <span role="math">$|R|=r$</span>. Note that when <span role="math">$S$</span> is being processed it creates a total of <span role="math">$r$</span> child nodes.</p>
<p>Thus, <span role="math">$T(s)=\max\limits_r\{T_r(s)\}$</span>.</p>
<p>Note that all steps other than <a href="#step:pcall">Step 9</a> and <a href="#step:nncall">Step 13</a> take time <span role="math">$O(s^2)$</span>. Say, they take time <span role="math">$p_1s^2$</span>, where <span role="math">$p_1&gt;0$</span> is a constant.</p>
<p>Thus, we have that:</p>
<div role="math">$$ T_r(s) \leq \sum\limits_{v \in R}{T(|N(S,v)|)  + p_1s^2}. $$</div>
<p>Moreover,</p>
<div role="math">$$ |N(S,v)| \leq s-r \leq s-1,\forall v \in R.  $$</div>
<p>This is because <span role="math">$p$</span> has the largest neighborhood in <span role="math">$S$</span> and <span role="math">$p$</span>'s neighborhood is of size atmost <span role="math">$s-r$</span>, and since <span role="math">$|S|\geq 1, s-r \leq s-1$</span>.</p>
<p>Thus, Lemma 2 and Theorem 3 from <span class="cite-container">[<a href="#cite:Tomita04" class="cite-label">29</a>]</span> hold, which implies that <span role="math">$T(s)=O(3^{s/3})$</span>. Since there are <span role="math">$n$</span> vertices and their outdegree is atmost <span role="math">$\alpha$</span>, the worst case running time of <span role="math">$SCTBUILDER$</span> (which is also an upper bound for <span role="math">$|sct(G)|$</span>) is <span role="math">$nT(\alpha)=O(n3^{\alpha/3})$</span> and hence, worst case running times of PIVOTER for obtaining global, per-vertex and per-edge clique counts are <span role="math">$O(n\alpha 3^{\alpha/3})$</span>, <span role="math">$O(n\alpha^2 3^{\alpha/3})$</span> and <span role="math">$O(n\alpha^3 3^{\alpha/3})$</span>, respectively.</p>
</div>
            <div class="proof-qed"><div class="proof-qed-icon"></div></div>
          </div>
<p><strong>Storage cost:</strong> Currently, PIVOTER is represented through two parts: the construction of <span role="math">$SCT(G)$</span> and then processing it to get clique counts. Conceptually, this is cleaner to think about and it makes the proof transparent. On the other hand, it requires storing <span role="math">$SCT(G)$</span>, which is potentially larger than the input graph. A more space efficient implementation is obtained by combining these steps.</p>
<p>We do not give full pseudocode, since it is somewhat of a distraction. (The details can be found in the code.) Essentially, instead of constructing <span role="math">$SCT(G)$</span> completely in breadth-first manner, we construct it depth-first through recursion. This will loop over all the paths of <span role="math">$\bm T$</span>, but only store a single path at any stage. The updates to the clique counts are done as soon as any root to leaf path is constructed. The total storage of a path is the storage for all the labels on a path. As mentioned earlier in the proof of <a class="theorem" href="#thm:main">Theorem 1</a>, all non-root nodes are labeled with sets of size at most <span role="math">$\alpha$</span>. The length of the path is at most <span role="math">$\alpha$</span>, so the total storage is <span role="math">$O(\alpha^2)$</span>. A classic bound on the degeneracy is <span role="math">$\alpha \leq \sqrt{2m}$</span> (Lemma 1 of<span class="cite-container">[<a href="#cite:ChNi85" class="cite-label">10</a>]</span>), so the storage, including the input, is <span role="math">$O(m+n)$</span>.</p>
<p><strong>Parallel version of PIVOTER:</strong> While this is not central to our results, we can easily implement a parallel version of PIVOTER for <em>global</em> clique counts. We stress that our aim was not to delve into complicated parallel algorithms, and merely to see if there was a way to parallelize the counting involving minimal code changes. The idea is simple, and is an easier variant of the parallelism in kCList<span class="cite-container">[<a href="#cite:DBS18" class="cite-label">11</a>]</span>.  Observe that the children of the root of <span role="math">$SCT(G)$</span> correspond to finding cliques in the sets <span role="math">$N^+(v)$</span>, for all <span role="math">$v$</span>. Clique counting in each of these sets can be treated as an independent problem, and can be handled by an independent thread/subprocess. Each subprocess maintains its own array of global clique counts. The final result aggregates all the clique counts. The change ends up being a few lines of code to the original implementation.</p>
<p>Note that this becomes tricky for local counts. Each subprocess cannot afford (storage-wise) to store an entire copy of the local count data structure. The aggregation step would be more challenging. Nonetheless, it should be feasible for each subprocess to create local counts for <span role="math">$N^+(v)$</span>, and appropriately aggregate all counts. We leave this for future work.</p>
<p><strong>Counting <span role="math">$k$</span>-cliques for a specific <span role="math">$k$</span>:</strong> PIVOTER can be modified to obtain clique counts upto a certain user specified <span role="math">$k$</span> (instead of counting for all <span role="math">$k$</span>). Whenever the number of links marked <span role="math">$\mathfrak{h}$</span> becomes greater than <span role="math">$k$</span> in any branch of the computation, we simply truncate the branch (as further calls in the branch will only yield cliques of larger sizes).</p>
<div id="sec:results"></div>
<h2 id="EXPERIMENTAL-RESULTS">EXPERIMENTAL RESULTS<a class="header-anchor" href="#EXPERIMENTAL-RESULTS">#</a></h2>
<p><strong>Preliminaries:</strong> All code for PIVOTER is available here: <a target="_blank" rel="noopener" href="https://bitbucket.org/sjain12/pivoter/">https://bitbucket.org/sjain12/pivoter/</a>. We implemented our algorithms in C and ran our experiments on a commodity machine equipped with a 1.4GHz AMD Opteron™ processor 6272 with 8 cores and 2048KB L2 cache (per core), 6144KB L3 cache, and 128GB memory. We performed our experiments on a collection of social networks, web networks, and infrastructure networks  from SNAP [49].  The graphs are simple and undirected (for graphs that are directed, we ignore the direction). A number of these graphs have more than 10 million edges, and the largest has more than 100 million edges.  Basic properties of these graphs are presented in <a href="#tab:main" >Tab 1</a>.</p>
<p>The data sets are split into two parts, in <a href="#tab:main" >Tab 1</a>. The upper part are instances feasibly solved with past work (notably kClist40<span class="cite-container">[<a href="#cite:DBS18" class="cite-label">11</a>]</span>), while the lower part has instances that cannot be solved with previous algorithm (even after days). We give more details in <a href="#sec:time">§time</a>.</p>
<p><strong>Competing algorithms:</strong> We compare with (what we consider) are the state of the art clique counting algorithms: Tur’{a}n-Shadow (TS)<span class="cite-container">[<a href="#cite:JS17" class="cite-label">18</a>]</span> and kClist40<span class="cite-container">[<a href="#cite:DBS18" class="cite-label">11</a>]</span>.</p>
<p><strong>kClist40:</strong> This algorithm by Danisch-Balalau-Sozio<span class="cite-container">[<a href="#cite:DBS18" class="cite-label">11</a>]</span> uses  degeneracy orientations and parallelization to enumerate all cliques.  The kClist40 algorithm, to the best of our knowledge, is the only existing algorithm that can feasibly compute all global counts for some graphs. Hence, our main focus is runtime comparisons with kClist40.</p>
<p>We note that the implementation of kClist40 visits every clique, but only updates the (appropriate) <span role="math">$C_k$</span>. While it could technically compute local counts, that would require more expensive data structure updates. Furthermore, there would be overhead in combining the counts for independent threads, and it is not immediately obvious how to distribute the underlying data structure storing local counts. As a result, we are unaware of any algorithm that computes local counts (at the scale of dataset in <a href="#tab:main" >Tab 1</a>).</p>
<p>We perform a simple optimization of kClist40, to make counting faster. Currently, when kClist40 encounters a clique, it enumerates every smaller clique contained inside it.  For the purpose of counting though, one can trivially count all subcliques of a clique using formulas. We perform this optimization (to have a fair comparison with kClist40), and note significant improvements in running time.</p>
<p>In all our runs, for consistency, we run kClist with 40 threads.  Note that we compare the <em>sequential</em> PIVOTER with the <em>parallel</em> kClist40.</p>
<p><strong>TS:</strong> This is an approximate clique counting algorithm for <span role="math">$k$</span> upto <span role="math">$10$</span> <span class="cite-container">[<a href="#cite:JS17" class="cite-label">18</a>]</span>.  It mines dense subgraphs (shadows) and samples cliques within the dense subgraphs to give an estimate. For fast randomized estimates, it is arguably the fastest algorithm. It runs significantly faster than a sequential implementation of kClist, but is typically comparable with a parallel implementation of kClist. It requires the entire shadow to be available for sampling which can require considerable space.</p>
<div id="sec:time"></div>
<h3 id="Running-time-and-comparison-with-other-algorithms">Running time and comparison with other algorithms<a class="header-anchor" href="#Running-time-and-comparison-with-other-algorithms">#</a></h3>
<p><strong>Running time for global counting:</strong> We show the running time results in <a href="#tab:main" >Tab 1</a>. For most of the graphs, PIVOTER was able to count all <span role="math">$k$</span>-cliques in seconds or minutes. For the largest <em>com-orkut</em> graph, PIVOTER ran in 1.5 hours.  This is a huge improvement on the state of the art. For the “infeasible” instances in <a href="#tab:main" >Tab 1</a>, we do not get results even in two days using previous algorithms. (This is consistent with results in Table 2 of<span class="cite-container">[<a href="#cite:DBS18" class="cite-label">11</a>]</span>, where some of the graphs are also listed as “very large graphs” for which clique counting is hard.)</p>
<p>A notable hard instance is <em>com-lj</em> where PIVOTER is unable to get all clique counts in a day. Again, previous work also notes this challenge, and only gives counts of <span role="math">$7$</span>-cliques. We can get some partial results for <em>com-lj</em>, as explained later.</p>
<div class="table-wrap" id="tab:main"><div class="table-container"><table><thead><tr><td style="text-align: center">Graph</td><td style="text-align: center">Vertices</td><td style="text-align: center">Edges</td><td style="text-align: center">Degen</td><td style="text-align: center">Max clique</td><td style="text-align: center">PIVOTER (<span role="math">$C_k$</span>)</td><td style="text-align: center">PIVOTER (<span role="math">$c_k(v)$</span>)</td><td style="text-align: center">PIVOTER (<span role="math">$c_k(e)$</span>)</td><td style="text-align: center">PIVOTER(<span role="math">$C_k$</span>) parallel</td></tr></thead><tbody><tr><td style="text-align: center" colspan="9">Feasible by previous algorithms</td></tr><tr><td style="text-align: center">dblp-v5</td><td style="text-align: center">1.56E+06</td><td style="text-align: center">2.08E+06</td><td style="text-align: center">15</td><td style="text-align: center">10</td><td style="text-align: center">7</td><td style="text-align: center">7</td><td style="text-align: center">8</td><td style="text-align: center">19</td></tr><tr><td style="text-align: center">dblp-v7</td><td style="text-align: center">3.67E+06</td><td style="text-align: center">4.18E+06</td><td style="text-align: center">19</td><td style="text-align: center">12</td><td style="text-align: center">15</td><td style="text-align: center">16</td><td style="text-align: center">19</td><td style="text-align: center">34</td></tr><tr><td style="text-align: center">amazon0601</td><td style="text-align: center">4.03E+05</td><td style="text-align: center">2.44E+06</td><td style="text-align: center">10</td><td style="text-align: center">11</td><td style="text-align: center">4</td><td style="text-align: center">5</td><td style="text-align: center">6</td><td style="text-align: center">4</td></tr><tr><td style="text-align: center">web-Google</td><td style="text-align: center">8.76E+05</td><td style="text-align: center">4.32E+06</td><td style="text-align: center">44</td><td style="text-align: center">44</td><td style="text-align: center">8</td><td style="text-align: center">9</td><td style="text-align: center">15</td><td style="text-align: center">9</td></tr><tr><td style="text-align: center">youtube</td><td style="text-align: center">1.13E+06</td><td style="text-align: center">2.99E+06</td><td style="text-align: center">51</td><td style="text-align: center">17</td><td style="text-align: center">7</td><td style="text-align: center">8</td><td style="text-align: center">11</td><td style="text-align: center">9</td></tr><tr><td style="text-align: center">cit-Patents</td><td style="text-align: center">3.77E+06</td><td style="text-align: center">1.65E+07</td><td style="text-align: center">64</td><td style="text-align: center">11</td><td style="text-align: center">40</td><td style="text-align: center">41</td><td style="text-align: center">53</td><td style="text-align: center">46</td></tr><tr><td style="text-align: center">soc-pokec</td><td style="text-align: center">1.63E+06</td><td style="text-align: center">2.23E+07</td><td style="text-align: center">47</td><td style="text-align: center">29</td><td style="text-align: center">68</td><td style="text-align: center">75</td><td style="text-align: center">93</td><td style="text-align: center">44</td></tr><tr><td style="text-align: center" colspan="9">Not feasible for previous algorithms</td></tr><tr><td style="text-align: center">Stanford</td><td style="text-align: center">2.82E+05</td><td style="text-align: center">1.99E+06</td><td style="text-align: center">71</td><td style="text-align: center">61</td><td style="text-align: center">5</td><td style="text-align: center">5</td><td style="text-align: center">38</td><td style="text-align: center">3</td></tr><tr><td style="text-align: center">BerkStan</td><td style="text-align: center">6.85E+05</td><td style="text-align: center">6.65E+06</td><td style="text-align: center">201</td><td style="text-align: center">201</td><td style="text-align: center">25</td><td style="text-align: center">26</td><td style="text-align: center">237</td><td style="text-align: center">9</td></tr><tr><td style="text-align: center">as-skitter</td><td style="text-align: center">1.70E+06</td><td style="text-align: center">1.11E+07</td><td style="text-align: center">111</td><td style="text-align: center">67</td><td style="text-align: center">120</td><td style="text-align: center">200</td><td style="text-align: center">9245</td><td style="text-align: center">75</td></tr><tr><td style="text-align: center">com-orkut</td><td style="text-align: center">3.07E+06</td><td style="text-align: center">1.17E+08</td><td style="text-align: center">253</td><td style="text-align: center">51</td><td style="text-align: center">5174</td><td style="text-align: center">8802</td><td style="text-align: center">99389</td><td style="text-align: center">3441</td></tr></tbody></table></div><div class="table-info"><p>Table shows the sizes, degeneracy, maximum clique size, and the time taken (in seconds) by PIVOTER to obtain global <span role="math">$k-$</span>clique counts, per-vertex and per edge <span role="math">$k-$</span>cliques counts for all k. *For the com-lj graph, we were not able to get all <span role="math">$k-$</span>clique counts in 1 day so we tested for the maximum <span role="math">$k$</span> we could count in about a day. PIVOTER was able to count the number of 9-cliques in 30 hours whereas kClist40 had not terminated even after 6 days.</p>
</div></div>
<div class="table-wrap" id="tab:comparison"><div class="table-container"><table><thead><tr><td style="text-align: center">Graph</td><td style="text-align: center">k=13,TS</td><td style="text-align: center">k=13, kClist40</td><td style="text-align: center">all k, Pivoter</td></tr></thead><tbody><tr><td style="text-align: center">Stanford</td><td style="text-align: center">230</td><td style="text-align: center">12600</td><td style="text-align: center">5</td></tr><tr><td style="text-align: center">BerkStan</td><td style="text-align: center">1198</td><td style="text-align: center">&gt; 172800</td><td style="text-align: center">25</td></tr><tr><td style="text-align: center">as-skitter</td><td style="text-align: center">798</td><td style="text-align: center">12480</td><td style="text-align: center">120</td></tr><tr><td style="text-align: center">com-orkut</td><td style="text-align: center">&gt; 28800</td><td style="text-align: center">&gt; 172800</td><td style="text-align: center">5174</td></tr></tbody></table></div><div class="table-info"><p>Time taken in seconds by the state-of-the-art randomized (TS, short for TuránShadow) and parallel (kClist40) algorithms. Note that PIVOTER obtains <strong>all</strong> <span role="math">$k-$</span>clique counts for these graphs in a fraction of the time taken by other methods to count just 13-cliques.</p>
</div></div>
<div class="table-wrap" id="tab:com-lj"><div class="table-container"><table><thead><tr><td style="text-align: center">k</td><td style="text-align: center"><span role="math">$k$</span>-cliques</td><td style="text-align: center">kClist40</td><td style="text-align: center">PIVOTER</td></tr></thead><tbody><tr><td style="text-align: center">7</td><td style="text-align: center">4.49E+15</td><td style="text-align: center">2.2 hours</td><td style="text-align: center">1.2 hours</td></tr><tr><td style="text-align: center">8</td><td style="text-align: center">1.69E+16</td><td style="text-align: center">42.5 hours</td><td style="text-align: center">6.4 hours</td></tr><tr><td style="text-align: center">9</td><td style="text-align: center">5.87E+17</td><td style="text-align: center">&gt; 6 days</td><td style="text-align: center">30 hours</td></tr><tr><td style="text-align: center">10</td><td style="text-align: center">1.89E+19</td><td style="text-align: center">&gt; 6 days</td><td style="text-align: center">5.9 days</td></tr></tbody></table></div><div class="table-info"><p>Table shows the time taken to count <span role="math">$k$</span>-cliques for com-lj graph. For <span role="math">$k$</span>=9, PIVOTER terminated in about 30 hours where kClist40 had not terminated in 6 days.</p>
</div></div>
<div class="justified-gallery"> <img src="nCalls_vs_m.png" title="Number of nodes in SCT vs m" alt="Number of nodes in SCT vs m" id="fig:treesize" /><img src="trends.png" title="Trends in different graphs" alt="Trends in different graphs" id="fig:trends" /><img src="trends-dblp.png" title="Trends in dblp over time." alt="Trends in dblp over time." id="fig:trends-dblp" /> </div>                 <div class="figure-more"> 
<p><a class="figure" title="Number of nodes in SCT vs m" href="#fig:treesize" >Figure 4</a> shows the number of nodes in the SCT vs the number of edges (m) for different graphs. The running time of PIVOTER is directly proportional to the SCT size which seems to be roughly linear in the number of edges. <a class="figure" title="Trends in different graphs" href="#fig:trends" >Figure 5</a> shows the trends in clique counts for a number of graphs. For some of the graphs, the complete distribution of their clique counts has been obtained for the first time. <a class="figure" title="Trends in dblp over time." href="#fig:trends-dblp" >Figure 6</a> shows the trends in the clique counts of 2 different versions over time of the dblp graph.</p>
 </div>
<p><strong>Feasible local counting:</strong> Notably, PIVOTER can get per-vertex counts in less than twice the time of global clique counting. Thus, we get  results for more graphs in a few minutes, and can process the <em>com-orkut</em> graph within 3 hours. We consider this a significant achievement, given the combinatorial explosion of clique counting.</p>
<p>PIVOTER is also able to get per-edge clique counts, though it can take an order of magnitude more time than global clique counting. Note that for obtaining the per-vertex and per-edge <span role="math">$k-$</span>clique counts, the result data structure can become extremely large. Indeed, most of the time is spent in updating the data structure, rather than in constructing the SCT. Nonetheless, for all but the <em>as-skitter</em> and <em>com-orkut</em> graph, it runs in minutes.</p>
<p><strong>Comparison with state of the art:</strong> We only focus on the “infeasible” instances of <a href="#tab:main" >Tab 1</a>. For all the other instances, both PIVOTER and kClist40 get results within two minutes. For space considerations, we do not report all the running times for such instances. It is worth noting that the sequential PIVOTER is comparable to the parallel kClist40 (when they both terminate).</p>
<p>In <a href="#tab:comparison" >Tab 2</a>, we report times on TS and kClist40 on the hard datasets. We are unable to get all values of <span role="math">$C_k$</span> using either of these two method. We run these algorithms for up to 100 times the running time of PIVOTER or two days, whichever is shorter. We try to count the largest feasible clique count.</p>
<p>Let us focus on kClist40, where we cannot go beyond counting 13-cliques (we note that this is consistent with results reported in<span class="cite-container">[<a href="#cite:DBS18" class="cite-label">11</a>]</span>).  Notably, in the <em>BerkStan</em> graph, kClist40 needs more than 2 days to count 13-cliques, while PIVOTER gets all clique counts in a minute. As mentioned earlier, clique counting on the large <em>com-orkut</em> graph is done in a few hours by PIVOTER, while even counting 13-cliques takes kClist40 more than two days.</p>
<p>TS also does not scale well for larger cliques and PIVOTER is faster than TS. For example, for the <em>Stanford</em> graph, TS required 230 seconds to estimate the number of 13-cliques whereas PIVOTER obtained all <span role="math">$k-$</span>clique counts in 5 seconds. Similar trends are observed with other graphs.</p>
<p><strong>Parallel global clique counting:</strong> As mentioned in <a href="#sec:count">§count</a>, we do a simple parallelization of the global clique counting of PIVOTER using 30 threads. It gives moderate benefits for most instances, and about a factor two speedup for large instances. For the challenging <em>com-lj</em> instances, the effect is much more dramatic.  We are able to count <span role="math">$7$</span>-cliques in an hour using the parallel PIVOTER, while the sequential version takes more than a day.</p>
<p><strong>Performance on com-lj.</strong> This is a particularly challenging graph.  The sequential version of PIVOTER for counting all <span role="math">$k$</span>-cliques did not terminate within a day,  so we used the parallel version of our algorithm to show a comparison for global counts upto <span role="math">$k=10$</span>. We can truncate the SCT to get cliques of some fixed size. <a href="#tab:com-lj" >Tab 3</a> shows the results. Even for this graph, the parallel version of PIVOTER is faster than kClist40 for <span role="math">$k=7$</span> and beyond. kClist40 did not terminate after six days, for <span role="math">$k = 9$</span> and beyond. We note the astronomical number of 10-cliques (<span role="math">$&gt; 10^{19}$</span>), which makes enumeration infeasible, but PIVOTER was able to get the exact count.</p>
<p><strong>Size of <span role="math">$SCT(G)$</span>:</strong> In <a class="figure" title="Number of nodes in SCT vs m" href="#fig:treesize" >Figure 4</a>, we plot the number of nodes of <span role="math">$SCT(G)$</span> as a function of the number of edges in <span role="math">$G$</span>. We observe that for most graphs, the size is quite close to <span role="math">$m$</span>, explaining why PIVOTER is efficient.</p>
<h3 id="Demonstrations-of-PIVOTER">Demonstrations of PIVOTER<a class="header-anchor" href="#Demonstrations-of-PIVOTER">#</a></h3>
<div id="sec:appl"></div>
<p>Global and local cliques have numerous applications. It is  outside the scope of this work for detailed demonstrations, but we show a few examples in this section.</p>
<p>As mentioned earlier, local clique counts are an important aspect of graph processing. In <a class="figure" title="Frequency distribution" href="#fig:soc-pokec-occurrences" >Figure 2</a> and <a class="figure" title="Frequency distribution" href="#fig:web-Stanford-occurrences" >Figure 3</a>, we plot the per-vertex clique distributions, also called the <em>graphlet</em> degree distribution in bioinformatics<span class="cite-container">[<a href="#cite:Pr07" class="cite-label">22</a>]</span> for the as-skitter and web-Stanford graphs. We choose values of <span role="math">$k = 5, 10, 15, 20, 25$</span>. Then, we plot the function <span role="math">$f_k(b)$</span> that is the number of vertices that participate in <span role="math">$b$</span> <span role="math">$k$</span>-cliques. We notice interesting trends. While the as-skitter graph has a nicely decaying <span role="math">$f_k$</span> function, there is much more noise in web-Stanford. It would be interesting to design models that can capture such behavior in the local clique counts.</p>
<p>In <a class="figure" title="Trends in different graphs" href="#fig:trends" >Figure 5</a>, we plot the <span role="math">$C_k$</span> values for a number of graphs. We notice, for example, that the <em>soc-pokec</em> network has a “flatter” distribution of <span role="math">$C_k$</span> for some of the initial values, while the <em>com-orkut</em> graph looks much closer to a binomial distribution. The latter suggests that the bulk of cliques are coming from the maximum clique in the <em>com-orkut</em> graph, but not so in the <em>soc-pokec</em> graph.</p>
<p>In <a class="figure" title="Trends in dblp over time." href="#fig:trends-dblp" >Figure 6</a>, we plot the <span role="math">$k$</span>-clique counts (vs <span role="math">$k$</span>) for two different versions across time for the DBLP citation network<span class="cite-container">[<a href="#cite:Aminer" class="cite-label">4</a>]</span>.  Interestingly, despite the later version only having less than twice as many edges,  the clique distribution (plotted in semilog) has a much bigger difference. It appears that the graph is becoming significantly dense in certain part. This sort of analysis may help in understanding dynamic graphs.</p>
<h2 id="FUTURE-WORK">FUTURE WORK<a class="header-anchor" href="#FUTURE-WORK">#</a></h2>
<div id="sec:future"></div>
<p>We provide an exact clique counting algorithm that counts all <span role="math">$k$</span>-cliques in a fraction of the time of other state-of-the-art parallel algorithms. One of the key ideas is the use of pivoting to create the SCT, and succinct representation of all the cliques of the graph. The success of<span class="cite-container">[<a href="#cite:DBS18" class="cite-label">11</a>]</span> in using parallelization for clique counting suggests combining their ideas with our pivoting techniques. We may be able to come up with an efficient parallel building of the SCT that is much faster than our current implementation. Indeed, the results on the <em>com-lj</em> graph suggest that even PIVOTER has its limits for real data.</p>
<p>An orthogonal approach would be to exploit the sampling techniques in the Turán-Shadow algorithm<span class="cite-container">[<a href="#cite:JS17" class="cite-label">18</a>]</span>. For many subgraph counting problems, randomization has been the key to truly practical algorithms. We believe that PIVOTER could be made faster with  these ideas.</p>
<p>Moreover, it also gives per-edge and per-vertex <span role="math">$k-$</span>clique counts. This is the first time that <span role="math">$k-$</span>clique counts are known for many of the graphs we experimented with and this will open doors for further use of cliques in generation and analysis of graphs.</p>
<h2 id="ACKNOWLEDGMENTS">ACKNOWLEDGMENTS<a class="header-anchor" href="#ACKNOWLEDGMENTS">#</a></h2>
<p>Shweta Jain and C. Seshadhri acknowledge the support of NSF Awards CCF-1740850, CCF-1813165, and ARO Award W911NF1910294.</p>
<h2 id="REFERENCES">REFERENCES<a class="header-anchor" href="#REFERENCES">#</a></h2>
<ol class="cite-list"><li class="cite-item"><div class="cite-label" id="cite:A73">[1]</div><div class="cite-content"><span class="cite-author">E. A. Akkoyunlu. </span><span class="cite-year">1973. </span><span class="cite-title">The enumeration of maximal cliques of large graphs. </span><span class="cite-journal">SIAM J. Comput. </span><span class="cite-volume">2 </span><span class="cite-timestamp">(2016.10.21), </span><span class="cite-pages">(1-6)</span></div></li><li class="cite-item"><div class="cite-label" id="cite:AhNe+15">[2]</div><div class="cite-content"><span class="cite-author">Nesreen K. Ahmed and Jennifer Neville and Ryan A. Rossi and Nick Duffield. </span><span class="cite-year">2015. </span><span class="cite-title">Efficient Graphlet Counting for Large Networks. </span><span class="cite-timestamp">(2016.02.10), </span></div></li><li class="cite-item"><div class="cite-label" id="cite:AlYuZw94">[3]</div><div class="cite-content"><span class="cite-author">Alon, Noga and Yuster, Raphy and Zwick, Uri. </span><span class="cite-year">1994. </span><span class="cite-title">Color-coding: A New Method for Finding Simple Paths, Cycles and Other Small Subgraphs Within Large Graphs. </span><span class="cite-pages">(326--335)</span></div></li><li class="cite-item"><div class="cite-label" id="cite:Aminer">[4]</div><div class="cite-content"><span class="cite-author">"Jie Tang and Jing Zhang and Limin Yao and Juanzi Li and Li Zhang and Zhong Su". </span><span class="cite-year">2008. </span><span class="cite-title">"ArnetMiner: Extraction and Mining of Academic Social Networks". </span><span class="cite-pages">("990-998")</span></div></li><li class="cite-item"><div class="cite-label" id="cite:BK73">[5]</div><div class="cite-content"><span class="cite-author">Bron, Coen and Kerbosch, Joep. </span><span class="cite-year">1973. </span><span class="cite-title">Algorithm 457: Finding All Cliques of an Undirected Graph. </span><span class="cite-journal">Commun. ACM </span><span class="cite-volume">16 </span><span class="cite-pages">(575--577)</span></div></li><li class="cite-item"><div class="cite-label" id="cite:BeGlLe16">[6]</div><div class="cite-content"><span class="cite-author">A. Benson and D. F. Gleich and J. Leskovec. </span><span class="cite-year">2016. </span><span class="cite-title">Higher-order organization of complex networks. </span><span class="cite-journal">Science </span><span class="cite-volume">353 </span><span class="cite-pages">(163-166)</span></div></li><li class="cite-item"><div class="cite-label" id="cite:BeHe+11">[7]</div><div class="cite-content"><span class="cite-author">Berry, Jonathan W. and Hendrickson, Bruce and LaViolette, Randall A. and Phillips, Cynthia A.. </span><span class="cite-year">2011. </span><span class="cite-title">Tolerating the community detection resolution limit with edge weighting. </span><span class="cite-journal">Phys. Rev. E </span><span class="cite-volume">83 </span><span class="cite-pages">(056119)</span></div></li><li class="cite-item"><div class="cite-label" id="cite:BetzlerBFKN11">[8]</div><div class="cite-content"><span class="cite-author">Nadja Betzler and Ren&eacute; van Bevern and Michael R. Fellows and Christian Komusiewicz and Rolf Niedermeier. </span><span class="cite-year">2011. </span><span class="cite-title">Parameterized Algorithmics for Finding Connected Motifs in Biological Networks. </span><span class="cite-journal">IEEE/ACM Trans. Comput. Biology Bioinform. </span><span class="cite-volume">8 </span><span class="cite-pages">(1296-1308)</span></div></li><li class="cite-item"><div class="cite-label" id="cite:CHKX04">[9]</div><div class="cite-content"><span class="cite-author">Jianer Chen and Xiuzhen Huang and Iyad A. Kanj and Ge Xia. </span><span class="cite-year">2004. </span><span class="cite-title">Linear {FPT} reductions and computational lower bounds. </span><span class="cite-timestamp">(Wed, 15 Feb 2006 09:55:49 +0100), </span><span class="cite-pages">(212--221)</span></div></li><li class="cite-item"><div class="cite-label" id="cite:ChNi85">[10]</div><div class="cite-content"><span class="cite-author">Chiba, Norishige and Nishizeki, Takao. </span><span class="cite-year">1985. </span><span class="cite-title">Arboricity and subgraph listing algorithms. </span><span class="cite-journal">SIAM J. Comput. </span><span class="cite-volume">14 </span><span class="cite-pages">(210--223)</span></div></li><li class="cite-item"><div class="cite-label" id="cite:DBS18">[11]</div><div class="cite-content"><span class="cite-author">Maximilien Danisch and Oana Denisa Balalau and Mauro Sozio. </span><span class="cite-year">2018. </span><span class="cite-title">Listing k-cliques in Sparse Real-World Graphs. </span><span class="cite-timestamp">(Wed, 21 Nov 2018 12:44:11 +0100), </span><span class="cite-pages">(589--598)</span></div></li><li class="cite-item"><div class="cite-label" id="cite:ELS13">[12]</div><div class="cite-content"><span class="cite-author">David Eppstein and  Maarten L&ouml;ffler and  Darren Strash. </span><span class="cite-year">2013. </span><span class="cite-title">Listing All Maximal Cliques in Large Sparse Real-World Graphs. </span><span class="cite-journal">{ACM} Journal of Experimental Algorithmics </span><span class="cite-volume">18 </span><span class="cite-timestamp">(Wed, 08 Apr 2015 14:32:05 +0200), </span></div></li><li class="cite-item"><div class="cite-label" id="cite:ES11">[13]</div><div class="cite-content"><span class="cite-author">Eppstein, David and L&ouml;ffler, Maarten and Strash, Darren. </span><span class="cite-year">2010. </span><span class="cite-title">Listing all maximal cliques in sparse graphs in near-optimal time. </span><span class="cite-pages">(403--414)</span></div></li><li class="cite-item"><div class="cite-label" id="cite:Escape">[14]</div><div class="cite-content"><span class="cite-author">Pinar, Ali and Seshadhri, C and Vishal, Vaidyanathan. </span><span class="cite-year">2017. </span><span class="cite-title">Escape: Efficiently counting all 5-vertex subgraphs. </span><span class="cite-pages">(1431--1440)</span></div></li><li class="cite-item"><div class="cite-label" id="cite:FFF15">[15]</div><div class="cite-content"><span class="cite-author">Irene Finocchi and  Marco Finocchi and  Emanuele G. Fusco. </span><span class="cite-year">2015. </span><span class="cite-title">Clique Counting in MapReduce: Algorithms and Experiments. </span><span class="cite-journal">{ACM} Journal of Experimental Algorithmics </span><span class="cite-volume">20 </span><span class="cite-timestamp">(Mon, 08 Feb 2016 17:41:45 +0100), </span></div></li><li class="cite-item"><div class="cite-label" id="cite:HR05">[16]</div><div class="cite-content"><span class="cite-author">Robert A. Hanneman and Mark Riddle. </span><span class="cite-year">2005. </span><span class="cite-title">Introduction to social network methods. </span><span class="cite-timestamp">(2016.10.21), </span></div></li><li class="cite-item"><div class="cite-label" id="cite:J10">[17]</div><div class="cite-content"><span class="cite-author">Matthew O. Jackson. </span><span class="cite-year">2010. </span><span class="cite-title">Social and Economic Networks. </span><span class="cite-timestamp">(2016.10.21), </span></div></li><li class="cite-item"><div class="cite-label" id="cite:JS17">[18]</div><div class="cite-content"><span class="cite-author">Jain, Shweta and Seshadhri, C. </span><span class="cite-year">2017. </span><span class="cite-title">A Fast and Provable Method for Estimating Clique Counts Using Tur&aacute;n's Theorem. </span><span class="cite-pages">(441--449)</span></div></li><li class="cite-item"><div class="cite-label" id="cite:JhSePi15">[19]</div><div class="cite-content"><span class="cite-author">M. Jha and C. Seshadhri and A. Pinar. </span><span class="cite-year">2015. </span><span class="cite-title">Path Sampling: A Fast and Provable Method for Estimating 4-Vertex Subgraph Counts. </span><span class="cite-timestamp">(2015.02.19), </span><span class="cite-pages">(495-505)</span></div></li><li class="cite-item"><div class="cite-label" id="cite:MB83">[20]</div><div class="cite-content"><span class="cite-author">Matula, David W and Beck, Leland L. </span><span class="cite-year">1983. </span><span class="cite-title">Smallest-last ordering and clustering and graph coloring algorithms. </span><span class="cite-journal">Journal of the ACM (JACM) </span><span class="cite-volume">30 </span><span class="cite-pages">(417--427)</span></div></li><li class="cite-item"><div class="cite-label" id="cite:MarcusS10">[21]</div><div class="cite-content"><span class="cite-author">Dror Marcus and Yuval Shavitt. </span><span class="cite-year">2010. </span><span class="cite-title">Efficient Counting of Network Motifs. </span><span class="cite-pages">(92-98)</span></div></li><li class="cite-item"><div class="cite-label" id="cite:Pr07">[22]</div><div class="cite-content"><span class="cite-author">Natasa Przulj. </span><span class="cite-year">2007. </span><span class="cite-title">Biological network comparison using graphlet degree distribution. </span><span class="cite-journal">Bioinformatics </span><span class="cite-volume">23 </span><span class="cite-pages">(177?-183)</span></div></li><li class="cite-item"><div class="cite-label" id="cite:RKKS17">[23]</div><div class="cite-content"><span class="cite-author">Rahmtin Rotabi and Krishna Kamath and Jon M. Kleinberg and Aneesh Sharma. </span><span class="cite-year">2017. </span><span class="cite-title">Detecting Strong Ties Using Network Motifs. </span><span class="cite-timestamp">(Tue, 06 Nov 2018 16:57:06 +0100), </span><span class="cite-pages">(983--992)</span></div></li><li class="cite-item"><div class="cite-label" id="cite:SGB16">[24]</div><div class="cite-content"><span class="cite-author">Ann Sizemore and Chad Giusti and Danielle S. Bassett. </span><span class="cite-year">2016. </span><span class="cite-title">Classification of weighted networks through mesoscale homological features. </span><span class="cite-journal">Journal of Complex Networks </span><span class="cite-volume">10.1093 </span><span class="cite-timestamp">(2016.10.21), </span></div></li><li class="cite-item"><div class="cite-label" id="cite:SaSePi14">[25]</div><div class="cite-content"><span class="cite-author">Ahmet Erdem Sariy&uuml;ce and C. Seshadhri and Ali Pinar and &Uuml;mit V. &Ccedil;ataly&uuml;rek. </span><span class="cite-year">2015. </span><span class="cite-title">Finding the Hierarchy of Dense Subgraphs using Nucleus Decompositions. </span><span class="cite-pages">(927--937)</span></div></li><li class="cite-item"><div class="cite-label" id="cite:SePiKo14">[26]</div><div class="cite-content"><span class="cite-author">C. Seshadhri and Ali Pinar and Tamara G. Kolda. </span><span class="cite-year">2014. </span><span class="cite-title">Wedge sampling for computing clustering coefficients and triangle counts on large graphs. </span><span class="cite-journal">Statistical Analysis and Data Mining </span><span class="cite-volume">7 </span><span class="cite-timestamp">(Sat, 20 May 2017 00:26:36 +0200), </span><span class="cite-pages">(294--307)</span></div></li><li class="cite-item"><div class="cite-label" id="cite:SeTi19">[27]</div><div class="cite-content"><span class="cite-author">C. Seshadhri and Srikanta Tirthapura. </span><span class="cite-year">2019. </span><span class="cite-title">Scalable Subgraph Counting: The Methods Behind The Madness: {WWW} 2019 Tutorial. </span></div></li><li class="cite-item"><div class="cite-label" id="cite:TPM17">[28]</div><div class="cite-content"><span class="cite-author">Charalampos E. Tsourakakis and Jakub Pachocki and Michael Mitzenmacher. </span><span class="cite-year">2017. </span><span class="cite-title">Scalable Motif-aware Graph Clustering. </span><span class="cite-timestamp">(Tue, 06 Nov 2018 16:57:07 +0100), </span><span class="cite-pages">(1451--1460)</span></div></li><li class="cite-item"><div class="cite-label" id="cite:Tomita04">[29]</div><div class="cite-content"><span class="cite-author">Tomita, Etsuji and Tanaka, Akira and Takahashi, Haruhisa. </span><span class="cite-year">2006. </span><span class="cite-title">The Worst-Case Time Complexity for Generating All Maximal Cliques. </span><span class="cite-journal">Theoretical Computer Science </span><span class="cite-volume">363 </span><span class="cite-pages">(28--42)</span></div></li><li class="cite-item"><div class="cite-label" id="cite:Ts15">[30]</div><div class="cite-content"><span class="cite-author">Charalampos E. Tsourakakis. </span><span class="cite-year">2015. </span><span class="cite-title">The K-clique Densest Subgraph Problem. </span><span class="cite-timestamp">(Mon, 25 May 2015 17:32:51 +0200), </span><span class="cite-pages">(1122--1132)</span></div></li><li class="cite-item"><div class="cite-label" id="cite:UganderBK13">[31]</div><div class="cite-content"><span class="cite-author">Johan Ugander and Lars Backstrom and Jon M. Kleinberg. </span><span class="cite-year">2013. </span><span class="cite-title">Subgraph frequencies: mapping the empirical and extremal geography of large graph collections. </span><span class="cite-pages">(1307-1318)</span></div></li><li class="cite-item"><div class="cite-label" id="cite:V09">[32]</div><div class="cite-content"><span class="cite-author">Virginia Vassilevska. </span><span class="cite-year">2009. </span><span class="cite-title">Efficient algorithms for clique problems. </span><span class="cite-journal">Information Processing Letters </span><span class="cite-volume">109 </span><span class="cite-pages">(254 - 257)</span></div></li><li class="cite-item"><div class="cite-label" id="cite:WaZh+18">[33]</div><div class="cite-content"><span class="cite-author">Pinghui Wang and Junzhou Zhao and Xiangliang Zhang and Zhenguo Li and Jiefeng Cheng and John C. S. Lui and Don Towsley and Jing Tao and Xiaohong Guan. </span><span class="cite-year">2018. </span><span class="cite-title">{MOSS-5:} {A} Fast Method of Approximating Counts of 5-Node Graphlets in Large Graphs. </span><span class="cite-journal">tkde </span><span class="cite-volume">30 </span><span class="cite-timestamp">(Wed, 10 Jan 2018 15:12:39 +0100), </span><span class="cite-pages">(73--86)</span></div></li><li class="cite-item"><div class="cite-label" id="cite:YiBiKe18">[34]</div><div class="cite-content"><span class="cite-author">Hao Yin and Austin R. Benson and Jure Leskovec. </span><span class="cite-year">2018. </span><span class="cite-title">Higher-order clustering in networks. </span><span class="cite-journal">Phys. Rev. E </span><span class="cite-volume">97 </span><span class="cite-timestamp">(Fri, 01 Feb 2019 08:07:59 +0100), </span><span class="cite-pages">(052306)</span></div></li><li class="cite-item"><div class="cite-label" id="cite:YiBiKe19">[35]</div><div class="cite-content"><span class="cite-author">Hao Yin and Austin R. Benson and Jure Leskovec. </span><span class="cite-year">2019. </span><span class="cite-title">The Local Closure Coefficient: {A} New Perspective On Network Clustering. </span><span class="cite-timestamp">(Fri, 01 Feb 2019 08:07:59 +0100), </span><span class="cite-pages">(303--311)</span></div></li><li class="cite-item"><div class="cite-label" id="cite:ZhWaBu+12">[36]</div><div class="cite-content"><span class="cite-author">Z. Zhao and G. Wang and A. Butt and M. Khan and V. S. Anil Kumar and M. Marathe. </span><span class="cite-year">2012. </span><span class="cite-title">SAHAD: Subgraph Analysis in Massive Networks Using Hadoop. </span><span class="cite-timestamp">(2014.06.10), </span><span class="cite-pages">(390-401)</span></div></li><li class="cite-item"><div class="cite-label" id="cite:lu2018community">[37]</div><div class="cite-content"><span class="cite-author">Lu, Zhenqi and Wahlstr&ouml;m, Johan and Nehorai, Arye. </span><span class="cite-year">2018. </span><span class="cite-title">Community detection in complex networks via clique conductance. </span><span class="cite-journal">Scientific reports </span><span class="cite-volume">8 </span><span class="cite-pages">(5982)</span></div></li></ol></div><div class="article-licensing box"><div class="licensing-title"><p>The Power of Pivoting for Exact Clique Counting</p><p><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2001.06784">https://arxiv.org/abs/2001.06784</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Original author</h6><p>Shweta Jain, C. Seshadhri</p></div></div><div class="level-item is-narrow"><div><h6>Original posted on</h6><p>2020-01-19</p></div></div><div class="level-item is-narrow"><div><h6>Article posted on</h6><p>2021-01-14</p></div></div><div class="level-item is-narrow"><div><h6>Article updated on</h6><p>2021-01-14</p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/"></a><a class="link-muted mr-2" rel="tag" href="/"></a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" href="http://afdian.net/@tootal" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>Afdian.net</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/asset/alipay.webp" alt="Alipay"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/asset/wechat_pay.webp" alt="Wechat"></span></a></div></div></div><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div class="content twikoo" id="twikoo"></div><script src="https://cdn.jsdelivr.net/npm/twikoo@1.2.0/dist/twikoo.all.min.js"></script><script>twikoo.init({
      envId: 'tootal-6g2y019v6b37e4be',
      region: 'ap-guangzhou',
      path: "'/en/clique-counting.html'",
      katex: {
        delimiters: 
        [
          {left: "$$", right: "$$", display: true},
          {left: "$", right: "$", display: false}
        ],
        throwOnError: false
      }
    });</script></div></div></div><!--!--><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Tootal Blog</a><p class="is-size-7"><span>&copy; 2021 Huang Zhiquan</span><span>&nbsp;&nbsp; Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>&nbsp;&&nbsp;<a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></span><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span><br><a href="http://beian.miit.gov.cn/" target="_blank" rel="noopener">赣ICP备20007667号-1</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="View on GitHub" href="https://github.com/tootal/tootal.github.io"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/mhchem.js" defer></script><script>
    var katex_config = {
      delimiters: 
      [
        {left: "$$", right: "$$", display: true},
        {left: "$", right: "$", display: false}
      ],
      strict: false,
      throwOnError: false
    };
    window.addEventListener("load", function() {
      document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
        renderMathInElement(element, katex_config);
      });
      document.querySelectorAll('#toc .level-item').forEach(function(element) {
        renderMathInElement(element, katex_config);
      });
    });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>