{"pages":[{"title":"404 FILE NOT FOUND","text":"为什么是404呢？ 1234567404页面是客户端在浏览网页时，服务器无法正常提供信息，或是服务器无法回应，且不知道原因所返回的页面。据说在第三次科技革命之前，互联网的形态就是一个大型的中央数据库，这个数据库就设置在404房间里面。那时候所有的请求都是由人工手动完成的，如果在数据库中没有找到请求者所需要的文件，或者由于请求者写错了文件编号，用户就会得到一个返回信息：room 404 : file not found。404错误信息通常是在目标页面被更改或移除，或客户端输入页面地址错误后显示的页面，人们也就习惯了用404作为服务器未找到文件的错误代码了。当然实际考证传说中的room 404是不存在的，在http请求3位的返回码中，4开头的代表客户错误，5开头代表服务器端错误。 当用户不小心访问了某一个不存在的页面并且没有设置错误提示 时，用户会怎么做？ 如果是初次到访的访客，那么回头率是多少呢？毫无疑问，会抱怨为何出现错误，之后当然是直接关闭窗口离开。 所以设置了 404页面也相当于是做了一个针对用户的提示页面，当用户访问了某一个 不存在的页面后就会转到404页面，然后因为你在这个404页面上有友好 的提示，并且有首页和主要栏目页的连接，用户就很有可能会再次点击进入你的首页。 但是，Web服务器默认的404错误页面，无论是Apache还是IIS，均十分简陋、呆板且对用户不友好，无法给用户提供必要的信息以获取更 多线索，无疑这会造成用户的流失。 因此，很多网站均使用自定义404错误的方式提供用户体验避免用户流失。 一般而言，自定义404页面通用的做法是在页面中放置网站快速导航链接、搜索框以及网页提供的特色服务，这样可以有效的帮助用户访问站点并获取需要的信息。 自从互联网诞生以来，设计师们为了让你不会因为错误访问而对网站失望，在 404 页面上花了不少功夫，而 404 页面的变化也是互联网交互形式发展的一个剪影。 下面是一些404页面：（请欣赏） 愿你的互联网历程中不会遇到太多的 404。 参考资料： https://baike.baidu.com/item/404页面 https://baike.baidu.com/tashuo/browse/content?id=c879ed0e4e3462147f340991&amp;lemmaId=&amp;fromLemmaModule=pcBottom 图片以及部分文字来源于：「404错误」传说是假的，但你一定猜不到哪家网站的404页面最好玩","link":"/404"},{"title":"","text":"{\"created_time\":\"2021-02-14T11:20:09Z\",\"files\":[{\"attachment_folder\":\"\",\"created_time\":\"2021-02-14T11:21:15Z\",\"id\":\"2\",\"modified_time\":\"2021-02-14T11:21:15Z\",\"name\":\"404.md\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2021-02-14T11:21:15Z\",\"id\":\"3\",\"modified_time\":\"2021-03-11T16:37:36Z\",\"name\":\"README.md\",\"tags\":[]}],\"folders\":[{\"name\":\"vx_recycle_bin\"},{\"name\":\"_posts\"},{\"name\":\"_drafts\"},{\"name\":\"en\"}],\"id\":\"1\",\"modified_time\":\"\",\"version\":\"1\"}","link":"/vx.json"},{"title":"","text":"{\"created_time\":\"2021-01-30T04:57:56Z\",\"files\":[{\"attachment_folder\":\"\",\"created_time\":\"2021-01-14T12:43:51Z\",\"id\":\"0\",\"modified_time\":\"2021-01-14T12:43:51Z\",\"name\":\"clique-counting.md\",\"tags\":[\"算法\",\"图论\"]}],\"folders\":[],\"id\":\"0\",\"version\":\"1\"}","link":"/en/vx.json"},{"title":"The Power of Pivoting for Exact Clique Counting","text":"ABSTRACT# Clique counting is a fundamental task in network analysis, and even the simplest setting of $3$-cliques (triangles) has been the center of much recent research. Getting the count of $k$-cliques for larger $k$ is algorithmically challenging, due to the exponential blowup in the search space of large cliques. But a number of recent applications (especially for community detection or clustering) use larger clique counts. Moreover, one often desires local counts, the number of $k$-cliques per vertex/edge. Our main result is PIVOTER, an algorithm that exactly counts the number of $k$-cliques, for all values of $k$. It is surprisingly effective in practice, and is able to get clique counts of graphs that were beyond the reach of previous work. For example, PIVOTER gets all clique counts in a social network with a 100M edges within two hours on a commodity machine. Previous parallel algorithms do not terminate in days. PIVOTER can also feasibly get local per-vertex and per-edge $k$-clique counts (for all $k$) for many public data sets with tens of millions of edges. To the best of our knowledge, this is the first algorithm that achieves such results. The main insight is the construction of a Succinct Clique Tree (SCT) that stores a compressed unique representation of all cliques in an input graph. It is built using a technique called pivoting, a classic approach by Bron-Kerbosch to reduce the recursion tree of backtracking algorithms for maximal cliques. Remarkably, the SCT can be built without actually enumerating all cliques, and provides a succinct data structure from which exact clique statistics ($k$-clique counts, local counts) can be read off efficiently. INTRODUCTION# Subgraph counting (also known as motif counting, graphlet counting) is a fundamental algorithmic problem in network analysis, widely applied in domains such as social network analysis, bioinformatics, cybersecurity, and physics (refer to tutorial[27] and references within). One of the most important cases is that of clique counting. A $k$-clique is a complete subgraph on $k$ vertices, and has great significance in network analysis (Chap. 11 of[16] and Chap. 2 of[17]). Indeed, just the special case of $k=3$ (triangle counting) has a rich history in modern network science. General clique counting has received much attention in recent times [2,11,14,15,18,19,21]. There is a line of recent work on exploiting clique counts for community detection and dense subgraph discovery [6,25,28,30,35,37]. Despite much effort on this problem, it has been challenging to get scalable algorithms for clique counting. There is a large literature for counting $3$-cliques (triangles) and some of these methods have been extended to counting cliques upto size $5$[2,14,19,21]. However, practical algorithms for counting cliques beyond size $5$ have proven to be much harder, and the reason for this is combinatorial explosion. Essentially, as $k$ increases, the number of $k$-cliques blows up. For large graphs, some recent practical algorithms have succeeded in counting up to (around) 10-cliques[11,15,18]. They either use randomized approximation or parallelism to speed up their counting. Besides the obvious problem that they do not scale for larger $k$, it is difficult to obtain more refined clique counts (such as counts for every vertex or every edge). Figure 1 shows the comparison of time taken (in seconds) by PIVOTER for 4 of our largest graphs to count all $k-$cliques with the time taken by kClist40 (the parallel version of the state of the art algorithm kClist that uses 40 threads) to count the number of $k-$cliques, where $k$ is the maximum clique size in each graph. For Stanford, BerkStan, as-skitter, orkut, the maximum clique sizes were 61, 201, 67 and 51 resp. PIVOTER terminated for most graphs in minutes, (except for orkut, for which it took about 2 hours) whereas kClist40 had not terminated even after 3 days, giving a speedup of 100x to 10000x. Figure 1 also shows the time taken by PIVOTER to obtain the per-vertex and per-edge $k-$clique counts. They were within a factor of the time taken to obtain global $k-$clique counts. Figure 2 and Figure 3 shows the frequency distribution of $k$-cliques i.e. for every number $r$ on the x-axis, the y-axis shows the number of vertices that participate in $r$ $k$-cliques, for $k \\in [5, 10, 15, 20, 25]$ for as-skitter and web-Stanford graphs. Problem Statement# We are given an undirected, simple graph $G(V,E)$. For $k \\geq 3$, a $k$-clique is a set of $k$ vertices that induce a complete subgraph (it contains all edges among the $k$ vertices). We will denote the number of $k$-cliques as $C_k$. For a vertex $v \\in V$, we use $c_k(v)$ to denote the number of $k$-cliques that $v$ participates in. Analogously, we define $c_k(e)$ for edge $e \\in E$. We focus on the following problems, in increasing order of difficulty. We stress that $k$ is not part of the input, and we want results for all values of $k$. Global clique counts: Output, $\\forall k \\geq 3$, $C_k$. Per-vertex clique counts: Output, $\\forall k$, $\\forall v \\in V$, the value $c_k(v)$. Per-edge clique counts: Output, $\\forall k$, $\\forall e \\in E$, the value $c_k(e)$. The per-vertex and per-edge counts are sometimes called local counts. In clustering applications, the local counts are used as vertex or edge weights, and are therefore even more useful than global counts[6,25,28,30,35,37]. Challenges: Even the simplest problem of getting global clique counts subsumes a number of recent results on clique counting [11,15,18]. The main challenge is combinatorial explosion: for example, the web-Stanford web graph with 2M edges has 3000 trillion $15$-cliques. These numbers are even more astronomical for larger graphs. Any method that tries to enumerate is doomed to failure. Amazingly, recent work by Danisch-Balalau-Sozio uses parallel algorithms to count beyond trillions of cliques. But even their algorithm fails to get all global clique counts for a number of datasets. Randomized methods have been used with some success, but even they cannot estimate all clique counts[15,18]. Local counting, for all $k$, is even harder, especially given the sheer size of the output. Parallel methods would eventually need to store local counts for every subproblem, which would increase the overall memory footprint. For local counts, sampling would require far too many random variables, each of which need to be sampled many times for convergence. (We give more explanation in §related.) This raises the main question: Is there a scalable, exact algorithm for getting all global and local cliques counts, on real-world graphs with millions of edges? To the best of our knowedge, there is no previous algorithm that can solve these problems on even moderate-sized graphs with a few million edges. Main contributions# Our main contribution is a new practical algorithm PIVOTER for the global and local clique counting problems. Exact counting without enumeration: Current methods for exact clique counting perform an enumeration, in that the algorithm explicitly “visits” every clique. Thus, this method cannot scale to counting larger cliques, since the number of cliques is simply too large. Our main insight is that the method of pivoting, used to reduce recursion trees for maximal clique enumeration[5,12], can be applied to counting cliques of all sizes. Succinct Clique Trees through Pivoting: We prove that pivoting can be used to construct a special data structure called the Succinct Clique Tree (SCT). The SCT stores a unique representation of all cliques, but is much smaller than the total number of cliques. It can also be built quite efficiently. Additionally, given the tree, one can easily “read off” the number of $k$-cliques and various local counts in the graph. Remarkably, we can get all counts without storing the entire tree and the storage required at any point is linear in the number of edges. Excellent practical performance: We implement PIVOTER on a commodity machine. For global clique counting, PIVOTER is able to process graphs of up to tens of millions of edges in minutes. Previous results either work only for small values of $k$ (typically up to $10$) or take much longer. Consider Figure 1, where the time of PIVOTER is compared with that of kClist (the state of the art parallel algorithm for clique counting)[11]. In the instances shown kClist did not terminate even after running for 3 days. By contrast, for the largest com-orkut social network with more than 100M edges, PIVOTER gets all values of $C_k$ within two hours. (Typically, in this time, kClist gets $k-$clique counts only up to $k \\leq 13$.) Feasible computation of local counts: PIVOTER is quite efficient for per-vertex counts, and runs in at most twice the time for global counts. The times for local clique counting are given in Figure 1. Even for the extremely challenging problem of per-edge counts, in most instances PIVOTER gets these numbers in a few hours. (For the com-orkut social network though, it takes a few days.) This allows us to get data shown in Figure 2 and Figure 3, that plots the frequency distribution of $k$-cliques. (In other words, for every number $r$, we plot the number of vertices that participate in $r$ $k$-cliques.) As mentioned earlier, this information is used for dense subgraph discovery[25,30]. To the best of our knowledge, this is the first algorithm that is able to get such information for real-world graphs. Related Work# Subgraph counting has an immensely rich history in network science, ranging from applications across social network analysis, bioinformatics, recommendation systems, graph clustering (we refer the reader to the tutorial[27] and references within). We only describe work directly relevant to clique counting. The simplest case of clique counting is triangle counting, which has received much attention from the data mining and algorithms communities. Recent work has shown the relevance of counts of large subgraphs (4, 5 vertex patterns) [7,23,24,31,34]. Local clique counts have played a significant role in a flurry of work on faster and better algorithms for dense subgraph discovery and community detection[6,25,28,30]. The latter results define the “motif conductance”, where cuts are measured by the number of subgraphs (not just edges) cut. This has been related to higher order clustering coefficients[34,35]. These quantities are computed using local clique counts, underscoring the importance of these numbers. The problem of counting cliques (and variants such as counting maximal cliques) has received much attention both from the applied and theoretical computer science communities[3,9,10,32]. Classic techniques like color-coding[8,36] and path sampling[19,26,33] have been employed for counting cliques up to size $5$. For larger cliques, Finocchi-Finocchi-Fusco gave a MapReduce algorithm that uses orientation and sampling techniques[15]. Jain and Seshadhri use methods from extremal combinatorics to give a fast sampling algorithm[18], that is arguably the fastest approximate clique counter to date. In a remarkable result, Danisch-Balalau-Sozio gave a parallel implementation (kClist) of a classic algorithm of Chiba-Nishizeki, which is able to enumerate upto trillions of cliques[11]. For exact counting, we consider kClist as the state of the art. Despite the collection of clever techniques, none of these methods really scale beyond counting (say) 10-cliques for large graphs. Why local counting is hard: Note that either parallelism or sampling is used to tame the combinatorial explosion. Even though (at least for small $k$), one can enumerate all cliques in parallel, local counting requires updating a potentially global data structure, the list of all $c_k(v)$ or $c_k(e)$ values. To get the benefits of parallelism, one would either have to duplicate a large data structure or combine results for various threads to get all local counts. While this may be feasible, it adds an extra memory overhead. Sampling methods typically require some overhead for convergence. For local counts, there are simply too many samples required to get accurate values for (say) all $c_k(v)$ values. For these reasons, we strongly believe that new ideas were required to get efficient local counting. Maximal clique enumeration: Extremely relevant to our approach is a line of work of maximal clique enumeration. A maximal clique is one that is not contained in a larger clique. Unlike the combinatorial explosion of $k$-cliques, maximal cliques tend to be much fewer. The first algorithm for this problem is the classic Bron-Kerbosch backtracking procedure from the 70s[1,5]. They also introduced an idea called pivoting, that prunes the recursion tree for efficiency. Tomita-Tanaka-Takahashi gave the first theoretical analysis of pivoting rules, and showed asymptotic improvements[29]. Eppstein-Löeffler- Strash combined these ideas with orientation methods to give a practical and provably fast algorithm for maximal clique enumeration[12,13]. An important empirical observation of this line of work is that the underlying recursion tree created with pivoting is typically small for real-world graphs. This is the starting point for our work. MAIN IDEAS# Inspired by the success of maximal clique enumeration through pivoting, we design the Succinct Clique Tree (SCT) of a graph for clique counting. To explain the SCT, it is useful to begin with the simple backtracking algorithm for listing all cliques. For any vertex $v$, let $N(v)$ denote the neighborhood of $v$. Any clique containing $v$ is formed by adding $v$ to a clique contained in $N(v)$. Thus, we can find all cliques by this simple recursive procedure: for all $v$, recursively enumerate all cliques in $N(v)$. For each such clique, add $v$ to get a new clique. It is convenient to think of the recursion tree of this algorithm. Every node of the tree (corresponding to a recursive call) corresponds to a subset $S \\subseteq V$, and the subtree of calls enumerates all cliques contained in $S$. A call to $S$ makes a recursive call corresponding to every $s \\in S$, which is over the set $N(s) \\cap S$ (the neighbors of $v$ in $S$). We can label every edge of the tree (call them links to distinguish from edges of $G$) with a vertex, whose neighborhood leads to the next recursive call. It is not hard to see that the link labels, along any path from a root (that might not end at a leaf), give a clique. Moreover, every clique has such a representation. Indeed, every permutation of clique forms such a path. A simple and classic method to eliminate multiple productions of a clique is acyclic orientations. Simply orient the graph as a DAG, and only make recursive calls on out-neighborhoods. Typically, an orientation is chosen by degeneracy/core decomposition or degree orderings, so that out-neighborhood sizes are minimized. This is a central technique in all recent applied algorithms on clique counting[11,15,18]. Yet it is not feasible to construct the recursion tree to completion, and it is typically truncated at some depth ($\\leq 10$) for large graphs. Is it possible to somehow “compress” the tree, and get a unique (easily accessible) representation of all cliques? The power of pivoting: We discover a suprising answer, in pivoting. This was discovered by Bron-Kerbosch in the context of maximal cliques[5]. We describe, at an intuitive level, how it can be applied for global and local clique counting. For the recursive call at $S$, first pick a pivot vertex $p \\in S$. Observe that the cliques in $S$ can be partitioned into three classes as follows. For clique $C$ contained in $S$: (i) $p \\in C$, (ii) $C \\subset N§$, (iii) $C$ contains a non-neighbor of $p$. There is 1-1 correspondence between cliques of type (i) and (ii), so we could hope to only enumerate type (ii) cliques. Thus, from a recursive call for $S$, we make recursive calls to find cliques in $N§ \\cap S$, and $N(u) \\cap S$ for every non-neighbor $u$ of $p$ in $S$. We avoid making recursive calls corresponding to vertices in $N§$. This gives the main savings over the simple backtracking procedure. The natural choice of $p$ is the highest degree vertex in the graph induced on $S$. The recursion tree obtained is essentially the SCT. We stress that this is quite different from the Bron-Kerbosch recursion tree. The BK algorithm also maintains a set of excluded vertices since it only cares for maximal cliques. This excluded set is used to prune away branches that cannot be maximal; moreover, the pivots in BK are potentially chosen from outside $S$ to increase pruning. The SCT is constructed in this specific manner to ensure unique clique representations, which the BK tree does not provide. The SCT is significantly smaller than recursion trees that use degeneracy orientations (which one cannot feasibly construct). In practice, it can be constructed efficiently for graphs with tens of millions of edges. As before the nodes of the SCT are labeled with subsets (corresponding to the recursive calls), and links are labeled with vertices (corresponding to the vertex whose neighborhood is being processed). Abusing notation, in the following discussion, we refer to a path by the set of link labels in the path. How can we count all cliques using the SCT? Every root to leaf path in the tree corresponds to a clique, but not all cliques correspond to paths. This is distinct from the standard recursion tree discussed earlier, where every clique corresponds to a path from the root. Indeed, this is why the standard recursion trees (even with degeneracy orientations) are large. We prove the following remarkable “unique encoding” property. Within any root to leaf path $T$, there is a subset of links $P$ corresponding to the pivot calls. Every clique $C$ in the graph can be uniquely expressed as $(T\\setminus P) \\cup Q$ for some $Q \\subseteq P$ (for a specific path $T$). The uniqueness is critical for global and local counting, since we can simply write down formulas to extract all counts. Thus, the SCT gives a unique encoding for every clique in the graph. Intuitively, the source of compression can be seen in two different ways. The simplest way is to see that pivoting prunes the tree, because recursive calls are only made for a subset of vertices. But also, not every clique is represented by (the link labels of) a path from the root. Thus, there are far fewer paths in the SCT. The final algorithm is quite simple and the main work was coming up with the above insight. Despite this simplicity, it outperforms even parallel methods for exact clique counting by orders of magnitude. Our main theorem follows. Basically, clique counts can be obtained in time proportional to the size of the SCT. All the technical terms will be formally defined in §prelims. THEOREM 1. Let $G$ be an input graph with $n$ vertices, $m$ edges, and degeneracy $\\alpha$. Let $SCT(G)$ be the Succinct Clique Tree of graph $G$. The procedure PIVOTER$(G)$ correctly outputs all global and local counts. For global and per-vertex counts, the running time is $O(\\alpha^2 |SCT(G)| + m + n)$. For per-edge counts, the running time is $O(\\alpha^3 |SCT(G)| + m + n)$. The storage cost is $O(m+n)$. Empirically, we observe that the SCT is quite small. In the worst-case, $|SCT(G)| = O(n 3^{\\alpha/3})$, which follows from arguments by Eppstein-Löeffler-Strash[12] and Tomita-Tanaka-Takahashi[29] (an exponential dependence is necessary because of the NP-hardness of maximum clique). We give a detailed description in §count PRELIMINARIES# We start with the mathematical formalism required to describe the main algorithm and associated proofs. The input is a simple, undirected graph $G = (V,E)$, where $|V| = n$ and $|E| = m$. It is convenient to assume that $G$ is connected. We use vertices to denote the elements of $V$ (the term nodes will be used for a different construct). We use the following notation for neighborhoods. $N(v)$: This is the neighborhood of $v$. $N(S,v)$: For any subset of vertices $S$, we use $N(S,v)$ to denote $N(v) \\cap S$. Alternately, this is the neighborhood of $v$ in $S$. We will use degeneracy orderings (or core decompositions) to reduce the recursion tree. This is a standard technique for clique counting[10,11,15,18]. This ordering is obtained by iteratively removing the minimum degree vertex, and can be computed in linear time[20]. Typically, one uses this ordering to convert $G$ into a DAG. The largest out-degree is the graph degeneracy, denoted $\\alpha$. We state this fact as a lemma, which is considered a classic fact in graph theory and network science. LEMMA 1. [20] Given a graph $G = (V,E)$, there is a linear time algorithm that constructs an ayclic orientation of $G$ such that all outdegrees are at most $\\alpha$. The most important construct we design is the Succinct Clique Tree (SCT) $\\bm T$. The SCT stores special node and link attributes that are key to getting global and local clique counts, for all values of $k$. The construction and properties of the SCT are given in the next section. Here, we list out technical notation associated with the SCT $\\bm T$. Formally, $\\bm T$ is a tree where nodes are labeled with subsets of $V$, with the following properties. The root is labeled $V$. Parent labels are strict supersets of child labels. Leaves are labeled with the empty set $\\emptyset$. An important aspect of $\\bm T$ are link labels. A link label is a pair with a vertex of $V$ and a “call type”. The label is of the form $(v,\\mathfrak{p})$ or $(v,\\mathfrak{h})$, where $\\mathfrak{p}$ is shorthand for “pivot” and $\\mathfrak{h}$ for “hold”. For a link label $(v,\\cdot)$ of the link $(S,S’)$ (where $S \\supset S’$ is the parent), $v$ will be an element of $S$. Consider a root to leaf path $T$ of $\\bm T$. We have the following associated set of vertices. It is convenient to think of $T$ as a set of tree links. $H(T)$: This is the set of vertices associated with “hold” call types, among the links of $T$. Formally, $H(T)$ is $\\{v | (v,\\mathfrak{h})$ is label of link in $T \\}$. $P(T)$: This is the set of vertices with “pivot” calls. Formally $P(T)$ is $\\{v | (v,\\mathfrak{p})$ is label of link in $T \\}$. We now describe our algorithm. We stress that the presentation here is different from the implementation. The following presentation is easier for mathematical formalization and proving correctness. The implementation is a recursive version of the same algorithm, which is more space efficient. This is explained in the proof of Theorem 1. BUILDING THE SCT# We give the algorithm to construct the SCT. We keep track of various attributes to appropriately label the edges. The algorithm will construct the SCT $\\bm T$ in a breadth-first manner. Every time a node is processed, the algorithm creates its children and labels all the new nodes and links created. SCTBuilder($G$) Output: SCT of $G$ 1Find degeneracy orientation of $G$, and let $N^+(v)$ denote the outneighborhood of a vertex $v$. 2Initialize tree $\\bm T$ with root labeled $V$. 3For every $v \\in V$, create a child of root with node label $N^+(v)$. Set the edge label to $(v,\\mathfrak{h})$. 4Insert all these child nodes into a queue $\\bm Q$. 5While $\\bm Q$ is non-empty: 6Dequeue to get node $\\gamma$. Let node label be $S$. 7If $S = \\emptyset$, continue. 8Find $p \\in S$ with largest $N(S,p)$ value. 9Create child node of $\\gamma$ with vertex label $N(S,p)$. Add this node to $\\bm T$ and set the link label (of the new link) to $(p,\\mathfrak{p})$. Also, add this node to $\\bm Q$. 10Let $S \\setminus (p \\cup N§) = \\{v_1, v_2, \\ldots, v_\\ell\\}$ (listed in arbitrary order). 11For each $i \\leq \\ell$: create child node of $\\gamma$ labeled 12$N(S,v_i) \\setminus \\{v_1, v_2, \\ldots, v_{i-1}\\}$. Add this node to $\\bm T$ and set link label to $(v_i, \\mathfrak{h})$. 13Also add this node to $\\bm Q$. 14Return $\\bm T$. As mentioned earlier, the child of the node labeled $S$ has one child corresponding to the pivot vertex $p$, and children for all non-neighbors of $p$. Importantly, we label each “call” with $\\mathfrak{p}$ or $\\mathfrak{h}$. This is central to getting unique representations of all the cliques. Now for our main theorem about SCT. THEOREM 2. Every clique $C$ (in $G$) can be *uniquely* represented as $H(T) \\cup Q$, where $Q \\subseteq P(T)$ and $T$ is a root to leaf path in $\\bm T$. (Meaning, for any other root to leaf path $T' \\neq T$, $\\forall Q \\subseteq P(T')$, $C \\neq H(T') \\cup Q$.) We emphasize the significance of this theorem. Every root to leaf path $T$ represents a clique, given by the vertex set $H(T) \\cup P(T)$. Every clique $C$ is a subset of potentially many such sets; and there is no obvious bound on this number. So one can think of $C$ “occurring” multiple times in the tree $\\bm T$. But Theorem 2 asserts that if we take the labels into account ($H(T)$ vs $P(T)$), then there is a unique representation or “single occurrence” of $C$. (of Theorem 2) Consider a node $\\gamma$ of $\\bm T$ labeled $S$. We prove, by induction on $|S|$, that every clique $C \\subseteq S$ can be expressed as $H(T) \\cup Q$, where $T$ is a path from $\\gamma$ to a leaf, and $Q \\subseteq P(T)$. The theorem follows by setting $\\gamma$ to the root. The base case is vacuously tree, since for empty $S$, all relevant sets are empty. Now for the induction. We will have three cases. Let $p$ be the pivot chosen in Step 8. (If $S$ is the root, then there is no pivot. We will directly go to Case (iii) below.) Case (i): $p \\in C$. By construction, there is a link labeled $(p,\\mathfrak{p})$ to a child of $\\gamma$. Denote the child $\\beta$. The child $\\beta$ has label $N(S,p)$. Observe that $C \\setminus p$ is a clique in $N(S,p)$ (since by assumption, $C$ is a clique in $S$.) By induction, there is a unique representation $C\\setminus p = H(T) \\cup Q$, for path $T$ from the child node to a leaf and $Q \\subseteq P(T)$. Moreover there cannot be a representation of $C$ by a path rooted at $\\beta$, since $N(S,p) \\not\\ni p$. Consider the path $T’$ that contains $T$ and starts from $\\gamma$. Note that $H(T’) = H(T)$ and $P(T’) = P(T) \\cup p$. We can express $C = H(T’) \\cup (Q \\cup p)$, noting that $Q \\cup p \\subseteq P(T’)$. This proves the existence of a representation. Moreover, there is only one representation using a path through $\\beta$. We need to argue that no other path can represent $C$. The pivoting is critical for this step. Consider any path rooted at $\\gamma$, but not passing through $\\beta$. It must pass through some other child, with corresponding links labeled $(v_i,\\mathfrak{h})$, where $v_i$ is a non-neighbor of $p$. Since $C \\ni p$, a non-neighbor $v_i$ cannot be in $C$. Moreover, for any path $\\hat{T}$ passing through these other children, $\\hat{T}$ must contain some non-neighbor. Thus, $\\hat{T}$ cannot represent $C$. Case (ii): $C \\subseteq N(S,p)$. The argument is essentially identical to the one above. Note that $C\\setminus p = C$, and by induction $C\\setminus p$ has a unique representation using a path through $\\beta$. For uniqueness, observe that $C$ does not contain a non-neighbor of $p$. The previous argument goes through as is. Case (iii): $C$ contains a non-neighbor of $p$. Recall that $S \\setminus (N§ \\cup p)$ (the set of non-neighbors in $S$) is denoted $\\{v_1, v_2, \\ldots, v_\\ell\\}$. Let $i$ be the smallest index $i$ such that $v_i \\in C$. For any $1 \\leq j \\leq \\ell$, let $N_j := N(S,v_j) \\setminus \\{v_1, v_2, \\ldots, v_{j-1}\\}$. Observe that for all $j$, there is a child labeled $N_j$. Moreover, all the link labels have $\\mathfrak{h}$, so for path $T$ passing through $N_j$, $H(T) \\ni v_j$. Thus, if $T$ can represent $C$, it cannot pass through $N_j$ for $j &lt; i$. Moreover, if $j &gt; i$, then $N_j \\not\\ni v_i$ and no path passing through this node can represent $C$. Hence, if there is a path that can represent $C$, it must pass through $N_i$. Note that $C\\setminus v_i$ is a clique contained in $N_i$. By induction, there is a unique path $T$ rooted at $N_i$ such that $C \\setminus v_i = H(T) \\cup Q$, for $Q \\subseteq P(T)$. Let $T’$ be the path that extends $T$ to $\\gamma$. Note that $H(T’) = H(T) \\cup v_i$, so $C = H(T’) \\cup Q$. The uniqueness of $T$ implies the uniquesness of $T’$. GETTING GLOBAL AND LOCAL COUNTS# The tree $\\bm T$ is succinct and yet one can extract fine-grained information from it about all cliques. PIVOTER($G$) Output: Clique counts of $G$ 1Let $\\bm T = SCTBuilder(G)$. 2Initialize all clique counts to zero. 3For every root to leaf path $T$ in $\\bm T$: 4For every $0 \\leq i \\leq |P(T)|$, increment $C_{|H(T)|+i}$ by ${P(T) \\choose i}$. 5For every $v \\in H(T)$ and every $0 \\leq i \\leq |P(T)|$, increment $c_{|H(T)|+i}(v)$ by ${P(T) \\choose i}$. 6For every $v \\in P(T)$ and every $0 \\leq i \\leq |P(T)|-1$, increment $c_{|H(T)|+i+1}(v)$ by ${ {P(T)-1} \\choose i}$. 7For every edge $e(u,v), u \\in H(T), v \\in H(T), u \\neq v$ and every $0 \\leq i \\leq |P(T)|$, increment $c_{|H(T)|+i}(e)$ by ${ {P(T)} \\choose i}$. 8For every edge $e(u,v), u \\in P(T), v \\in H(T)$ and every $0 \\leq i \\leq |P(T)|-1$, increment $c_{|H(T)|+i+1}(e)$ by ${ {P(T)-1} \\choose i}$. 9For every edge $e(u,v), u \\in P(T), v \\in P(T), u \\neq v$ and every $0 \\leq i \\leq |P(T)|-2$, increment $c_{|H(T)|+i+2}(e)$ by ${ {P(T)-2} \\choose i}$. 10Output the sets of values $\\{C_k\\}$, $\\{c_k(v)\\}$ and $\\{c_k(e)\\}$. The storage complexity of the algorithm, as given, is potentially $O(\\alpha^2 |SCT(G)|)$, since this is required to store the tree. In the proof of Theorem 1, we explain how to reduce the storage. (of Theorem 1) Correctness: By Theorem 2, a root to leaf path $T$ of $\\bm T$ represents exactly $2^{P(T)}$ different cliques, with ${P(T) \\choose i}$ of size $|H(T)| + i$. Moreover, over all $T$, this accounts for all cliques in the graph. This proves the correctness of global counts. Pick a vertex $v \\in H(T)$. For every subset of $P(T)$, we get a different clique containing $v$ (that is uniquely represented by Theorem 2). This proves the correctness of Step 5. For a vertex $v \\in P(T)$, we look at all subsets containing $v$. Equivalently, we get a different represented clique containing $v$ for every subset of $P(T)\\setminus v$. This proves the correctness of Step 6. Pick an edge $e=(u,v), u \\in H(T), v \\in H(T)$. For every subset of $P(T)$, we get a different clique containing $e$ (that is uniquely represented by Theorem 2). This proves the correctness of Step 7. For an edge $e=(u,v), u \\in P(T), v \\in H(T)$, we look at all subsets of $P(T)$ containing $u$. Equivalently, we get a different represented clique containing $e$ for every subset of $P(T)\\setminus u$. This proves the correctness of Step 8. For an edge $e=(u,v), u \\in P(T), v \\in P(T)$, we look at all subsets of $P(T)$ containing both $u$ and $v$. Equivalently, we get a different represented clique containing $e$ for every subset of $P(T)\\setminus v \\setminus u$. This proves the correctness of Step 9. Running time (in terms of $|SCT(G)|$): Consider the procedure $SCTBuilder(G)$. Note that the size of $\\bm T$ is at least $n$, so we can replace any running time dependence on $n$ by $|T|$. The degeneracy orientation can be found in $O(m+n)$[20]. For the actual building of the tree, the main cost is in determining the pivot and constructing the children of a node. Suppose a non-root node labeled $S$ is processed. The above mentioned steps can be done by constructing the subgraph induced on $S$. This can be done in $O(|S|^2)$ time. Since this is not a root node, $|S| \\leq \\alpha$ (this is the main utility of the degeneracy ordering). Thus, the running time of $SCTBuilder(G) = O(\\alpha^2|\\bm T|) = O(\\alpha^2 |SCT(G)|)$. Now we look at PIVOTER. Note that the subsequent counting steps do not need the node labels in $\\bm T$; for all path $T$, one only needs $P(T)$ and $H(T)$. The paths can be looped over by a DFS from the root. For each path, there are precisely $|P(T)|+1$ updates to global clique counts, and at most $|H(T) \\cup P(T)| \\times (|P(T)|+1)$ updates to per-vertex clique counts. The length of $T$ is at most $\\alpha$, and thus both these quantities are $O(\\alpha^2)$. Thus, the total running time is $O(\\alpha^2 |SCT(G)|)$ for global and per-vertex clique counting. Similarly, for each path, at most $|H(T) \\cup P(T)|^2 \\times (|P(T)|+1)$ updates are made to per-edge clique counts. This quantity is $O(\\alpha^3)$. Thus, the total running time is $O(\\alpha^3 |SCT(G)|)$. Running time (in terms of $n$ and $\\alpha$): One crucial difference between the algorithm of Bron-Kerbosch and $SCTBUILDER$ is that in Bron-Kerbosch, the pivot vertex can be chosen not only from $S$ but also from a set of already processed vertices. Hence, the tree obtained in Bron-Kerbosch can potentially be smaller than that of PIVOTER. Despite this difference, the recurrence and bound on the worst case running time of $SCTBUILDER$ is the same as Bron-Kerbosch. THEOREM 3. Worst case running time of $SCTBUILDER$ is $O(n3^{\\alpha/3})$. Let $T(s)$ be the worst case running time required by $SCTBUILDER$ to process $S$ where $s=|S|$. Let $R=S \\setminus N§$. Let $T_r(s)$ be the worst case running time of processing $S$ when $|R|=r$. Note that when $S$ is being processed it creates a total of $r$ child nodes. Thus, $T(s)=\\max\\limits_r\\{T_r(s)\\}$. Note that all steps other than Step 9 and Step 13 take time $O(s^2)$. Say, they take time $p_1s^2$, where $p_1&gt;0$ is a constant. Thus, we have that: $$ T_r(s) \\leq \\sum\\limits_{v \\in R}{T(|N(S,v)|) + p_1s^2}. $$ Moreover, $$ |N(S,v)| \\leq s-r \\leq s-1,\\forall v \\in R. $$ This is because $p$ has the largest neighborhood in $S$ and $p$'s neighborhood is of size atmost $s-r$, and since $|S|\\geq 1, s-r \\leq s-1$. Thus, Lemma 2 and Theorem 3 from [29] hold, which implies that $T(s)=O(3^{s/3})$. Since there are $n$ vertices and their outdegree is atmost $\\alpha$, the worst case running time of $SCTBUILDER$ (which is also an upper bound for $|sct(G)|$) is $nT(\\alpha)=O(n3^{\\alpha/3})$ and hence, worst case running times of PIVOTER for obtaining global, per-vertex and per-edge clique counts are $O(n\\alpha 3^{\\alpha/3})$, $O(n\\alpha^2 3^{\\alpha/3})$ and $O(n\\alpha^3 3^{\\alpha/3})$, respectively. Storage cost: Currently, PIVOTER is represented through two parts: the construction of $SCT(G)$ and then processing it to get clique counts. Conceptually, this is cleaner to think about and it makes the proof transparent. On the other hand, it requires storing $SCT(G)$, which is potentially larger than the input graph. A more space efficient implementation is obtained by combining these steps. We do not give full pseudocode, since it is somewhat of a distraction. (The details can be found in the code.) Essentially, instead of constructing $SCT(G)$ completely in breadth-first manner, we construct it depth-first through recursion. This will loop over all the paths of $\\bm T$, but only store a single path at any stage. The updates to the clique counts are done as soon as any root to leaf path is constructed. The total storage of a path is the storage for all the labels on a path. As mentioned earlier in the proof of Theorem 1, all non-root nodes are labeled with sets of size at most $\\alpha$. The length of the path is at most $\\alpha$, so the total storage is $O(\\alpha^2)$. A classic bound on the degeneracy is $\\alpha \\leq \\sqrt{2m}$ (Lemma 1 of[10]), so the storage, including the input, is $O(m+n)$. Parallel version of PIVOTER: While this is not central to our results, we can easily implement a parallel version of PIVOTER for global clique counts. We stress that our aim was not to delve into complicated parallel algorithms, and merely to see if there was a way to parallelize the counting involving minimal code changes. The idea is simple, and is an easier variant of the parallelism in kCList[11]. Observe that the children of the root of $SCT(G)$ correspond to finding cliques in the sets $N^+(v)$, for all $v$. Clique counting in each of these sets can be treated as an independent problem, and can be handled by an independent thread/subprocess. Each subprocess maintains its own array of global clique counts. The final result aggregates all the clique counts. The change ends up being a few lines of code to the original implementation. Note that this becomes tricky for local counts. Each subprocess cannot afford (storage-wise) to store an entire copy of the local count data structure. The aggregation step would be more challenging. Nonetheless, it should be feasible for each subprocess to create local counts for $N^+(v)$, and appropriately aggregate all counts. We leave this for future work. Counting $k$-cliques for a specific $k$: PIVOTER can be modified to obtain clique counts upto a certain user specified $k$ (instead of counting for all $k$). Whenever the number of links marked $\\mathfrak{h}$ becomes greater than $k$ in any branch of the computation, we simply truncate the branch (as further calls in the branch will only yield cliques of larger sizes). EXPERIMENTAL RESULTS# Preliminaries: All code for PIVOTER is available here: https://bitbucket.org/sjain12/pivoter/. We implemented our algorithms in C and ran our experiments on a commodity machine equipped with a 1.4GHz AMD Opteron™ processor 6272 with 8 cores and 2048KB L2 cache (per core), 6144KB L3 cache, and 128GB memory. We performed our experiments on a collection of social networks, web networks, and infrastructure networks from SNAP [49]. The graphs are simple and undirected (for graphs that are directed, we ignore the direction). A number of these graphs have more than 10 million edges, and the largest has more than 100 million edges. Basic properties of these graphs are presented in Tab 1. The data sets are split into two parts, in Tab 1. The upper part are instances feasibly solved with past work (notably kClist40[11]), while the lower part has instances that cannot be solved with previous algorithm (even after days). We give more details in §time. Competing algorithms: We compare with (what we consider) are the state of the art clique counting algorithms: Tur’{a}n-Shadow (TS)[18] and kClist40[11]. kClist40: This algorithm by Danisch-Balalau-Sozio[11] uses degeneracy orientations and parallelization to enumerate all cliques. The kClist40 algorithm, to the best of our knowledge, is the only existing algorithm that can feasibly compute all global counts for some graphs. Hence, our main focus is runtime comparisons with kClist40. We note that the implementation of kClist40 visits every clique, but only updates the (appropriate) $C_k$. While it could technically compute local counts, that would require more expensive data structure updates. Furthermore, there would be overhead in combining the counts for independent threads, and it is not immediately obvious how to distribute the underlying data structure storing local counts. As a result, we are unaware of any algorithm that computes local counts (at the scale of dataset in Tab 1). We perform a simple optimization of kClist40, to make counting faster. Currently, when kClist40 encounters a clique, it enumerates every smaller clique contained inside it. For the purpose of counting though, one can trivially count all subcliques of a clique using formulas. We perform this optimization (to have a fair comparison with kClist40), and note significant improvements in running time. In all our runs, for consistency, we run kClist with 40 threads. Note that we compare the sequential PIVOTER with the parallel kClist40. TS: This is an approximate clique counting algorithm for $k$ upto $10$ [18]. It mines dense subgraphs (shadows) and samples cliques within the dense subgraphs to give an estimate. For fast randomized estimates, it is arguably the fastest algorithm. It runs significantly faster than a sequential implementation of kClist, but is typically comparable with a parallel implementation of kClist. It requires the entire shadow to be available for sampling which can require considerable space. Running time and comparison with other algorithms# Running time for global counting: We show the running time results in Tab 1. For most of the graphs, PIVOTER was able to count all $k$-cliques in seconds or minutes. For the largest com-orkut graph, PIVOTER ran in 1.5 hours. This is a huge improvement on the state of the art. For the “infeasible” instances in Tab 1, we do not get results even in two days using previous algorithms. (This is consistent with results in Table 2 of[11], where some of the graphs are also listed as “very large graphs” for which clique counting is hard.) A notable hard instance is com-lj where PIVOTER is unable to get all clique counts in a day. Again, previous work also notes this challenge, and only gives counts of $7$-cliques. We can get some partial results for com-lj, as explained later. GraphVerticesEdgesDegenMax cliquePIVOTER ($C_k$)PIVOTER ($c_k(v)$)PIVOTER ($c_k(e)$)PIVOTER($C_k$) parallelFeasible by previous algorithmsdblp-v51.56E+062.08E+06151077819dblp-v73.67E+064.18E+06191215161934amazon06014.03E+052.44E+0610114564web-Google8.76E+054.32E+06444489159youtube1.13E+062.99E+06511778119cit-Patents3.77E+061.65E+07641140415346soc-pokec1.63E+062.23E+07472968759344Not feasible for previous algorithmsStanford2.82E+051.99E+06716155383BerkStan6.85E+056.65E+0620120125262379as-skitter1.70E+061.11E+0711167120200924575com-orkut3.07E+061.17E+082535151748802993893441Table shows the sizes, degeneracy, maximum clique size, and the time taken (in seconds) by PIVOTER to obtain global $k-$clique counts, per-vertex and per edge $k-$cliques counts for all k. *For the com-lj graph, we were not able to get all $k-$clique counts in 1 day so we tested for the maximum $k$ we could count in about a day. PIVOTER was able to count the number of 9-cliques in 30 hours whereas kClist40 had not terminated even after 6 days. Graphk=13,TSk=13, kClist40all k, PivoterStanford230126005BerkStan1198&gt; 17280025as-skitter79812480120com-orkut&gt; 28800&gt; 1728005174Time taken in seconds by the state-of-the-art randomized (TS, short for TuránShadow) and parallel (kClist40) algorithms. Note that PIVOTER obtains all $k-$clique counts for these graphs in a fraction of the time taken by other methods to count just 13-cliques. k$k$-cliqueskClist40PIVOTER74.49E+152.2 hours1.2 hours81.69E+1642.5 hours6.4 hours95.87E+17&gt; 6 days30 hours101.89E+19&gt; 6 days5.9 daysTable shows the time taken to count $k$-cliques for com-lj graph. For $k$=9, PIVOTER terminated in about 30 hours where kClist40 had not terminated in 6 days. Figure 4 shows the number of nodes in the SCT vs the number of edges (m) for different graphs. The running time of PIVOTER is directly proportional to the SCT size which seems to be roughly linear in the number of edges. Figure 5 shows the trends in clique counts for a number of graphs. For some of the graphs, the complete distribution of their clique counts has been obtained for the first time. Figure 6 shows the trends in the clique counts of 2 different versions over time of the dblp graph. Feasible local counting: Notably, PIVOTER can get per-vertex counts in less than twice the time of global clique counting. Thus, we get results for more graphs in a few minutes, and can process the com-orkut graph within 3 hours. We consider this a significant achievement, given the combinatorial explosion of clique counting. PIVOTER is also able to get per-edge clique counts, though it can take an order of magnitude more time than global clique counting. Note that for obtaining the per-vertex and per-edge $k-$clique counts, the result data structure can become extremely large. Indeed, most of the time is spent in updating the data structure, rather than in constructing the SCT. Nonetheless, for all but the as-skitter and com-orkut graph, it runs in minutes. Comparison with state of the art: We only focus on the “infeasible” instances of Tab 1. For all the other instances, both PIVOTER and kClist40 get results within two minutes. For space considerations, we do not report all the running times for such instances. It is worth noting that the sequential PIVOTER is comparable to the parallel kClist40 (when they both terminate). In Tab 2, we report times on TS and kClist40 on the hard datasets. We are unable to get all values of $C_k$ using either of these two method. We run these algorithms for up to 100 times the running time of PIVOTER or two days, whichever is shorter. We try to count the largest feasible clique count. Let us focus on kClist40, where we cannot go beyond counting 13-cliques (we note that this is consistent with results reported in[11]). Notably, in the BerkStan graph, kClist40 needs more than 2 days to count 13-cliques, while PIVOTER gets all clique counts in a minute. As mentioned earlier, clique counting on the large com-orkut graph is done in a few hours by PIVOTER, while even counting 13-cliques takes kClist40 more than two days. TS also does not scale well for larger cliques and PIVOTER is faster than TS. For example, for the Stanford graph, TS required 230 seconds to estimate the number of 13-cliques whereas PIVOTER obtained all $k-$clique counts in 5 seconds. Similar trends are observed with other graphs. Parallel global clique counting: As mentioned in §count, we do a simple parallelization of the global clique counting of PIVOTER using 30 threads. It gives moderate benefits for most instances, and about a factor two speedup for large instances. For the challenging com-lj instances, the effect is much more dramatic. We are able to count $7$-cliques in an hour using the parallel PIVOTER, while the sequential version takes more than a day. Performance on com-lj. This is a particularly challenging graph. The sequential version of PIVOTER for counting all $k$-cliques did not terminate within a day, so we used the parallel version of our algorithm to show a comparison for global counts upto $k=10$. We can truncate the SCT to get cliques of some fixed size. Tab 3 shows the results. Even for this graph, the parallel version of PIVOTER is faster than kClist40 for $k=7$ and beyond. kClist40 did not terminate after six days, for $k = 9$ and beyond. We note the astronomical number of 10-cliques ($&gt; 10^{19}$), which makes enumeration infeasible, but PIVOTER was able to get the exact count. Size of $SCT(G)$: In Figure 4, we plot the number of nodes of $SCT(G)$ as a function of the number of edges in $G$. We observe that for most graphs, the size is quite close to $m$, explaining why PIVOTER is efficient. Demonstrations of PIVOTER# Global and local cliques have numerous applications. It is outside the scope of this work for detailed demonstrations, but we show a few examples in this section. As mentioned earlier, local clique counts are an important aspect of graph processing. In Figure 2 and Figure 3, we plot the per-vertex clique distributions, also called the graphlet degree distribution in bioinformatics[22] for the as-skitter and web-Stanford graphs. We choose values of $k = 5, 10, 15, 20, 25$. Then, we plot the function $f_k(b)$ that is the number of vertices that participate in $b$ $k$-cliques. We notice interesting trends. While the as-skitter graph has a nicely decaying $f_k$ function, there is much more noise in web-Stanford. It would be interesting to design models that can capture such behavior in the local clique counts. In Figure 5, we plot the $C_k$ values for a number of graphs. We notice, for example, that the soc-pokec network has a “flatter” distribution of $C_k$ for some of the initial values, while the com-orkut graph looks much closer to a binomial distribution. The latter suggests that the bulk of cliques are coming from the maximum clique in the com-orkut graph, but not so in the soc-pokec graph. In Figure 6, we plot the $k$-clique counts (vs $k$) for two different versions across time for the DBLP citation network[4]. Interestingly, despite the later version only having less than twice as many edges, the clique distribution (plotted in semilog) has a much bigger difference. It appears that the graph is becoming significantly dense in certain part. This sort of analysis may help in understanding dynamic graphs. FUTURE WORK# We provide an exact clique counting algorithm that counts all $k$-cliques in a fraction of the time of other state-of-the-art parallel algorithms. One of the key ideas is the use of pivoting to create the SCT, and succinct representation of all the cliques of the graph. The success of[11] in using parallelization for clique counting suggests combining their ideas with our pivoting techniques. We may be able to come up with an efficient parallel building of the SCT that is much faster than our current implementation. Indeed, the results on the com-lj graph suggest that even PIVOTER has its limits for real data. An orthogonal approach would be to exploit the sampling techniques in the Turán-Shadow algorithm[18]. For many subgraph counting problems, randomization has been the key to truly practical algorithms. We believe that PIVOTER could be made faster with these ideas. Moreover, it also gives per-edge and per-vertex $k-$clique counts. This is the first time that $k-$clique counts are known for many of the graphs we experimented with and this will open doors for further use of cliques in generation and analysis of graphs. ACKNOWLEDGMENTS# Shweta Jain and C. Seshadhri acknowledge the support of NSF Awards CCF-1740850, CCF-1813165, and ARO Award W911NF1910294. REFERENCES# [1]E. A. Akkoyunlu. 1973. The enumeration of maximal cliques of large graphs. SIAM J. Comput. 2 (2016.10.21), (1-6)[2]Nesreen K. Ahmed and Jennifer Neville and Ryan A. Rossi and Nick Duffield. 2015. Efficient Graphlet Counting for Large Networks. (2016.02.10), [3]Alon, Noga and Yuster, Raphy and Zwick, Uri. 1994. Color-coding: A New Method for Finding Simple Paths, Cycles and Other Small Subgraphs Within Large Graphs. (326--335)[4]\"Jie Tang and Jing Zhang and Limin Yao and Juanzi Li and Li Zhang and Zhong Su\". 2008. \"ArnetMiner: Extraction and Mining of Academic Social Networks\". (\"990-998\")[5]Bron, Coen and Kerbosch, Joep. 1973. Algorithm 457: Finding All Cliques of an Undirected Graph. Commun. ACM 16 (575--577)[6]A. Benson and D. F. Gleich and J. Leskovec. 2016. Higher-order organization of complex networks. Science 353 (163-166)[7]Berry, Jonathan W. and Hendrickson, Bruce and LaViolette, Randall A. and Phillips, Cynthia A.. 2011. Tolerating the community detection resolution limit with edge weighting. Phys. Rev. E 83 (056119)[8]Nadja Betzler and Ren&eacute; van Bevern and Michael R. Fellows and Christian Komusiewicz and Rolf Niedermeier. 2011. Parameterized Algorithmics for Finding Connected Motifs in Biological Networks. IEEE/ACM Trans. Comput. Biology Bioinform. 8 (1296-1308)[9]Jianer Chen and Xiuzhen Huang and Iyad A. Kanj and Ge Xia. 2004. Linear {FPT} reductions and computational lower bounds. (Wed, 15 Feb 2006 09:55:49 +0100), (212--221)[10]Chiba, Norishige and Nishizeki, Takao. 1985. Arboricity and subgraph listing algorithms. SIAM J. Comput. 14 (210--223)[11]Maximilien Danisch and Oana Denisa Balalau and Mauro Sozio. 2018. Listing k-cliques in Sparse Real-World Graphs. (Wed, 21 Nov 2018 12:44:11 +0100), (589--598)[12]David Eppstein and Maarten L&ouml;ffler and Darren Strash. 2013. Listing All Maximal Cliques in Large Sparse Real-World Graphs. {ACM} Journal of Experimental Algorithmics 18 (Wed, 08 Apr 2015 14:32:05 +0200), [13]Eppstein, David and L&ouml;ffler, Maarten and Strash, Darren. 2010. Listing all maximal cliques in sparse graphs in near-optimal time. (403--414)[14]Pinar, Ali and Seshadhri, C and Vishal, Vaidyanathan. 2017. Escape: Efficiently counting all 5-vertex subgraphs. (1431--1440)[15]Irene Finocchi and Marco Finocchi and Emanuele G. Fusco. 2015. Clique Counting in MapReduce: Algorithms and Experiments. {ACM} Journal of Experimental Algorithmics 20 (Mon, 08 Feb 2016 17:41:45 +0100), [16]Robert A. Hanneman and Mark Riddle. 2005. Introduction to social network methods. (2016.10.21), [17]Matthew O. Jackson. 2010. Social and Economic Networks. (2016.10.21), [18]Jain, Shweta and Seshadhri, C. 2017. A Fast and Provable Method for Estimating Clique Counts Using Tur&aacute;n's Theorem. (441--449)[19]M. Jha and C. Seshadhri and A. Pinar. 2015. Path Sampling: A Fast and Provable Method for Estimating 4-Vertex Subgraph Counts. (2015.02.19), (495-505)[20]Matula, David W and Beck, Leland L. 1983. Smallest-last ordering and clustering and graph coloring algorithms. Journal of the ACM (JACM) 30 (417--427)[21]Dror Marcus and Yuval Shavitt. 2010. Efficient Counting of Network Motifs. (92-98)[22]Natasa Przulj. 2007. Biological network comparison using graphlet degree distribution. Bioinformatics 23 (177?-183)[23]Rahmtin Rotabi and Krishna Kamath and Jon M. Kleinberg and Aneesh Sharma. 2017. Detecting Strong Ties Using Network Motifs. (Tue, 06 Nov 2018 16:57:06 +0100), (983--992)[24]Ann Sizemore and Chad Giusti and Danielle S. Bassett. 2016. Classification of weighted networks through mesoscale homological features. Journal of Complex Networks 10.1093 (2016.10.21), [25]Ahmet Erdem Sariy&uuml;ce and C. Seshadhri and Ali Pinar and &Uuml;mit V. &Ccedil;ataly&uuml;rek. 2015. Finding the Hierarchy of Dense Subgraphs using Nucleus Decompositions. (927--937)[26]C. Seshadhri and Ali Pinar and Tamara G. Kolda. 2014. Wedge sampling for computing clustering coefficients and triangle counts on large graphs. Statistical Analysis and Data Mining 7 (Sat, 20 May 2017 00:26:36 +0200), (294--307)[27]C. Seshadhri and Srikanta Tirthapura. 2019. Scalable Subgraph Counting: The Methods Behind The Madness: {WWW} 2019 Tutorial. [28]Charalampos E. Tsourakakis and Jakub Pachocki and Michael Mitzenmacher. 2017. Scalable Motif-aware Graph Clustering. (Tue, 06 Nov 2018 16:57:07 +0100), (1451--1460)[29]Tomita, Etsuji and Tanaka, Akira and Takahashi, Haruhisa. 2006. The Worst-Case Time Complexity for Generating All Maximal Cliques. Theoretical Computer Science 363 (28--42)[30]Charalampos E. Tsourakakis. 2015. The K-clique Densest Subgraph Problem. (Mon, 25 May 2015 17:32:51 +0200), (1122--1132)[31]Johan Ugander and Lars Backstrom and Jon M. Kleinberg. 2013. Subgraph frequencies: mapping the empirical and extremal geography of large graph collections. (1307-1318)[32]Virginia Vassilevska. 2009. Efficient algorithms for clique problems. Information Processing Letters 109 (254 - 257)[33]Pinghui Wang and Junzhou Zhao and Xiangliang Zhang and Zhenguo Li and Jiefeng Cheng and John C. S. Lui and Don Towsley and Jing Tao and Xiaohong Guan. 2018. {MOSS-5:} {A} Fast Method of Approximating Counts of 5-Node Graphlets in Large Graphs. tkde 30 (Wed, 10 Jan 2018 15:12:39 +0100), (73--86)[34]Hao Yin and Austin R. Benson and Jure Leskovec. 2018. Higher-order clustering in networks. Phys. Rev. E 97 (Fri, 01 Feb 2019 08:07:59 +0100), (052306)[35]Hao Yin and Austin R. Benson and Jure Leskovec. 2019. The Local Closure Coefficient: {A} New Perspective On Network Clustering. (Fri, 01 Feb 2019 08:07:59 +0100), (303--311)[36]Z. Zhao and G. Wang and A. Butt and M. Khan and V. S. Anil Kumar and M. Marathe. 2012. SAHAD: Subgraph Analysis in Massive Networks Using Hadoop. (2014.06.10), (390-401)[37]Lu, Zhenqi and Wahlstr&ouml;m, Johan and Nehorai, Arye. 2018. Community detection in complex networks via clique conductance. Scientific reports 8 (5982)","link":"/en/clique-counting"}],"posts":[{"title":"2018年SCUT软件学院ACM新生杯","text":"难度非常友好！！ 就是我打炸了。奖品只有气球。。。 A# 人类的本质 123456789101112131415#include &lt;cstdio&gt;int main(){ int t; scanf(&quot;%d&quot;,&amp;t); for(int T=1;T&lt;=t;T++){ int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ printf(&quot;\\&quot;LJJnb!!!!!!!\\'\\'\\n&quot;); } if(T!=t)printf(&quot;\\n&quot;); } return 0;} B# CYC的公倍数 注意到$1 \\le d_{min} \\le 1000$，枚举$d_{min}$即可。 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;const int N=1005;int a[N];int main(){ int T; cin&gt;&gt;T; for(int t=1;t&lt;=T;t++){ int n,k; cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i]; } int d; for(d=1;d&lt;=1000;d++){ int count=0; for(int i=1;i&lt;=n;i++){ if(d%a[i]==0)count++; if(count&gt;=k)break; } if(count&gt;=k)break; } cout&lt;&lt;d&lt;&lt;'\\n'; } return 0;} C# CYC的计算几何 容易推出$S=|EF| \\times |AE|$ 12345678910111213#include &lt;iostream&gt;using namespace std;int main(){ int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ int a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;(a*b)%10017&lt;&lt;'\\n'; } return 0;} D# 时空裂隙(参考题目pdf） 这题有些不严谨，而且OJ题库里也没找到这题。就姑且自己分析一波吧。 比赛时，我以为第k大的数要去除重复的，后来才发现不用，这个可能是我理解有问题。 但，官方题解给的是暴力！！而范围内明显暴力可能会超时！ 此题给出的程序不一定正确 官方题解# 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int Maxn=10010;int n,k;int num[Maxn];int main(){ freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;n); for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;num[i]); sort(num+1,num+n+1); for (int k=1;k&lt;=(n+1)/2;k++) { int a=num[k],b=num[n-k+1]; int number=b-a; bool bj=true; for (int i=2;i&lt;=sqrt(number);i++) { if (number%i==0) { bj=false; break; } } if (bj) {printf(&quot;%d\\n&quot;,k);return 0;} } printf(&quot;GG\\n&quot;); return 0;} hack数据生成程序# 2147483353是范围内需要判定次数最多的合数。利用这一点可以让上面程序超时。 数据类似这样： 10 1 1 1 1 1 2147483354 2147483382 2147483382 2147483382 2147483382 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;using namespace std;//const int N=10;int N;int Min=1;int Max=(1&lt;&lt;31)-1;int i,j,k;int main(){ freopen(&quot;input.txt&quot;,&quot;w&quot;,stdout); //printf(&quot;%d\\n&quot;,Max);return 0; //scanf(&quot;%d&quot;,&amp;N); N=10000; printf(&quot;%d\\n&quot;,N); int M=N&gt;&gt;1; for(i=1;i&lt;=M-1;i++){ printf(&quot;%d &quot;,Min); } //int maxi,maxn=0; /* for(i=2147483381;i&gt;2147483381-10000;i--){ int j=int(sqrt(i)); int flag=1; for(k=2;k&lt;=j;k++){ if(i%k==0){ //printf(&quot;\\ni=%d\\nk=%d\\n&quot;,i,k); if(k&gt;maxn){ maxn=k; maxi=i; } flag=0; break; } } if(flag){ printf(&quot;get one:%d\\n&quot;,i); break; } }*/ //printf(&quot;\\nmaxi=%d\\nmaxn=%d\\n&quot;,maxi,maxn); //maxi=2147483381 //maxn=46271 //2147483381=46271*46411 //18 2147483647 //2147483647-18=2147483629 //get one:2147483353 printf(&quot;%d %d &quot;,1,2147483354); Max=2147483381+1; for(i=1;i&lt;=M-1;i++){ printf(&quot;%d&quot;,Max); if(i==M-1)printf(&quot;\\n&quot;); else printf(&quot; &quot;); } return 0;} Miller-Rabin随机性素数测试# 貌似只有这种方法了，经测试是不会超时的，这个就先当模版。。 原理以后再学。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;using namespace std;const int N=10005;int A[N];typedef long long LL;LL muti_mod(LL a,LL b,LL c){ //return (a*b) mod c,a,b,c&lt;2^63 a%=c; b%=c; LL ret=0; while(b){ if(b&amp;1){ ret+=a; if(ret&gt;=c)ret-=c; } a&lt;&lt;=1; if(a&gt;=c)a-=c; b&gt;&gt;=1; } return ret;}LL pow_mod(LL x,LL n,LL mod){ //return x^n mod c if(n==1) return x%mod; int bit[90],k=0; while(n){ bit[k++]=n&amp;1; n&gt;&gt;=1; } LL ret=1; for(k=k-1;k&gt;=0;k--){ ret=muti_mod(ret,ret,mod); if(bit[k]==1) ret=muti_mod(ret,x,mod); } return ret;}bool check(LL a,LL n,LL x,LL t){ LL ret=pow_mod(a,x,n),last=ret; for(int i=1; i&lt;=t; i++){ ret=muti_mod(ret,ret,n); if(ret==1&amp;&amp;last!=1 &amp;&amp; last!=n-1) return 1; last=ret; } if(ret!=1) return 1; return 0;}bool miller(LL n,int S=50){ if(n&lt;=1)return 0; LL x=n-1,t=0; while ((x&amp;1)==0) x&gt;&gt;=1,t++; bool flag=1; if (t&gt;=1 &amp;&amp; (x&amp;1)==1){ for (int k=0; k&lt;S; k++){ LL a=rand()%(n-1)+1; if (check(a,n,x,t)){ flag=1; break; } flag=0; } } if (!flag || n==2) return 1; return 0;}int check(int x){ if(x&lt;=1)return 0; if(x==2||x==3)return 1; for(int i=2;i&lt;=int(sqrt(1.0*x)+1);i++){ if(x%i==0)return 0; } return 1;}int main(){ freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); srand((unsigned)time(NULL)); int n; scanf(&quot;%d&quot;,&amp;n); /*for(int i=0;i&lt;n;i++){ //printf(&quot;check(%d)=%d\\n&quot;,i,check(i)); //printf(&quot;miller(%d)=%d\\n&quot;,i,miller(i)); if(check(i)!=miller(i))printf(&quot;%d\\n&quot;,i); } return 0;*/ for(int i=0;i&lt;n;i++){ scanf(&quot;%d&quot;,&amp;A[i]); } sort(A,A+n); //for(int i=0;i&lt;n;i++)printf(&quot;A[%d]=%d\\n&quot;,i,A[i]); //return 0; int flag=0; int tn=(n&gt;&gt;1)+1; for(int k=1;k&lt;=tn;k++){ if(miller(A[n-k]-A[k-1])){ //if(check(a[n-k]-a[k-1])){ flag=k; break; } } if(flag){ printf(&quot;%d\\n&quot;,flag); }else{ printf(&quot;GG\\n&quot;); } return 0;} E# yang12138的快乐炉石 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;int main(){ int T; cin&gt;&gt;T; for(int t=1;t&lt;=T;t++){ int n; cin&gt;&gt;n; int count=0; while(n!=1){ if(n&amp;1){ n=(n-1)&gt;&gt;1; }else{ n=n&gt;&gt;1; } count++; } cout&lt;&lt;count&lt;&lt;'\\n'; } return 0;} F# yang1238的激烈炉石 注意到$\\sqrt{1}=1$即可。 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;const int N=100005;int a[N][9];int main(){ int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i][0]; for(int j=1;j&lt;9;j++){ a[i][j]=int(sqrt(1.0*a[i][j-1])); } } for(int j=1;j&lt;=m;j++){ if(j&gt;=9)cout&lt;&lt;n&lt;&lt;'\\n'; else{ int sum=0; for(int i=1;i&lt;=n;i++){ sum=sum+a[i][j-1]; } cout&lt;&lt;sum&lt;&lt;'\\n'; } } return 0;} G# yang12138的妹子 容易推出 $$ ans=\\sum_{i=m}^nC_n^i $$ 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;int com(int n,int r){ if(n-r&gt;r)r=n-r; int i,j,s=1; for(i=0,j=1;i&lt;r;i++){ s*=(n-i); for(;j&lt;=r&amp;&amp;s%j==0;j++)s/=j; } return s;}int main(){ int T; cin&gt;&gt;T; for(int t=1;t&lt;=T;t++){ int n,m; cin&gt;&gt;n&gt;&gt;m; int ans=1; for(int i=m;i&lt;n;i++){ ans=ans+com(n,i); } cout&lt;&lt;ans&lt;&lt;'\\n'; } return 0;} H# yang12138的随机炉石 简单的dp。 12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int N=105;int a[N],b[N];double f[N][N];int main(){ for(int i=0;i&lt;N;i++){ for(int j=0;j&lt;N;j++){ if(i==0)f[i][j]=0; else if(j==0)f[i][j]=1.0; else f[i][j]=0.5*f[i-1][j]+0.5*f[i][j-1]; } } int T; cin&gt;&gt;T; for(int t=1;t&lt;=T;t++){ int hp1,hp2,n,m; cin&gt;&gt;hp1&gt;&gt;hp2&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i]; } for(int j=1;j&lt;=m;j++){ cin&gt;&gt;b[j]; } if(hp1%10==0)hp1--; if(hp2%10==0)hp2--; hp1=hp1/10+1; hp2=hp2/10+1; printf(&quot;%.5lf\\n&quot;,f[hp1][hp2]); } return 0;} I# HOOCCOOH的大模拟 真是大模拟，按题意处理即可。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int N=200005;char base[]=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;int rebase[305];char s[N];int change(char *p){ char a=rebase[int(*(p))],b=rebase[int(*(p+1))],c,d; if(*(p+2)=='=')c=0; else c=rebase[int(*(p+2))]; if(*(p+3)=='=')d=0; else d=rebase[int(*(p+3))]; int ta=(a&lt;&lt;2)+(b&gt;&gt;4),tb=((b&amp;15)&lt;&lt;4)+(c&gt;&gt;2),tc=((c&amp;3)&lt;&lt;6)+(d); //printf(&quot;\\nta=%d\\ntb=%d\\ntc=%d\\n&quot;,ta,tb,tc); if(ta&gt;=32&amp;&amp;ta&lt;=126)printf(&quot;%c&quot;,ta); if(tb&gt;=32&amp;&amp;tb&lt;=126)printf(&quot;%c&quot;,tb); if(tc&gt;=32&amp;&amp;tc&lt;=126)printf(&quot;%c&quot;,tc);}int main(){ //freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); //freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); for(int i=0;i&lt;64;i++){ rebase[base[i]]=i; } while(~scanf(&quot;%s&quot;,s)){ int len=strlen(s); /*for(int i=0;i&lt;len;i++){ printf(&quot;%c:%d\\n&quot;,s[i],rebase[s[i]]); }*/ for(int i=0;i&lt;len;i+=4) change(s+i); printf(&quot;\\n&quot;); } return 0;} J# BPM的签到题 发现自己分析能力好弱。。尤其是做这种构造题。 从左往右逐个贪心选取，能选取的条件是后面能补回来。 每个位只可能出现三种情况，逐个判断即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;const int N=100005;char a[N],b[N];int main(){ int n; scanf(&quot;%d&quot;,&amp;n); while(n--){ scanf(&quot; %s %s&quot;,a,b); int len=strlen(a); int d=0; for(int i=0;i&lt;len;i++){ if(a[i]==b[i]){ printf(&quot;a&quot;); continue; } int t[3]={a[i],b[i],'a'}; while(t[2]==a[i]||t[2]==b[i])t[2]++; for(int ii=0;ii&lt;2;ii++){ for(int jj=ii+1;jj&lt;3;jj++){ if(t[ii]&gt;t[jj])swap(t[ii],t[jj]); } } /*for(int ii=0;ii&lt;3;ii++){ printf(&quot;\\ntest:t[%d]=%c\\n&quot;,ii,t[ii]); }*/ for(int ii=0;ii&lt;3;ii++){ if(t[ii]!=a[i]&amp;&amp;t[ii]!=b[i]&amp;&amp;d==0){ printf(&quot;%c&quot;,t[ii]); break; } int td=d; if(t[ii]!=a[i])d++; if(t[ii]!=b[i])d--; int count=0; for(int jj=i+1;jj&lt;len;jj++){ if(a[jj]!=b[jj])count++; if(count&gt;=abs(d))break; } //printf(&quot;\\nii=%d,d=%d,count=%d\\n&quot;,ii,d,count); if(count&gt;=abs(d)){ printf(&quot;%c&quot;,t[ii]); break; }else{ d=td; } } } puts(&quot;&quot;); } return 0;} K# BPM种南瓜 n个区间里面选k个，要求这k个区间的连续公共长度最大。 先对左端点排序，依次选取。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;struct seg{ int l,r; seg(int l,int r):l(l),r(r){}};bool cmp1(seg a,seg b){ return a.l&lt;b.l;}struct cmp2{ bool operator()(seg a,seg b){ return a.r&gt;b.r; }};vector&lt;seg&gt;V;priority_queue&lt;seg,vector&lt;seg&gt;,cmp2&gt; Q;int main(){ int n,k; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=n;i++){ int l,r; scanf(&quot;%d%d&quot;,&amp;l,&amp;r); V.push_back(seg(l,r)); } sort(V.begin(),V.end(),cmp1); int ans=0; for(auto i:V){ //printf(&quot;test:V=(%d,%d)\\n&quot;,i.l,i.r); if(Q.size()&lt;k){ Q.push(i); if(Q.size()==k){ ans=max(ans,Q.top().r-i.l); } continue; } //printf(&quot;Q.top=(%d,%d)\\n&quot;,Q.top().l,Q.top().r); Q.push(i); seg temp=Q.top(); Q.pop(); if(temp.r!=i.r)ans=max(ans,Q.top().r-i.l); } printf(&quot;%d\\n&quot;,ans); return 0;} L# 小南瓜爱旅游","link":"/posts/scutpc2018-newcup/"},{"title":"2018年计算机科学与工程学院新生赛","text":"ACM新生赛总结，加油！ A# 326. CC玩游戏 只需判断$T+\\sum_{i=1}^nA[i]\\le K$是否成立即可。 123456789101112131415#include &lt;iostream&gt;using namespace std;int main(){ int n,t,k; cin&gt;&gt;n&gt;&gt;t&gt;&gt;k; int sum=0; for(int i=1;i&lt;=n;i++){ int x; cin&gt;&gt;x; sum+=x; } if(t+sum&lt;=k)cout&lt;&lt;&quot;CCHandsome!\\n&quot;; else cout&lt;&lt;&quot;PoorCC!&quot;; return 0;} B# 327. CC的木棍 推出答案的函数表达式，容易看出单调性。 二分求函数零点。 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;double x,y,c;const double eps=1e-9;double f(double m){ double tx=(x*x-m*m),ty=(y*y-m*m); double ans=tx*ty-c*c*(tx+ty+2*sqrt(tx*ty)); return ans;}int main(){ cin&gt;&gt;x&gt;&gt;y&gt;&gt;c; double l=0,r=min(x,y),mid; int flag=(f(l)&gt;0)?1:0; while(1){ mid=(l+r)/2.0; double temp=f(mid); if(fabs(l-r)&lt;eps)break; if(fabs(temp)&lt;eps)break; else if(temp&gt;0){ if(flag)l=mid; else r=mid; }else if(temp&lt;0){ if(flag)r=mid; else l=mid; } } printf(&quot;%.8lf\\n&quot;,mid); return 0;} C# 328. CC的秘密 先预处理出[1000,9999]范围内所有的素数。 然后写大暴力，把A在12步变动以内所有的数处理一遍，看是否有B。 一开始我也是不确定多少步，通过写暴力数据测试，可以得知。 范围内任意一个素数都可以在10步以内修改得到任意另一个素数。 因此这题的Impossible是不可能出现的情况！ BFS完全没想到啊 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int check[10005],can[15][10005];int main(){ //freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); //freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); for(int i=1000;i&lt;=9999;i++){ int f=1; for(int j=2;j&lt;=int(sqrt(i))+1;j++){ if(i%j==0){ f=0; break; } } if(f)check[i]=1; } int t; cin&gt;&gt;t; while(t--){ int a,b; cin&gt;&gt;a&gt;&gt;b; if(a==b){ cout&lt;&lt;&quot;0\\n&quot;; continue; } memset(can,0,sizeof(can)); can[0][a]=1; int times=0; for(int i=1;i&lt;=12;i++){ for(int j=1000;j&lt;=9999;j++){ if(can[i-1][j]){ int a1=j/1000,a2=(j/100)%10,a3=(j%100)/10,a4=(j%10); for(int k=1;k&lt;=9;k++){ if(k==a1)continue; int temp=k*1000+a2*100+a3*10+a4; if(check[temp]){ can[i][temp]=1; } } for(int k=0;k&lt;=9;k++){ if(k==a2)continue; int temp=a1*1000+k*100+a3*10+a4; if(check[temp]){ can[i][temp]=1; } } for(int k=0;k&lt;=9;k++){ if(k==a3)continue; int temp=a1*1000+a2*100+k*10+a4; if(check[temp]){ can[i][temp]=1; } } for(int k=0;k&lt;=9;k++){ if(k==a4)continue; int temp=a1*1000+a2*100+a3*10+k; if(check[temp]){ can[i][temp]=1; } } } if(can[i][b]){ times=i; break; } } if(times)break; } if(times)cout&lt;&lt;times&lt;&lt;endl; else cout&lt;&lt;&quot;Impossible&quot;&lt;&lt;endl; } return 0;} 附上当时考场上写的数据生成程序。 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;using namespace std;int check[10005];int main(){ freopen(&quot;input.txt&quot;,&quot;w&quot;,stdout); cout&lt;&lt;&quot;100\\n&quot;; for(int i=1000;i&lt;=9999;i++){ int flag=1; for(int j=2;j&lt;int(sqrt(i))+1;j++){ if(i%j==0){ flag=0; break; } } if(flag){ //printf(&quot;1009 %d\\n&quot;,i); check[i]=1; } } int count=0; for(int i=1000;i&lt;=9999;i++){ for(int j=1000;j&lt;=9999;j++){ if(check[i]&amp;&amp;check[j]){ printf(&quot;%d %d\\n&quot;,i,j); count++; } } } cout&lt;&lt;count&lt;&lt;endl; return 0;} D# 329. CC的画板 E# 330. CC锤小兵 当时没想到前缀和+后缀和的做法。 用了一种类似数位dp的方法。 f[i][j][0]表示前i-1个数第j位是否有0 f[i][j][1]表示前i-1个数第j位是否有1 g[i][j]类似表示第i个数后的数。 感觉和前缀后缀类似，但是写法要麻烦一点。 这样可以处理位与和位或。 由于异或的逆元是本身。 故可以先把所有数异或一下，再异或a[i]就可以得到除a[i]外所有数异或的结果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int N=100005;int a[N],p[N],Xor,f[N][12][2],g[N][12][2];int main(){ //freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); //freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i]; } Xor=a[1]; for(int i=2;i&lt;=n;i++){ Xor=Xor^a[i]; } for(int i=1;i&lt;=m;i++){ cin&gt;&gt;p[i]; } for(int i=2;i&lt;=n;i++){ for(int j=0;j&lt;=10;j++){ f[i][j][0]=f[i][j][0]||f[i-1][j][0]||(((a[i-1]&gt;&gt;j)&amp;1)==0); f[i][j][1]=f[i][j][1]||f[i-1][j][1]||(((a[i-1]&gt;&gt;j)&amp;1)==1); //printf(&quot;f[%d][%d][0]=%d,f[%d][%d][1]=%d\\n&quot;,i,j,f[i][j][0],i,j,f[i][j][1]); } } for(int i=n-1;i&gt;=1;i--){ for(int j=0;j&lt;=10;j++){ //printf(&quot;(a[%d]&gt;&gt;%d)&amp;1=%d\\n&quot;,i+1,j,(a[i+1]&gt;&gt;j)&amp;1); g[i][j][0]=g[i][j][0]||g[i+1][j][0]||(((a[i+1]&gt;&gt;j)&amp;1)==0); g[i][j][1]=g[i][j][1]||g[i+1][j][1]||(((a[i+1]&gt;&gt;j)&amp;1)==1); //printf(&quot;g[%d][%d][0]=%d,g[%d][%d][1]=%d\\n&quot;,i,j,g[i][j][0],i,j,g[i][j][1]); } } for(int i=1;i&lt;=n;i++){ for(int j=0;j&lt;=10;j++){ f[i][j][0]=f[i][j][0]||g[i][j][0]; f[i][j][1]=f[i][j][1]||g[i][j][1]; //printf(&quot;f[%d][%d][0]=%d,f[%d][%d][1]=%d\\n&quot;,i,j,f[i][j][0],i,j,f[i][j][1]); } } int w=0; for(int i=1;i&lt;=m;i++){ for(int j=0;j&lt;=10;j++){ if(f[p[i]][j][0]==0/*&amp;&amp;f[p[i]][j][1]*/){ w+=(1&lt;&lt;j); //printf(&quot;&amp;&amp;when i=%d,j=%d,w=%d\\n&quot;,i,j,w); } if(f[p[i]][j][1]==1){ w+=(1&lt;&lt;j); //printf(&quot;||when i=%d,j=%d,w=%d\\n&quot;,i,j,w); } /*if((f[p[i]][j][0]==1)&amp;&amp;(f[p[i]][j][1]==1)){ w+=(1&lt;&lt;j); printf(&quot;^^when i=%d,j=%d,w=%d\\n&quot;,i,j,w); }*/ } w+=Xor^a[p[i]]; } cout&lt;&lt;w&lt;&lt;endl; return 0;} F# 331. CC看星星 一个简单又重要的结论：最大的斜率一定在两个x坐标相邻的点连接产生 画图易证。 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;const int N=100005;struct point{ int x,y;}a[N];bool cmp(point x,point y){ return x.x&lt;y.x;}int main(){ int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ scanf(&quot;%d%d&quot;,&amp;a[i].x,&amp;a[i].y); } sort(a+1,a+1+n,cmp); double maxk=-1e9; for(int i=1;i&lt;n;i++){ double temp=double(a[i].y-a[i+1].y)/(a[i].x-a[i+1].x); if(temp&gt;maxk)maxk=temp; } printf(&quot;%.14lf\\n&quot;,maxk); return 0;} G# 332. CC的单向路 构造题（(⊙o⊙)…） 边只能从到达点数多的点连向到达点数少的点。 做法参考题解： 先按A[i]排序，从小开始，若某个点到达的点数比A值小于它的点数更大，则无解。 否则连A[i]条单向边指向前A[i]个点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;struct node{ int index,reach; node(int a,int b):index(a),reach(b){}};struct edge{ int u,v; edge(int u,int v):u(u),v(v){}};bool cmp(node x,node y){ return x.reach&lt;y.reach;}vector&lt;node&gt; G;vector&lt;edge&gt; E;int main(){ int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ int x; scanf(&quot;%d&quot;,&amp;x); G.push_back(node(i,x)); } sort(G.begin(),G.end(),cmp); int f=1,m=0; for(int i=0;i&lt;n;i++){ int order=i; while(order&gt;0&amp;&amp;G[order].reach==G[order-1].reach)order--; if(order&lt;G[i].reach){ f=0; break; } for(int j=0;j&lt;G[i].reach;j++){ E.push_back(edge(G[i].index,G[j].index)); m++; } } if(f==0)puts(&quot;-1&quot;); else{ printf(&quot;%d\\n&quot;,m); for(auto i:E){ printf(&quot;%d %d\\n&quot;,i.u,i.v); } } return 0;} H# 333. CC的速度 简单的dp。 显然CC的疲劳值先增后减，并且一定会减到0。 由于最后的疲劳值一定为0，从后往前分析。 0这个状态一定从之前一个0的状态转移而来。 故枚举所有可转移的状态，取最优解。 利用前缀和计算区间和。 f[i]表示在第i分钟结束后，CC的疲劳值一定是0的情况下，最远能冲多远。 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int N=10005;const int M=505;int d[N],f[N],sum[N];int main(){ int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;d[i]; sum[i]=sum[i-1]+d[i]; } for(int i=1;i&lt;=n;i++){ f[i]=max(f[i],f[i-1]); for(int j=0;j&lt;=m;j++){ if(i-(j&lt;&lt;1)&gt;=0)f[i]=max(f[i],f[i-(j&lt;&lt;1)]+sum[i-j]-sum[i-(j&lt;&lt;1)]); } } cout&lt;&lt;f[n]&lt;&lt;endl; return 0;} I# 334. CC好厉害 利用的数学技巧。 主要是对数的两个性质： $$ \\log_ab^n=n\\log_ab\\\\ \\log_abc=\\log_ab+log_ac $$ 由于任意一个数都可以用科学计数法表示。 如$10234432=1.0234432 \\times 10^7$，则$\\log_{10}(10234432)=\\log_{10}(1.0234432)+7$ 那么$\\log_{10}(1.0234432)$就是$\\log_{10}(10234432)$的小数部分。 因此，若要计算$X^n$的前$k$位，可以先取对数，把指数降成乘积。 $\\log_{10}X^n=n\\times \\log_{10}X$，再取出这个数的小数部分$Y$（整数部分不影响前$k$位的值） 计算$10^Y$，就可以得到用小数表示的结果。 显然$10^{Y+k-1}$的整数部分就是$X^n$的前$k$位。 下面用了fmod(X,1)来求X的小数部分。 123456789101112#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;const int M=3;int main(){ //cout&lt;&lt;fmod(2.71828,1); long long n,k; cin&gt;&gt;n&gt;&gt;k; cout&lt;&lt;int(pow(10,M-1+fmod(k*log10(n),1)))&lt;&lt;endl; return 0;} J# 335. CC的金手指 容易推出ab可以互换位置，而c无法变化。 故先判断c的数量，再以c为分界点判断每个区间内的ab数量的奇偶性。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;char s1[10005],s2[10005];int main(){ int n; cin&gt;&gt;n&gt;&gt;s1&gt;&gt;s2; int c1=0,c2=0; for(int i=0;i&lt;n;i++){ if(s1[i]=='c')c1++; if(s2[i]=='c')c2++; } if(c1!=c2)puts(&quot;No&quot;); else{ int f=1; s1[n]=s2[n]='c'; int sc1=0,sc2=0; while(sc1&lt;=n&amp;&amp;sc2&lt;=n){ int a1=0,a2=0,b1=0,b2=0; while(s1[sc1]!='c'){ if(s1[sc1]=='a')a1++; else if(s1[sc1]=='b')b1++; sc1++; } while(s2[sc2]!='c'){ if(s2[sc2]=='a')a2++; else if(s2[sc2]=='b')b2++; sc2++; } if((a1&amp;1)!=(a2&amp;1)||(b1&amp;1)!=(b2&amp;1)){ f=0; break; } sc1++; sc2++; } if(f)puts(&quot;Yes&quot;); else puts(&quot;No&quot;); } return 0;} 参考资料# 题解 优秀代码","link":"/posts/scutpc2018-summary1/"},{"title":"2018年计算机科学与工程学院新生赛2","text":"ACM新生赛总结2，加油！ A# 336. 酋雷姆 这题想法很好，把看似两种不同的毁灭世界方法统一成一种。 假想一个世界0，它在开始时就已经毁灭，并且把世界0和世界$i$连接需要花费$w_i$。 这样问题就变成求完全图的最小生成树了。 Kruskal算法# 时间复杂度$O(E\\lg E)$，可能常数偏大，并查集并未写按秩合并的功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;struct edge{ int u,v,w; edge(int u,int v,int w):u(u),v(v),w(w){}};vector&lt;edge&gt; E;int Set[505];bool cmp(edge x,edge y){ return x.w&lt;y.w;}int Find(int x){ return Set[x]=((x==Set[x])?x:Find(Set[x]));}void Union(int x,int y){ Set[Find(x)]=Find(y);}int main(){ //freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ int w; scanf(&quot;%d&quot;,&amp;w); E.push_back(edge(0,i,w)); } for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=n;j++){ int w; scanf(&quot;%d&quot;,&amp;w); if(i&gt;j)E.push_back(edge(i,j,w)); //E.push_back(edge(i,j,w)); } } sort(E.begin(),E.end(),cmp); for(int i=0;i&lt;=n;i++){ Set[i]=i; } long long ans=0; for(auto i:E){ if(Find(i.u)!=Find(i.v)){ ans+=i.w; Union(i.u,i.v); } } printf(&quot;%lld\\n&quot;,ans); return 0;} Prim算法# 时间复杂度$O(E\\lg V)$，采用了优先队列优化，若用斐波那契堆实现优先队列可优化到$O(V\\lg V)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;struct edge{ int v,w; edge(int v,int w):v(v),w(w){}};vector&lt;edge&gt; G[505];struct cmp{ bool operator()(edge a,edge b){ return a.w&gt;b.w; }};int vis[505];priority_queue&lt;edge,vector&lt;edge&gt;,cmp&gt; Q;int main(){ //freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ int w; scanf(&quot;%d&quot;,&amp;w); G[0].push_back(edge(i,w)); G[i].push_back(edge(0,w)); } for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=n;j++){ int w; scanf(&quot;%d&quot;,&amp;w); if(i&gt;j){ G[i].push_back(edge(j,w)); G[j].push_back(edge(i,w)); //printf(&quot;add edge(%d,%d) and edge(%d,%d)\\n&quot;,j,w,i,w); } } } vis[0]=1; for(auto i:G[0])Q.push(i); int count=1; long long ans=0; while(count&lt;=n){ while(vis[Q.top().v])Q.pop(); edge u=Q.top(); vis[u.v]=1; for(auto i:G[u.v]){ Q.push(i); } ans+=u.w; count++; //printf(&quot;u.v=%d,u.w=%d,ans=%d\\n&quot;,u.v,u.w,ans); } printf(&quot;%lld\\n&quot;,ans); return 0;} B# 337. 岩殿居蟹 把题目给的式子拆开，可以发现只要维护$A_i$与$i\\times A_i$的区间和。 用树状数组维护即可。 由于平时树状数组写的少，比赛时一直出错，结果没写出来。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int N=100005;const long long M=1000000007ll;long long n,a[N],b[N];int lowbit(int x){ return x&amp;(-x);}void add(long long *arr,int x,int v){ while(x&lt;=n){ arr[x]+=v; x+=lowbit(x); }}long long sum(long long *arr,int x){ long long ans=0; while(x&gt;0){ ans+=arr[x]; while(ans&gt;=M)ans-=M; //ans%=M; x-=lowbit(x); } return ans;}int main(){ //freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); //freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); //cin&gt;&gt;n; scanf(&quot;%lld&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ int x; //cin&gt;&gt;x; scanf(&quot;%d&quot;,&amp;x); add(a,i,x); add(b,i,i*x); } /*for(int i=1;i&lt;=n;i++){ printf(&quot;a[%d]=%lld,b[%d]=%lld\\n&quot;,i,sum(a,i)-sum(a,i-1),i,sum(b,i)-sum(b,i-1)); }*/ int m; cin&gt;&gt;m; for(int i=1;i&lt;=m;i++){ char s; int x,y; //cin.get(); //cin&gt;&gt;s&gt;&gt;x&gt;&gt;y; scanf(&quot; %c%d%d&quot;,&amp;s,&amp;x,&amp;y); if(s=='C'){ int temp=sum(a,x)-sum(a,x-1); add(a,x,-temp+y); add(b,x,-x*temp+x*y); }else if(s=='Q'){ long long ans=sum(b,y)-sum(b,x-1)-((x-1)*sum(a,y))+((x-1)*sum(a,x-1)); while(ans&lt;0)ans+=M; while(ans&gt;=M)ans-=M; //cout&lt;&lt;ans&lt;&lt;endl; printf(&quot;%lld\\n&quot;,ans); } /*printf(&quot;after i=%d\\n&quot;,i); for(int i=1;i&lt;=n;i++){ printf(&quot;a[%d]=%lld,b[%d]=%lld\\n&quot;,i,sum(a,i)-sum(a,i-1),i,sum(b,i)-sum(b,i-1)); }*/ } return 0;} C# 338. 三首恶龙 问至少有多大，显然可以二分x，对每个x判断是否可行。 判断x时贪心选择即可。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int N=100005;int n,m,a[N];int check(int x){ int i=1,d=0; while(1){ d++; int mm=a[i++]; while(i&lt;=n&amp;&amp;mm+a[i]&lt;=x){ mm+=a[i]; i++; } if(d&gt;m)return 0; if(i&gt;n)break; } return 1;}int main(){ //freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); //freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); cin&gt;&gt;n&gt;&gt;m; int Max=0,Sum=0; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i]; if(a[i]&gt;Max)Max=a[i]; Sum+=a[i]; } int l=Max,r=Sum; while(l&lt;r){ int mid=(l+r)&gt;&gt;1; if(check(mid)){ r=mid; }else{ l=mid+1; } //printf(&quot;l=%d,r=%d,mid=%d\\n&quot;,l,r,mid); } cout&lt;&lt;l&lt;&lt;endl; return 0;} D# 339. 谜拟Ｑ E# 340. 单首龙 题解说是dp，但我暴力二分也过了。 显然只需考虑最大沿主对角线对称子矩阵。 同样是求最大，而且注意到，这个最大的子矩阵的子矩阵也必然是沿主对角线对称的。 对每一个x暴力判断是否存在大小为x的沿主对角线对称子矩阵。 复杂度有点难分析，可能约为$O(n^3\\lg n)$。 二分做法：# 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int N=505;int n,a[N][N];int check(int x){ for(int i=1;i&lt;=n-x+1;i++){ for(int j=1;j&lt;=n-x+1;j++){ int flag=1; for(int ii=1;ii&lt;=x;ii++){ for(int jj=ii+1;jj&lt;=x;jj++){ if(a[i+ii-1][j+jj-1]!=a[i+jj-1][j+ii-1]){ flag=0; break; } } if(flag==0)break; } if(flag==1)return 1; } } return 0;}int main(){ //freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=n;j++){ cin&gt;&gt;a[i][j]; } } int l=1,r=n; while(l&lt;r){ int mid=(l+r+1)&gt;&gt;1; if(check(mid)){ l=mid; }else{ r=mid-1; } //printf(&quot;l=%d,r=%d,mid=%d\\n&quot;,l,r,mid); } cout&lt;&lt;l&lt;&lt;&quot; 1\\n&quot;; return 0;} dp做法# 此题也可利用dp，用$f[i][j]$表示以原矩阵第$i$行第$j$列为右下角的最大沿主对角线对称子矩阵边长。 则计算$f[i][j]$时只需从小到大枚举一个边长$k$，比较第$i$行第$j$列对应数值是否相同，同时判断$f[i-1][j-1]\\ge k-1$是否成立即可。 复杂度为$O(n^3)$。 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;int a[505][505],f[505][505];int main(){ int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ for(int j=n;j&gt;=1;j--){ scanf(&quot;%d&quot;,&amp;a[i][j]); f[i][j]=1; } } for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=n;j++){ int op=f[i-1][j+1]; int flag=1,k; for(k=1;k&lt;=op;k++){ if(a[i-k][j]!=a[i][j+k]){ flag=0; break; } } if(flag==0)f[i][j]=k; else f[i][j]=op+1; } } int ans=1; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) ans=max(ans,f[i][j]); printf(&quot;%d 1\\n&quot;,ans); return 0;} F# 341. 爆香猴 广搜。。。 为什么我广搜都不会。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1005;const int INF=0x3f3f3f3f;int x[N],y[N],r[N],vis[N][N];struct node{ int x,y,t; node(int x,int y,int t):x(x),y(y),t(t) {}};queue&lt;node&gt; Q;int main(){ //freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n,m,k; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=k;i++){ scanf(&quot;%d%d%d&quot;,&amp;x[i],&amp;y[i],&amp;r[i]); } int sx,sy,gx,gy; scanf(&quot;%d%d%d%d&quot;,&amp;sx,&amp;sy,&amp;gx,&amp;gy); for(int t=1;t&lt;=k;t++){ for(int i=-r[t];i&lt;=r[t];i++){ for(int j=-r[t];j&lt;=r[t];j++){ if(x[t]+i&gt;=1&amp;&amp;x[t]+i&lt;=n&amp;&amp;y[t]+j&gt;=1&amp;&amp;y[t]+j&lt;=m&amp;&amp;abs(i*i)+abs(j*j)&lt;=r[t]*r[t])vis[x[t]+i][y[t]+j]=1; } } } /*for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++){ printf(&quot;%d &quot;,vis[i][j]); } puts(&quot;&quot;); }*/ if(vis[sx][sy]||vis[gx][gy]){ puts(&quot;-1&quot;); return 0; } //BFS Q.push(node(sx,sy,0)); int ans=INF; while(!Q.empty()){ node u=Q.front(); //printf(&quot;When BFS (%d,%d):\\n&quot;,u.x,u.y); Q.pop(); if(vis[u.x][u.y])continue; vis[u.x][u.y]=1; if(u.x==gx&amp;&amp;u.y==gy&amp;&amp;u.t&lt;ans){ ans=u.t; continue; } if(u.t&gt;=ans)continue; if(u.x&gt;1&amp;&amp;!vis[u.x-1][u.y]){ Q.push(node(u.x-1,u.y,u.t+1)); //printf(&quot;\\tpush(%d,%d)\\n&quot;,u.x-1,u.y); } if(u.y&gt;1&amp;&amp;!vis[u.x][u.y-1]){ Q.push(node(u.x,u.y-1,u.t+1)); //printf(&quot;\\tpush(%d,%d)\\n&quot;,u.x,u.y-1); } if(u.x&lt;n&amp;&amp;!vis[u.x+1][u.y]){ Q.push(node(u.x+1,u.y,u.t+1)); //printf(&quot;\\tpush(%d,%d)\\n&quot;,u.x+1,u.y); } if(u.y&lt;m&amp;&amp;!vis[u.x][u.y+1]){ Q.push(node(u.x,u.y+1,u.t+1)); //printf(&quot;\\tpush(%d,%d)\\n&quot;,u.x,u.y+1); } } if(ans!=INF)printf(&quot;%d\\n&quot;,ans); else puts(&quot;-1&quot;); return 0;} G# 342. 战槌龙 2018 ICPC沈阳站 热身赛B——CLS and LCS 题意 ： A和B两字符串的LCS长度是k，现给定A和k，输出一个B。 思路 ： 统计A中出现次数最少的字母，例如是a，就将B置为N个a，然后从前往后把A中不是a的字母替换B中字母，替换k-a个即可。 例如 A ：acbdbaaad N = 9， K = 8. 其中c个数最少，则B = ccccccccc K - c个数 = 7 则B = acbdbaaac。 构造题很玄学。。 思路不是很清晰，慢慢想一下。。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1005;int a[N],b[N],c[N];int main(){ freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); int n,m,k; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]); c[a[i]]++; } int mini=1; for(int i=2;i&lt;=m;i++){ if(c[i]&lt;c[mini])mini=i; } if(c[mini]&gt;k||k&gt;n){ puts(&quot;-1&quot;); return 0; } //printf(&quot;mini=%d\\n&quot;,mini); for(int i=1;i&lt;=n;i++){ if(a[i]==mini)b[i]=mini; } int cnt=k-c[mini]; for(int i=1;i&lt;=n;i++){ if(a[i]!=mini){ b[i]=a[i]; cnt--; } if(cnt==0)break; } for(int i=1;i&lt;=n;i++){ if(b[i]==0)b[i]=mini; } for(int i=1;i&lt;=n;i++){ printf(&quot;%d &quot;,b[i]); } puts(&quot;&quot;); return 0;} H# 343. 牙牙 I# 344. 基格尔德 暴力匹配。 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;using namespace std;const int N=10005;char S[N],T[12];int main(){ //freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); cin&gt;&gt;S; int n,len=strlen(S); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;T; int cnt=0,lent=strlen(T); for(int j=0;j&lt;lent;j++){ if(T[j]=='A')T[j]='T'; else if(T[j]=='T')T[j]='A'; else if(T[j]=='G')T[j]='C'; else if(T[j]=='C')T[j]='G'; } for(int j=0;j&lt;=len-lent;j++){ int f=1; for(int k=0;k&lt;lent;k++){ if(T[k]!=S[j+k]){ f=0; break; } } if(f)cnt++; } cout&lt;&lt;cnt&lt;&lt;endl; } return 0;} J# 345. 变隐龙 大坑题。题意非常简单，就是数字有点大。 但是我没注意到在unsigned long long范围内。 一开始用两个long long 计算一直WA。 含泪打了个高精度模版通过。 后来才听说long double也能过。 C++高精度模版做法：# 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int base=10000;const int width=4;const int N=1000;struct bint{ int ln,v[N]; bint (long long r=0){ for(ln=0;r&gt;0;r/=base)v[ln++]=r%base; } bint&amp; operator=(const bint&amp;r){ memcpy(this,&amp;r,(r.ln+1)*sizeof(int)); return *this; }};bool operator&lt;(const bint&amp;a,const bint&amp;b){ int i; if(a.ln!=b.ln) return a.ln&lt;b.ln; for(i=a.ln-1;i&gt;=0&amp;&amp;a.v[i]==b.v[i];i--); return i&lt;0?0:a.v[i]&lt;b.v[i];}bint operator+(const bint&amp;a,const bint&amp;b){ bint res;int i,cy=0; for(i=0;i&lt;a.ln||i&lt;b.ln||cy&gt;0;i++){ if(i&lt;a.ln)cy+=a.v[i]; if(i&lt;b.ln)cy+=b.v[i]; res.v[i]=cy%base; cy/=base; } res.ln=i; return res;}void write(const bint&amp;v){ int i; printf(&quot;%d&quot;,v.ln==0?0:v.v[v.ln-1]); for(i=v.ln-2;i&gt;=0;i--) printf(&quot;%04d&quot;,v.v[i]); printf(&quot;\\n&quot;);}int main(){ //freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n; cin&gt;&gt;n; bint ans(0); for(int i=1;i&lt;=n;i++){ long long x; cin&gt;&gt;x; if(x&lt;0)x=-x; bint tx(x); ans=ans+tx; } write(ans); return 0;} C++unsigned long long 做法：# 12345678910111213#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ int n; unsigned long long ans=0; scanf(&quot;%d&quot;,&amp;n); while(n--){ long long x; scanf(&quot;%lld&quot;,&amp;x); ans+=abs(x); } printf(&quot;%llu\\n&quot;,ans);} C++long double做法# 这里x的读入用long long也行，取绝对值最好用fabs，但经过测试用abs也可通过。 12345678910111213#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ int n; long double ans=0; cin&gt;&gt;n; while(n--){ long double x; cin&gt;&gt;x; ans+=fabs(x); } cout&lt;&lt;fixed&lt;&lt; setprecision(0)&lt;&lt;ans;} 参考资料# 题解 优秀代码","link":"/posts/scutpc2018-summary2/"},{"title":"2018级-C++-第5章课后作业(计科1班、创新班、辅修班)","text":"A# Problem A: 二进制数右移 print函数功能：把x按二进制位输出，每8位空一格。 123456789101112131415161718#include &lt;iostream&gt;using namespace std;void print(long long x){ for(int i=1;i&lt;=32;i++){ cout&lt;&lt;((x&gt;&gt;(32-i))&amp;1); if(i%8==0)cout&lt;&lt;' '; } cout&lt;&lt;endl;}int main(){ long long n; while(cin&gt;&gt;n){ print(n); print(n&gt;&gt;4); } return 0;} B# Problem B: 判断水平线和垂直线 判断是否有相同的x坐标或y坐标即可。 123456789101112131415161718#include &lt;iostream&gt;using namespace std;struct Point{ int x; int y; }a[105];int main(){ int n; while(cin&gt;&gt;n){ int fx=1,fy=1; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i].x&gt;&gt;a[i].y; if(i&gt;1&amp;&amp;a[i].x!=a[i-1].x)fx=0; if(i&gt;1&amp;&amp;a[i].y!=a[i-1].y)fy=0; } if(fx||fy)cout&lt;&lt;&quot;YES\\n&quot;; else cout&lt;&lt;&quot;NO\\n&quot;; } return 0;} C# Problem C: 快速交换 请勿使用中间变量完成交换，如检查代码发现中间变量，视为未过。 。。。看到这句话真是。。难道不是不用交换也可以过嘛 这里就说说交换两个变量的原理吧。 一般而言，交换两个变量可以用第三个变量； 但对于整型、浮点型等变量，存在一种利用逆元的交换变量方法。 例如选取±这一对逆元 a=a+b 这时a存放的是a与b的和。 b=a-b 这时b存放的是a与b的和减去b的值（也就是a的值） a=a-b 这是a存放的是a与b的和减去a的值（也就是b的值） 以此类推，选取*/这一对逆元同样可以。 特殊的是，异或运算的逆元是它本身。 于是就有了看起来很高端的交换方法： a=a^b b=a^b a=a^b 写在一行里就是 a^=b^=a^=b 交换做法# 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;int main(){ //freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n,x[105],y[105]; while(cin&gt;&gt;n){ for(int i=1;i&lt;=n;i++){ cin&gt;&gt;x[i]; } for(int i=1;i&lt;=n;i++){ cin&gt;&gt;y[i]; } for(int i=1;i&lt;=n;i++){ x[i]^=y[i]^=x[i]^=y[i]; } for(int i=1;i&lt;=n;i++){ cout&lt;&lt;x[i]&lt;&lt;' '; } cout&lt;&lt;endl; for(int i=1;i&lt;=n;i++){ cout&lt;&lt;y[i]&lt;&lt;' '; } cout&lt;&lt;endl; int a,b; cin&gt;&gt;a&gt;&gt;b; if(a==1)cout&lt;&lt;x[b]&lt;&lt;' '&lt;&lt;endl; else cout&lt;&lt;y[b]&lt;&lt;' '&lt;&lt;endl; } return 0;} 不交换做法# 123456789101112131415161718192021222324252627282930313233/*exchange a and b1: a^=b^=a^=b;2.t=a;a=b;b=t;3.a=a+b,b=a-b,a=a-b;but why not no exchange!*/#include &lt;iostream&gt;using namespace std;int main(){ //freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n,x[105],y[105]; while(cin&gt;&gt;n){ for(int i=1;i&lt;=n;i++){ cin&gt;&gt;x[i]; } for(int i=1;i&lt;=n;i++){ cin&gt;&gt;y[i]; } for(int i=1;i&lt;=n;i++){ cout&lt;&lt;y[i]&lt;&lt;' '; } cout&lt;&lt;endl; for(int i=1;i&lt;=n;i++){ cout&lt;&lt;x[i]&lt;&lt;' '; } cout&lt;&lt;endl; int a,b; cin&gt;&gt;a&gt;&gt;b; if(a==1)cout&lt;&lt;y[b]&lt;&lt;' '&lt;&lt;endl; else cout&lt;&lt;x[b]&lt;&lt;' '&lt;&lt;endl; } return 0;} D# Problem D: 找出最高分 注意最后一个输出数据之后没有空格 这里采用了先输出第一个，后面的数据在前面加一个空格的方法。 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;struct student{ string name; int score;};int main(){ //freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n; while(cin&gt;&gt;n){ struct student s[105]; int maxs=0; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;s[i].name&gt;&gt;s[i].score; if(s[i].score&gt;maxs)maxs=s[i].score; } int i; for(i=1;i&lt;=n;i++){ if(s[i].score==maxs){ cout&lt;&lt;s[i].name&lt;&lt;'_'&lt;&lt;s[i].score; break; } } for(i++;i&lt;=n;i++){ if(s[i].score==maxs){ cout&lt;&lt;' '&lt;&lt;s[i].name&lt;&lt;'_'&lt;&lt;s[i].score; } } cout&lt;&lt;endl; }} E# Problem E: 头插法建立单链表 请用指针，数组AC视为未通过。 链表好恶心啊。为什么有人会觉得充满指针的代码很优美？？？ 话说不用数组用string类行吗？ 指针写法# 末尾两个getchar，第一个是读入0，第二个是读入换行符。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;struct node{ char data; node *next;};int main(){ //freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); char ch=getchar(); while(ch!=EOF){ node *head,*p; head=NULL; while(ch!='0'){ p=new node; p-&gt;next=NULL; p-&gt;data=ch; if(head==NULL)head=p; else{ p-&gt;next=head; head=p; } ch=getchar(); } while(head){ //printf(&quot;head-&gt;data=%d\\n&quot;,head-&gt;data); cout&lt;&lt;head-&gt;data&lt;&lt;' '; head=head-&gt;next; //if(head-&gt;data&lt;=0)break; } cout&lt;&lt;endl; ch=getchar(); //printf(&quot;1:ch=%d\\n&quot;,ch); ch=getchar(); //printf(&quot;2:ch=%d\\n&quot;,ch); } return 0;} string写法# 12345678910111213141516#include &lt;iostream&gt;#include &lt;string&gt;struct keyword{};using namespace std;int main(){ string s; while(getline(cin,s)){ int len=s.length(); for(int i=len-2;i&gt;=0;i--){ cout&lt;&lt;s[i]&lt;&lt;' '; } cout&lt;&lt;endl; } return 0;} F# Problem F: 统计相同数据的出现次数 计算并输出链表数据相同值的结点及个数 链表写法# first变量用于控制第一个数据之前不用输出空格。包含链表的插入、删除、遍历操作。 一般而言，单链表由三个指针控制。head指向链表头、s指向当前节点、p指向前一个节点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;using namespace std;struct node{ int val; node *next;};int main(){ int n; while(cin&gt;&gt;n){ node *head,*p,*s; head=new node; cin&gt;&gt;head-&gt;val; p=head; while(--n){ s=new node; p-&gt;next=s; cin&gt;&gt;s-&gt;val; s-&gt;next=NULL; p=s; } int first=0; while(head){ //cout&lt;&lt;&quot;test:&quot;&lt;&lt;head-&gt;val&lt;&lt;endl; int count=1; p=head; s=head-&gt;next; while(s){ if(s-&gt;val==head-&gt;val){ count++; p-&gt;next=s-&gt;next; }else{ p=s; } s=s-&gt;next; } if(count&gt;1){ if(first==1)cout&lt;&lt;' '; if(first==0)first=1; cout&lt;&lt;head-&gt;val&lt;&lt;'_'&lt;&lt;count; } head=head-&gt;next; } cout&lt;&lt;endl; } return 0;} 数组桶排序# 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;struct keyword{};int main(){ //freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n; while(cin&gt;&gt;n){ int a[105],c[1005]={0}; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i]; c[a[i]]++; } for(int i=1;i&lt;=n;i++){ if(c[a[i]]&gt;1){ cout&lt;&lt;a[i]&lt;&lt;'_'&lt;&lt;c[a[i]]; c[a[i]]=0; break; } } for(int i=1;i&lt;=n;i++){ if(c[a[i]]&gt;1){ cout&lt;&lt;' '&lt;&lt;a[i]&lt;&lt;'_'&lt;&lt;c[a[i]]; c[a[i]]=0; } } cout&lt;&lt;endl; } return 0;}","link":"/posts/2018cpp-hw5/"},{"title":"2018级C++-第4章课后作业（计科1班、创新班、辅修班）","text":"狠狠吐槽OJ的输入输出，简直有毒。 输出判断设置成逐字节比较（一般是忽略末尾多余的回车与空格） 读入还不给数据组数和数据个数，还改数据！！ 目前A题只用stream流输入输出过了。如有其他读入方法，望留言指出。 A# Problem A: 求平均成绩和方差 1234567891011121314151617181920212223#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;sstream&gt;using namespace std;int main(){ string s; while(getline(cin,s)){ istringstream in(s); int n=0,a[105],sum=0; while(in&gt;&gt;a[n++]){ sum+=a[n-1]; } n--; double avg=1.0*sum/n,dev=0; for(int i=0;i&lt;n;i++){ dev+=(a[i]-avg)*(a[i]-avg); } dev=sqrt(dev/n); cout&lt;&lt;avg&lt;&lt;' '&lt;&lt;dev&lt;&lt;'\\n'; }} B# Problem B: 按要求输出数组 选择排序# 123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;sstream&gt;using namespace std;struct point{ int val,pos;};int main(){ //freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); //freopen(&quot;answer.txt&quot;,&quot;w&quot;,stdout); string s; while(getline(cin,s)){ stringstream in(s); int n=0; point a[105]; while(in&gt;&gt;a[n++].val) a[n-1].pos=n-1; n--; for(int i=0;i&lt;n-1;i++) for(int j=i;j&lt;n;j++) if(a[i].val&lt;=a[j].val)swap(a[i],a[j]); for(int i=0;i&lt;n;i++) printf(&quot;%d_%d%c&quot;,a[i].val,a[i].pos,(i==n-1)?'\\n':' '); } return 0;} sort# 这题用sort+cmp(强行不稳定排序)也可以过。 但这种做法及其危险，通过对拍发现 sort如果cmp函数在两个元素相等情况下返回真，有可能会陷入死循环。 这与sort内部实现机制有关，具体就不深究了。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;algorithm&gt;using namespace std;struct point{ int val,pos;};bool cmp(point x,point y){ return x.val&gt;=y.val;}int main(){ //freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); string s; while(getline(cin,s)){ stringstream in(s); int n=0; point a[105]; while(in&gt;&gt;a[n++].val){ a[n-1].pos=n-1; //printf(&quot;a[%d].val=%d,a[%d].pos=%d\\n&quot;,n-1,a[n-1].val,n-1,a[n-1].pos); } n--; /* for(int i=0;i&lt;n-1;i++){ for(int j=i;j&lt;n;j++){ if(a[i].val&lt;=a[j].val)swap(a[i],a[j]); } }*/ sort(a,a+n,cmp); /*for(int i=0;i&lt;n;i++) printf(&quot;a[%d].val=%d,a[%d].pos=%d\\n&quot;,i,a[i].val,i,a[i].pos);*/ for(int i=0;i&lt;n;i++){ printf(&quot;%d_%d%c&quot;,a[i].val,a[i].pos,(i==n-1)?'\\n':' '); } } return 0;} 其中cmp函数可改写成这样。 1234bool cmp(point x,point y){ if(x.val!=y.val)return x.val&gt;y.val; else return x.pos&gt;y.pos;} qsort# 好久没用了，虽然用的少，但是有时候还是比sort快。 虽然qsort本身是不稳定的，但是这题。。。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;algorithm&gt;using namespace std;struct point{ int val,pos;};int cmp(const void *x,const void *y){ if((((point*)y)-&gt;val)!=(((point*)x)-&gt;val)) return (((point*)y)-&gt;val)-(((point*)x)-&gt;val); else return (((point*)y)-&gt;pos)-(((point*)x)-&gt;pos);}int main(){ //freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); string s; while(getline(cin,s)){ stringstream in(s); int n=0; point a[105]; while(in&gt;&gt;a[n++].val){ a[n-1].pos=n-1; //printf(&quot;a[%d].val=%d,a[%d].pos=%d\\n&quot;,n-1,a[n-1].val,n-1,a[n-1].pos); } n--; /* for(int i=0;i&lt;n-1;i++){ for(int j=i;j&lt;n;j++){ if(a[i].val&lt;=a[j].val)swap(a[i],a[j]); } }*/ qsort(a,n,sizeof(point),cmp); /*for(int i=0;i&lt;n;i++) printf(&quot;a[%d].val=%d,a[%d].pos=%d\\n&quot;,i,a[i].val,i,a[i].pos);*/ for(int i=0;i&lt;n;i++){ printf(&quot;%d_%d%c&quot;,a[i].val,a[i].pos,(i==n-1)?'\\n':' '); } } return 0;} C# Problem C: 判断回文数 首尾逐字符比较即可。 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main(){ char s[105]; while(cin&gt;&gt;s){ int len=strlen(s); int f=1; for(int i=0;i&lt;((len+1)&gt;&gt;1);i++){ if(s[i]!=s[len-i-1]){ f=0; break; } } cout&lt;&lt;(f?&quot;YES&quot;:&quot;NO&quot;)&lt;&lt;endl; } return 0;} D# Problem D: 按要求合并数组 依次从两个数组中选取较小的元素即可。 归并排序思想。 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;int main(){ //freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n,m; while(cin&gt;&gt;n&gt;&gt;m){ int a[105],b[105],c[210]; for(int i=0;i&lt;n;i++){ cin&gt;&gt;a[i]; } for(int i=0;i&lt;m;i++){ cin&gt;&gt;b[i]; } int la=0,lb=0,lc=0; a[n]=b[m]=1e9; while(la&lt;n||lb&lt;m){ if(a[la]&lt;=b[lb])c[lc++]=a[la++]; else c[lc++]=b[lb++]; } for(int i=0;i&lt;lc;i++){ cout&lt;&lt;c[i]&lt;&lt;((i==lc-1)?'\\n':' '); } } return 0;} E# Problem E: 用英文表示星期数 1234567891011#include &lt;iostream&gt;using namespace std;char *weekday[7]={&quot;sunday&quot;,&quot;monday&quot;,&quot;tuesday&quot;,&quot;wednesday&quot;,&quot;thursday&quot;,&quot;friday&quot;,&quot;saturday&quot;};int main(){ int n; while(cin&gt;&gt;n){ cout&lt;&lt;weekday[n]&lt;&lt;endl; } return 0;} F# Problem F: 矩阵操作 create|del|main_diagonal OJ上的图炸了，这里放一张图。 使用矩阵操作# 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;int M[105][105];void create(int a[][105],int n){ for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=n;j++){ if(j&gt;=i)a[i][j]=1; else a[i][j]=i-j+1; } }}void del(int a[][105],int n){ for(int i=1;i&lt;=n;i++){ a[1][i]=a[2][i]=a[i][1]=a[i][2]=0; }}int main_diagonal(int a[][105],int n){ int sum=0; for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=n;j++){ if(i&gt;j)sum+=a[i][j]; } } return sum;}int main(){ int n; while(cin&gt;&gt;n){ create(M,n); del(M,n); cout&lt;&lt;main_diagonal(M,n)&lt;&lt;endl; } return 0;} 不使用矩阵操作# 12345678910111213141516//keywords:create del main_diagonal//Keep It Simple and Stupid#include &lt;iostream&gt;using namespace std;int main(){ int n; while(cin&gt;&gt;n){ int sum=0; for(int i=2;i&lt;=n-2;i++){ sum+=(n-i)*(i-1); } cout&lt;&lt;sum&lt;&lt;endl; } return 0;} G# Problem G: 对数组重新排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;void insert(int a[], int n){ int i=1, p = 1; while (i &lt;= n - 3){ if ((a[i] &gt; a[n])&amp;&amp;p){ cout &lt;&lt; a[n]&lt;&lt;' '; p = 0; i--; }else{ if ((a[i] &lt; a[n]) || p == 0) cout &lt;&lt; a[i] &lt;&lt; ' '; else if ((a[i] == a[n])&amp;&amp;p){ cout &lt;&lt; a[i] &lt;&lt; ' ' &lt;&lt; a[i] &lt;&lt; ' '; p = 0; } } i++; } if (p){ if (a[n] &lt; a[n - 2]) cout &lt;&lt; a[n] &lt;&lt; ' ' &lt;&lt; a[n - 2]; else cout &lt;&lt; a[n - 2] &lt;&lt; ' '&lt;&lt;a[n]; } else cout &lt;&lt; a[n - 2]; cout &lt;&lt; endl;}int main(){ string s; int i, j, n; int a[100] = {0}; while (getline(cin, s)){ n = 1; j = 1; for (i = 0; i &lt; s.size(); i++){ if (s[i] == ' ') { a[n] = a[n] * j; n += 1; j = 1; continue; } if (s[i] == '-') { j = -1; continue; } a[n] = a[n] * 10 + (int)(s[i]) - 48; } a[n] *= j; insert(a, n); for (i = 1; i &lt;= n; i++) a[i] = 0; }} H# Problem H: 找出最小关键字 123456789101112131415161718192021#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int main(){ //freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); char s[105][105]; int n=0; while(cin&gt;&gt;s[n++]){ char c=cin.get(); if(c=='\\n'||c==-1){ int mini=0; for(int i=1;i&lt;n;i++){ if(strcmp(s[mini],s[i])&gt;0)mini=i; } cout&lt;&lt;s[mini]&lt;&lt;endl; n=0; } } return 0;} GH后来修改了keyword，stringstream被禁了。重写了一下。。。","link":"/posts/2018cpp-hw4/"},{"title":"2018级计科1、计科2、网工、信安班第14周竞赛题题解","text":"前言# 本文中的题目做法仅供参考，不一定是最简单或是最正确的方法。 每题附的程序源码均在当时通过了OJ测试，但随着时间的推移也有可能失效。 作者水平有限，如有疏漏，在所难免，望留言指出。 A# Problem A: Balloon Comes! 分情况处理，除法时注意判断一下能否整除即可。 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int main(){ int t; cin&gt;&gt;t; while(t--){ char c; int a,b; cin&gt;&gt;c&gt;&gt;a&gt;&gt;b; if(c=='+')cout&lt;&lt;a+b&lt;&lt;endl; else if(c=='-')cout&lt;&lt;a-b&lt;&lt;endl; else if(c=='*')cout&lt;&lt;a*b&lt;&lt;endl; else if(c=='/'){ if(a%b==0){ cout&lt;&lt;a/b&lt;&lt;endl; }else{ cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;double(a)/b&lt;&lt;endl; } } } return 0;} B# Problem B: 整数翻转 主要在于如何判断溢出，这里采用了开long long类型的变量，通过比较大小判断是否溢出。 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;const int N=2147483647;long long rev(long long x){ long long ans=0; while(x){ ans=ans*10+x%10; x/=10; } return ans;}int main(){ long long n; while(cin&gt;&gt;n){ long long re=rev(n); if(re&gt;=(-N-1)&amp;&amp;re&lt;=N)cout&lt;&lt;re&lt;&lt;endl; else cout&lt;&lt;&quot;0\\n&quot;; } return 0;} C# Problem C: 各位相加 按照题意模拟，把各个位上的数加起来，递归处理。 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int dig(int x){ if(x&lt;10)return x; int sum=0; while(x){ sum+=x%10; x/=10; } return dig(sum);}int main(){ int n; while(cin&gt;&gt;n){ cout&lt;&lt;dig(n)&lt;&lt;endl; } return 0;} D# Problem D: 整数转化为罗马数字 罗马数字看似复杂其实也有规律可循。 与普通数字一样可以按位处理。这里采用了常量字符串数组简化判断过程。 s[1]~s[9]对应罗马数字的1~9 s[11]~s[19]对应罗马数字的10~90 后面的以此类推。 注意0是没有对应的罗马数字的。 1234567891011121314151617#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;string s[]={&quot;0&quot;,&quot;I&quot;,&quot;II&quot;,&quot;III&quot;,&quot;IV&quot;,&quot;V&quot;,&quot;VI&quot;,&quot;VII&quot;,&quot;VIII&quot;,&quot;IX&quot;,&quot;0&quot;,&quot;X&quot;,&quot;XX&quot;,&quot;XXX&quot;,&quot;XL&quot;,&quot;L&quot;,&quot;LX&quot;,&quot;LXX&quot;,&quot;LXXX&quot;,&quot;XC&quot;,&quot;0&quot;,&quot;C&quot;,&quot;CC&quot;,&quot;CCC&quot;,&quot;CD&quot;,&quot;D&quot;,&quot;DC&quot;,&quot;DCC&quot;,&quot;DCCC&quot;,&quot;CM&quot;,&quot;0&quot;,&quot;M&quot;,&quot;MM&quot;,&quot;MMM&quot;};int main(){ string ss; while(cin&gt;&gt;ss){ int len=ss.length(); for(int i=0;i&lt;len;i++){ if(ss[i]!='0')cout&lt;&lt;s[(len-i-1)*10+ss[i]-'0']; } cout&lt;&lt;endl; } return 0;} E# Problem E: 旋转数组 显然移动k次和移动k%n次是一样的。 其实也不必真的移动数组中的元素，改变一下输出的顺序就行。 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int main(){ int n; while(cin&gt;&gt;n){ if(n==0)break; int a[55]; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i]; } int k; cin&gt;&gt;k; k%=n; for(int i=n-k+1;i&lt;=n;i++) cout&lt;&lt;a[i]&lt;&lt;' '; for(int i=1;i&lt;=n-k;i++){ cout&lt;&lt;a[i]; if(i==n-k)cout&lt;&lt;endl; else cout&lt;&lt;' '; } } return 0;} F# Problem F: Zigzag表示 此题可以找规律发现输出字符串下标的关系。 具体过程就不在此细说了。 注意运算过程中下标不要越界了。 下面程序在字符串末尾添加了大量空格，避免了特殊处理越界情况。 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(){ string s; int n; while(cin&gt;&gt;s&gt;&gt;n){ for(int i=0;i&lt;1000;i++)s+=&quot; &quot;; int len=s.length(); for(int i=1;i&lt;=n;i++){ for(int j=i-1;j&lt;len;j+=(n-1)*2){ if(s[j-(i-1)*2]!=' '&amp;&amp;i!=n&amp;&amp;j-(i-1)*2&gt;=n&amp;&amp;j-(i-1)*2!=j)cout&lt;&lt;s[j-(i-1)*2]; if(s[j]!=' ')cout&lt;&lt;s[j]; } } cout&lt;&lt;endl; } return 0;} C+# 这里给出C题另外一种做法，巧妙的利用了求余与数位的性质。 在此就不给出推导过程与证明了。 123456789101112#include &lt;iostream&gt;using namespace std;int main(){ int n; while(cin&gt;&gt;n){ if(n==0)cout&lt;&lt;&quot;0\\n&quot;; else cout&lt;&lt;(n+8)%9+1&lt;&lt;endl; } return 0;}","link":"/posts/2018cs-w14c/"},{"title":"2018级计科1、计科2、网工、信安班第15周竞赛题题解","text":"前言# 本文中的题目做法仅供参考，不一定是最简单或是最正确的方法。 每题附的程序源码均在当时通过了OJ测试，但随着时间的推移也有可能失效。 作者水平有限，如有疏漏，在所难免，望留言指出。 A# Problem A: 忽略大小写比较字符串大小 逐个字符比较，遇到不同的就返回。当两个字符均为0时结束。 忽略大小写，这里采用了将所有的大写字母转换成小写字母来处理。 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int MyStrCmp(char *pStr1,char *pStr2){ for(int i=0;;i++){ if(pStr1[i]&gt;='A'&amp;&amp;pStr1[i]&lt;='Z')pStr1[i]+='a'-'A'; if(pStr2[i]&gt;='A'&amp;&amp;pStr2[i]&lt;='Z')pStr2[i]+='a'-'A'; if(pStr1[i]&gt;pStr2[i])return 1; else if(pStr1[i]&lt;pStr2[i])return -1; if(pStr1[i]==0&amp;&amp;pStr2[i]==0)return 0; }}int main(){ char s1[25],s2[25]; while(cin&gt;&gt;s1&gt;&gt;s2){ int ans=MyStrCmp(s1,s2); if(ans==0)printf(&quot;=\\n&quot;); else if(ans==1)printf(&quot;&gt;\\n&quot;); else if(ans==-1)printf(&quot;&lt;\\n&quot;); } return 0;} B# Problem B: 超大整数加法 当数字远远超过已有的数据类型时，只有用字符串来读入处理了。 先读入，再把字符串中的字符转换成数字存到数组里。（注意存到数组里的顺序是相反的，方便进位） 然后按位相加，处理进位即可。 这里的top用来处理数字前面不需要的0。 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main(){ char s1[305],s2[305]; int a1[305],a2[305]; while(cin&gt;&gt;s1&gt;&gt;s2){ memset(a1,0,sizeof(a1)); memset(a2,0,sizeof(a2)); int len1=strlen(s1),len2=strlen(s2); for(int i=0;i&lt;len1;i++){ a1[len1-i-1]=s1[i]-'0'; } for(int i=0;i&lt;len2;i++){ a2[len2-i-1]=s2[i]-'0'; } for(int i=0;i&lt;len2;i++){ a1[i]+=a2[i]; if(a1[i]&gt;=10){ a1[i+1]+=a1[i]/10; a1[i]%=10; } } int top=300; while(a1[top]==0)top--; for(int i=top;i&gt;=0;i--){ cout&lt;&lt;a1[i]; } cout&lt;&lt;endl; } return 0;} C# Problem C: 消费情况调查 按照题意模拟，这里交换元素用了algorithm库文件里的swap函数。 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;struct stu{ string name; int ord,pay,back,actpay; char sex;};int main(){ int n; while(cin&gt;&gt;n){ stu s[105]; int Msum=0,Wsum=0; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;s[i].ord&gt;&gt;s[i].name&gt;&gt;s[i].sex&gt;&gt;s[i].pay&gt;&gt;s[i].back; s[i].actpay=s[i].pay-s[i].back; if(s[i].sex=='M')Msum+=s[i].actpay; else if(s[i].sex=='W')Wsum+=s[i].actpay; } for(int i=1;i&lt;n;i++){ for(int j=i+1;j&lt;=n;j++){ if(s[i].actpay&lt;s[j].actpay)swap(s[i],s[j]); } } cout&lt;&lt;'M'&lt;&lt;Msum&lt;&lt;&quot; W&quot;&lt;&lt;Wsum&lt;&lt;endl; for(int i=1;i&lt;=n;i++){ if(s[i].back&gt;=(s[i].pay/2.0))cout&lt;&lt;s[i].ord; cout&lt;&lt;s[i].name&lt;&lt;' '; } cout&lt;&lt;endl; } return 0;} D# Problem D: Emirp rev函数用于反转数字，check函数判断是否为质数。 这里采用了先预处理出10000以内的符合条件的数字，记录在is数组里。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int rev(int x){ int ans=0; while(x){ ans=ans*10+x%10; x/=10; } return ans;}int check(int x){ int temp=int(sqrt(x)+1); for(int i=2;i&lt;temp;i++){ if(x%i==0)return 0; } return 1;}int is[10005];int main(){ for(int i=2;i&lt;=10000;i++){ if(check(i)&amp;&amp;check(rev(i))){ is[i]=1; } } int n; while(cin&gt;&gt;n){ int count=0; for(int i=2;;i++){ if(is[i]){ cout&lt;&lt;i; count++; if(count%10==0&amp;&amp;count!=n)cout&lt;&lt;endl; else if(count==n){ cout&lt;&lt;endl; break; }else cout&lt;&lt;' '; } } } return 0;} E# Problem E: 数组位置交换及序号名次统计 由于只能用一个数组交换元素，这里利用了下标n以后的空间暂存。 （其实也可以不交换） 显然一个数的排名=大于这个数的个数+1 暴力枚举统计即可。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;void swap(int a[],int m,int n){ for(int i=1;i&lt;=m;i++){ a[m+n+i]=a[i]; } for(int i=1;i&lt;=n;i++){ a[i]=a[m+i]; } for(int i=1;i&lt;=m;i++){ a[n+i]=a[n+m+i]; }}int sortNo(int a[],int m,int n){ int x=a[m]; int t=1; for(int i=1;i&lt;=n;i++){ if(a[i]&gt;x)t++; } return t;}int main(){ int n,m; while(cin&gt;&gt;n&gt;&gt;m){ int s[105]; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;s[i]; } cout&lt;&lt;sortNo(s,m,n)&lt;&lt;endl; swap(s,m,n-m); for(int i=1;i&lt;=n;i++){ cout&lt;&lt;s[i]; if(i==n)cout&lt;&lt;endl; else cout&lt;&lt;' '; } } return 0;} F# Problem F: 子串查找与替换 可以先把str字符串存到strtemp里。用p指向str字符串。p初始化为0。（可以理解为把str字符串清空） 再用i指向strtemp里的字符，逐个处理，对每个字符开始判断是否与find_str相同。 若相同则把replace_str字符串添加在str后面（利用p确定位置），并且i向后跳一段距离。 若不相同则直接把i指向的字符加在str后即可，最后在str末尾添加0截断。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int find_replace_str(char str[],const char find_str[],const char replace_str[]){ int count=0; char strtemp[105]; strcpy(strtemp,str); int p=0; int lens=strlen(str),lenf=strlen(find_str),lenr=strlen(replace_str); for(int i=0;i&lt;lens;i++){ int f=1; if(i&lt;=lens-lenf){ for(int j=0;j&lt;lenf;j++){ if(strtemp[i+j]!=find_str[j]){ f=0; break; } } }else f=0; if(f){ for(int j=0;j&lt;lenr;j++){ str[p++]=replace_str[j]; } i+=lenf-1; count++; }else{ str[p++]=strtemp[i]; } } str[p]=0; return count;}int main(){ char str[100],find_str[20],replace_str[20]; memset(str,0,sizeof(str)); int replace_cnt=0; while(cin&gt;&gt;str&gt;&gt;find_str&gt;&gt;replace_str){ replace_cnt=find_replace_str(str,find_str,replace_str); cout&lt;&lt;replace_cnt&lt;&lt;endl; cout&lt;&lt;str&lt;&lt;endl; memset(str,0,sizeof(str)); } return 0;}","link":"/posts/2018cs-w15c/"},{"title":"2019GDCPC总结","text":"OI退役后还是第一次参加这么大型的比赛，感觉还是很不错的。至少比当初NOIP好多了。 同时感觉大学氛围也还是挺不错的。有队友督促训练。 最终差一题，只拿了银，还是有些可惜吧。 一直找不到重现赛或是提交的链接,先记录一下类似的题目吧. hex A G I (已经有重现赛了,但是还是没时间补题…)","link":"/posts/2019GDCPC-summary/"},{"title":"Avito Cool Challenge 2018","text":"题目 A# A. Definite Game 123456789#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int n; cin&gt;&gt;n; if(n==2)cout&lt;&lt;2&lt;&lt;endl; else cout&lt;&lt;1&lt;&lt;endl; return 0;} B# B. Farewell Party 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;const int N=100005;int a[N],b[N];int main(){ int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]); a[i]=n-a[i]; } int f=1; for(int i=1;i&lt;=n;i++){ if(b[i]&gt;0)continue; b[i]=f; int count=a[i]-1; for(int j=i+1;j&lt;=n;j++){ if(count==0)break; if(b[j]&gt;0)continue; if(a[j]==a[i]){ b[j]=b[i]; count--; } } if(count&gt;0)f=0; if(f==0)break; f++; } if(f==0)puts(&quot;Impossible&quot;); else{ puts(&quot;Possible&quot;); for(int i=1;i&lt;=n;i++){ printf(&quot;%d &quot;,b[i]); } puts(&quot;&quot;); } return 0;} C# C. Colorful Bricks he found there are k bricks with a color different from the color of the brick on its left. n个方块，m种颜色，存在k个方块与左边相邻方块颜色不同，求涂色方案数. 排列组合问题. 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;const int N=2005;const int MOD=998244353;int Comn[N][N];int Com(int n,int m){ for(int i=0;i&lt;=n;i++){ Comn[i][0]=Comn[i][i]=1; for(int j=1;j&lt;i;j++){ Comn[i][j]=(1ll*Comn[i-1][j]+Comn[i-1][j-1])%MOD; } } return Comn[n][m];}int Qpow(int x,int y){ int ans=1; while(y){ if(y&amp;1)ans=(1ll*ans*x)%MOD; x=(1ll*x*x)%MOD; y&gt;&gt;=1; } return ans;}int main(){ int n,m,k; //cout&lt;&lt;Com(2,1)&lt;&lt;endl; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; //printf(&quot;Com=%d,Qpow=%d\\n&quot;,Com(n-1,k),Qpow(m-1,k)); cout&lt;&lt;(1ll*Com(n-1,k)*m%MOD*Qpow(m-1,k))%MOD&lt;&lt;endl; return 0;} D# D. Maximum Distance E# E. Missing Numbers 依次尝试平方数。long long真是恶心。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;#define check(x) ((long long)(sqrt(x))*(long long)(sqrt(x))==(x))using namespace std;const int N=100005;const long long M=10000000000000ll;long long a[N];int main(){ //freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); //freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); int n; scanf(&quot;%d&quot;,&amp;n); for(int i=2;i&lt;=n;i+=2){ scanf(&quot;%lld&quot;,&amp;a[i]); } long long s=0,k=1,f=1; for(int i=1;i&lt;=n;i+=2){ while(1){ //printf(&quot;when k=%lld,s=%lld,check(%lld)=%d\\n&quot;,k,s,k*k+a[i+1],check(k*k+a[i+1])); if(k*k&gt;s&amp;&amp;check(k*k+a[i+1])){ a[i]=k*k-s; s=k*k+a[i+1]; k++; break; } k++; if(k&gt;1000000){ f=0; break; } } if(f==0)break; } if(f==0)puts(&quot;No&quot;); else{ puts(&quot;Yes&quot;); for(int i=1;i&lt;=n;i++){ printf(&quot;%lld &quot;,a[i]); } puts(&quot;&quot;); } return 0;} F# F. Tricky Interactor G# G. Mergesort Strikes Back H# H. Palindromic Magic","link":"/posts/cf-1081/"},{"title":"C++声明浅析","text":"明天就要考C++了，赶紧复习一下C++。 变量# int a; a是一个整型变量，可以在声明时同时给定初值int a=1;. 其中全局变量若不显示指定初值，会自动初始化为0. 而局部变量若不初始化，值是任意的。 常量# const int a=1; a是一个整型常量，声明时必须给定初值（可以是字面量、常量或者变量），声明后a的值不会改变. 也可写成int const a=1;，两种写法没有区别. 指针# int a=1; int *b; b=&amp;a; b是一个整型指针，指向一个整型变量，b中存储的值为指向整型变量的地址. 无论指针指向的变量是什么类型，指针所占用的内存空间一般是固定的. 注意int* a,b;声明的a是指针，b是变量。 指针的指针（二级指针）# int a; int *b=&amp;a; int **c=&amp;b; c是一个二级整型指针，指向一个整型指针b，b指向整型变量a. 注意不能写成int **c=&amp;&amp;a; 依次类推有三级指针、多级指针. 常量指针（指向常量的指针）# const int c=1; const int d=1; const int *b; b=&amp;c; b=&amp;d; 上面b的声明也可以写成int const *b; 但不能写成const int const *b;. b是一个指向整型常量的指针，可以用整型常量的地址给b复制，b的值可以改变，不能通过*b改变指向常量的值. （但由于b的值可变，*b的值也可能变化） 注意：指向常量的指针说法不一定准确，如下面的声明也是合法的： int a=1; const int *b=&amp;a; 此时，b是一个指向整型变量的指针，a、b的值均可变，但不能通过*b来改变a的值. 常指针（指针常量）# int a=1; int *const b=&amp;a; *b=2; b是一个整型常指针，声明时必须用整型变量的地址赋初值，声明后b的值不可改变，但可以通过*b改变指向变量的值. 指向常量的常指针（常指针常量）# const int a=1; const int *const b=&amp;a; b是一个指向整型常量的常指针，同时具备上述两种特性. 同样可以写成int const *const b=&amp;a;但不存在const int const *const b=&amp;a;的写法. 注：由于指向常量的指针和常指针声明类似（仅仅const位置不同）容易混淆，记录一种（来源网上）的方法记忆. 先忽略类型关键字（如上面的int），然后看const修饰的是谁，谁就不可变. 如const int *p;const修饰的是*p，则*p不可变（实际若p可变的话*p也会变），那么p是指向常量的指针. 如const int * const p;const同时修饰p和*p，则p和*p不可变，那么p是指向常量的常指针. 至于const int const *p;忽略int后两个const重复，显然声明有问题. 引用# int a=1; int &amp;b=a; int &amp;c=b; int *d=new int; int &amp;e=*d; b是一个整型引用，声明时必须初始化，可以用变量，也可以用变量引用、或地址对应变量初始化，但不能用常量初始化. 可以把b看作a的一个别名，对b的操作就是对a的操作，b的内存地址和a的内存地址相同. 引用常常用在函数参数的传递过程中，若是希望能修改参数的值或是减少参数复制带来的开销，一般用引用传参. 引用应该也是通过常指针来实现的. 常引用（常量引用）# int a=1; const int &amp;b=a; b是一个整型常引用，声明时必须初始化，此处用变量初始化，与引用类似，b的内存地址和a的内存地址相同，只不过不能通过b修改a的值，但a的值可以修改（从而b的值也可变），同样可以写成int const &amp;b=a;.（类似于常量指针） const int a=1; const int &amp;b=a; b还可以用常量初始化，此时b的内存地址和a的内存地址相同，但由于a是常量不可变，b的值也不可变.（类似于常指针常量） const int &amp;b=1; b甚至还可以用字面量初始化，此时会隐含创建一个匿名常量，再把b作为匿名常量的引用，b的值显然不可变. 由此就不难理解下面的声明语句。 int a=1; const int &amp;b=a+1; const int &amp;c=a+a; 其中a+1和a+a都可以看作常量（因为隐含创建的变量是匿名的），b、c和a的内存地址都不同，即使a的值改变了，b、c的值也不会变化. 与引用类似，常引用也可用常引用初始化. int a=1; const int &amp;b=a; const int &amp;c=b; 常引用常常用在函数参数的传递过程中，若是希望能减少参数复制带来的开销同时不修改参数的值，一般用常引用传参. 引用常量# int a=1; int &amp; const b=a; 上述写法是错误的，一般编译器会报错，但在VS中可以通过编译，&amp;后的const会被忽略. 因此可以说不存在引用常量. 指针的引用# int *b; int *&amp;d=b; 与引用类似，d可看作是b的别名. 注意不可写成： int a; int *&amp;b=&amp;a; 因为&amp;a是常指针，而b是普通引用，可以通过常指针引用解决这个问题. 常量指针的引用# const int *b; const int *&amp;c=b; 可看作常量指针的别名. 注意c不是指针的常引用，可以通过c更改b的值. 常指针的引用# int a=1; int * const b=&amp;a; int * const &amp;c=b; c是一个常指针引用，类似常指针的别名. 再如指针的引用时提到的问题： int a; int * const &amp;b=&amp;a; 上述写法可以. 常指针常量的引用# int a=1; const int * const b=&amp;a; const int * const &amp;d=b; 类似常指针常量的别名. 常量指针的常引用# 注意到由于常量指针的引用声明时const已经占据了常引用声明时const的位置，那如何声明一个常量指针的常引用？ 先来看常量指针的引用的情况： int a=1; int d=2; const int *b=&amp;a; const int *&amp;c=b; c=&amp;d; 此时可通过c改变b的值，显然c不是常引用. 方法一：typedef# 利用typedef把常量指针包装成一个新的类型，就不会占据const位置了. int a=1; int d=2; const int *b=&amp;a; typedef const int *pci; const pci &amp;c=b; //c=&amp;d; 此时就不能用c改变b的值了，c是常量指针的常引用. 方法二：auto# int a=1; int d=2; const int *b=&amp;a; const auto &amp;c=b; //c=&amp;d; c被自动推断为b类型的常引用，而b是常量指针. 方法三：decltype# int a=1; int d=2; const int *b=&amp;a; const decltype(b) &amp;c=b; //c=&amp;d; 利用decltype(b)获取b的类型. 指针的常引用# 上述方法具有一般性，指针的常引用也可如此声明. 常量的常引用# 常指针的常引用# 常指针常量的常引用# 由于上述三者本身不可变，故声明其对应的常引用没有意义. 可以仿照常量指针的常引用的声明方法进行声明，不会报错. 数组# int a[3]; a是一个含3个整型变量（从a[0]~a[2]）的整型数组，可以在声明时同时初始化，如int a[3]={1,2,3};即表示a[0]=1,a[1]=2,a[2]=3,若初始化的值个数少于数组总元素个数，后面的值会被初始化为0. 当有初始化时，数组个数可以省略，由编译器根据初始化元素自动判断数组大小，如int a[]={1,2,3,4}. 与变量类似，全局数组会自动初始化，局部数组不会，但通过int a[105]={0};即可全部初始化为0. 一般而言，数组申明是若未初始化，需要用常量指定数组大小。但在一些较新的编译器里已经支持（VS会报错）用变量定义数组. 如以下代码不会报错： int n; cin&gt;&gt;n; int a[n]; 但极不推荐这样做，若要使用动态数组可以用new申请空间或是用STL中的vector容器，而且这种用法可能存在潜在的问题. a可以看做是常指针类型（int * const）,a的地址就是数组首地址&amp;a[0]，但数组首地址对应的值为a[0]，a中的值也是数组首地址（a的值与a的地址相同，这一点与指针不同），a+1是&amp;a[1],但要注意a实质为一个数组类型，如sizeof(a)=12，&amp;a+1会跨越一个数组的长度，此时可以看作a的类型为int[3]. 值得一提的是，当数组名作为函数形参时，会被’降维’处理，不再具备int[3]的性质，而彻底变成了int *类型（可以修改，sizeof为指针大小）. 二维数组# int a[2][3]; a是一个含6个整型变量的二维整型数组（从a[0][0]~a[1][2]）,可以在声明时同时初始化，如int a[2][3]={{1,2,3},{4,5,6}};即表示a[0][0]=1,a[0][1]=2,a[0][2]=3,a[1][0]=4,a[1][1]=5,a[1][2]=6，同样，若初始化的值个数少于数组总元素个数，后面的值会被初始化为0. 与一维数组不同，二维数组也可对每行的前面部分初始化，如int a[2][3]={{1,2}, {4}};表示a[0][0]=1,a[0][1]=2,a[0][2]=0,a[1][0]=4,a[1][1]=0,a[1][2]=0.同时还支持线性初始化，如用int a[2][3]={1,2,0,4};初始化结果与上面相同. 但是，初始化时仅能省略第一维的大小，其余维大小必须指明，例如上面的声明语句还可写成int a[][3]={1,2,3,4};，第一维大小被自动判断为2. 二维数组与指针的关系就更加复杂了，仿照一维数组，此时a可以看作是数组常指针int (*const)[3]类型，&amp;a[0][0]=a[0]=&amp;a[0]=a=&amp;a,同样a实质为int[2][3]类型，a+1=&amp;a[1][0],sizeof(a)=24，由此不难理解一些用指针处理数组的方法，如:（n，m为整型常量） int a[n][m]; a[i][j]=*(a[i]+j)=*(*(a+i)+j)=*(*a+i*m+j)=*(a[0]+i*m+j)=a[0][i*m+j]=*(*(&amp;a[0]+i)+j)=*(&amp;a[0][0]+i*m+j) 由此也可以发现，在用指针处理高维数组时，第一维的大小相对而言不那么重要. 一维数组时提到可以用变量作为数组大小申明，二维数组其实也可以，但仍然可能有问题，如下面这个例子： int n=2,m=3; int a[n][m]={1,2,3,4,5,6}; 输出a中元素会发现a[1][0]=a[1][1]=a[1][2]=0，而若第一行改成const int n=2,m=3;就不会有这个问题. 类比一维数组，二维数组在作为函数形参时，也会被’降维’处理，（即使函数参数写成int[2][3],第一维可省略）,不再具备int[2][3]的性质，而彻底变成了int (*)[3]类型（可以修改，sizeof为指针大小）. 常量数组# const int a[3]={1,2,3}; a是一个含3个整型常量的常量数组，声明时必须初始化，但可以初始化前面一部分，如const int a[3]={1,2};剩下的会自动初始化为0，数组大小也可以省略不写. 常用在误差表的处理或简化判断语句。 常量二维数组# const int a[2][3]={1,2,3,4,5,6}; 与二维数组和常量数组具有类似的性质. 指针数组# int *a[3]; 与数组类似，元素为指针类型. 注意此时[]的优先级较高，先与a结合，说明a是一个数组. 指针二维数组# int *a[2][3]; 与指针数组和二维数组有类似的性质. 数组指针（指向一维数组的指针、行指针）# int a[3]={1,2,3}; int (*b)[3]=&amp;a; 数组指针实质为指针，指向一个一维数组. 此时()优先级更高，先与b结合，b是一个指针. 数组指针中数组大小不能省略. 数组常指针# int a[3]={1,2,3}; int (*const b)[3]=&amp;a; 声明时必须初始化，与二维数组名类似. 常数组指针# const int a[3]={1,2,3}; const int (*b)[3]=&amp;a; 常数组常指针# const int a[3]={1,2,3}; const int (* const b)[3]=&amp;a; 二维数组指针# int a[][3]={1,2,3,4,5,6}; int (*b)[2][3]=&amp;a; 同样b是指针，大小均不能省略. 二维数组常指针# int a[2][3]={1,2,3}; int (*const b)[2][3]=&amp;a; 常二维数组常指针# const int a[2][3]={1,2,3,4,5,6}; const int (* const b)[2][3]=&amp;a; 引用数组# 下面语句试图申明元素为引用的数组，会报错. int a[3]={1,2,3}; int &amp;b[3]={a[0],a[1],a[2]}; 因此可以说不存在引用数组. 数组引用# 类比数组指针有: int a[3]={1,2,3}; int (&amp;b)[3]=a; 指针数组引用# int* a[3]; int* (&amp;b)[3]=a; a是指针数组，b是指针数组的引用. 数组指针引用# int a[3]={1,2,3}; int (*b)[3]=&amp;a; int (*&amp;c)[3]=b; a是数组，b是数组指针，c是数组指针的引用. 二维数组引用# int a[2][3]={1,2,3,4,5,6}; int (&amp;b)[2][3]=a; 数组常引用# int a[3]={1,2,3}; const int (&amp;b)[3]=a; 常数组引用# 与数组常引用相同. const int a[3]={1,2,3}; const int (&amp;b)[3]=a; 函数# void func(); func的地址就是函数首地址，（函数首地址对应的值也是函数首地址）func的值也是函数首地址，比数组名更特殊，因此可以对函数名无限次间值运算仍然正确.(***************func)();可以通过编译，而且函数运行正常！ 函数指针# int func(int x){return 0;} int (*pfunc)(int)=func; 与函数名类似，但指针可变，函数名不可变. 指针函数（返回值为指针的函数）# int* func(int x){return nullptr;} 函数常指针# int func(int x){return 0;} int (* const pfunc)(int)=func; 函数引用# int func(int x){return 0;} int (&amp;pfunc)(int)=func; 函数指针数组# int (*pfunc[3])(int); 函数指针数组引用# int (*pfunc[3])(int); int (*(&amp;fun)[3])(int)=pfunc; pfunc是函数指针数组，fun是函数指针数组引用. 引用的引用（右值引用）# 注意并不是说引用的引用又称为右值引用，只是放在一块记录. 在说明引用时，提到可以用引用来初始化，这样也算一种引用的引用，但实质还是原始变量的引用. int a=1; int &amp;b=a; int &amp;c=b; 如c是a的引用的引用. 但下面的代码是错误的:（试图声明c为a引用的引用） int a=1; int &amp;&amp;c=a; &amp;&amp;是用来声明右值引用的，其中涉及到深浅复制、移动构造函数、移动语义，可以参考这篇文章：从4行代码看右值引用 上述都是一些基本的类型申明，事实上还有许多复杂的类型声明，虽然一般不会用到，但理解一下有助于开阔思维。 Keep It Simple &amp; Stupid 下面列举几个较为复杂的例子，可以参考网上的’右左法则’理解这些声明.（先右后左，遇括号反向） 参数为函数指针的函数# int func(int (*)(int)); func是一个函数，返回值为int，有一个参数，该参数是一个指针，指向一个函数，被指向的函数返回值为int，有一个参数int. 返回值为函数指针的函数# int (*fun(int))(int *); fun是一个函数，有一个int型参数，返回值为指针，指向一个函数，被指向的函数返回值为int，有一个int型指针参数. const叠加二级指针# const char *p1; const char * const * const p2=&amp;p1; p1是一个常量指针，p2是一个指向常量指针的常指针常量. 最后用一个声明结束本文，赶紧复习英语. char*const*(*(*tootal())[520])(int **(&amp;&amp;),double *(&amp;)[666],void*&amp;()); Eternity is a very long time, especially towards the end. 永恒是很长的时间，特别是对尽头而言。","link":"/posts/cpp-typedef/"},{"title":"CSS高级实践编程","text":"其实起这个标题还是有点尴尬的，毕竟这次的内容实在算不上什么“高级”，但这就是Web程序设计课程的第三次实验名称，还是按照实验名来发布了。由于Web实验均要求提交HTML文档（当然不可能是Markdown文档），因此就只在这里记录一个正文的链接，内容同样保存在博客内部，但不会在其他地方有链接。 这次实验虽然做的比较匆忙，但总体来说还是达到了我的预期：看着还行。其实仔细测试一下就会发现很多不完善的地方，例如将浏览器窗口缩小后，目录位置就错乱了。这主要是应为我使用了绝对定位。网页的内容大部分都是从平时的课件上照抄下来的，参考价值不是很大。这次只是想记录一下我制作HTML文档的成果。","link":"/posts/css-programming/"},{"title":"Codeforces Round 527 (Div. 3)","text":"被自己菜哭::&gt;_&lt;:: A# 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int t; cin&gt;&gt;t; while(t--){ int n,m; cin&gt;&gt;n&gt;&gt;m; int a=n/m,b=n%m; for(int i=1;i&lt;=a;i++){ for(int i=1;i&lt;=m;i++){ cout&lt;&lt;char('a'+i-1); } } for(int i=1;i&lt;=b;i++){ cout&lt;&lt;char('a'+i-1); } cout&lt;&lt;endl; } return 0;} B# 排序后统计相邻元素差值。 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int a[105];int main(){ int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i]; } sort(a+1,a+1+n); int ans=0; for(int i=1;i&lt;=n;i+=2){ ans+=a[i+1]-a[i]; } cout&lt;&lt;ans&lt;&lt;endl; return 0;} C# 利用两个长度为n-1的串把原串找出来，然后逐个判断。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;using namespace std;char s[205][105];int len[205],ps[205],markp[105],marks[105];int main(){ //freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n; cin&gt;&gt;n; int m=2*n-2; int n1=0,n2=0; for(int i=1;i&lt;=m;i++){ cin&gt;&gt;s[i]; len[i]=strlen(s[i]); if(len[i]==n-1&amp;&amp;n1==0)n1=i; else if(len[i]==n-1&amp;&amp;n2==0)n2=i; } //printf(&quot;n1=%d,n2=%d\\n&quot;,n1,n2); int f2=1; for(int i=1;i&lt;n-1;i++){ if(s[n2][i]!=s[n1][i-1])f2=0; } int count=0; for(int i=1;i&lt;=m;i++){ int ff=1; for(int j=0;j&lt;len[i];j++){ if(s[i][j]!=s[n2][j]){ ff=0; break; } } if(ff)count++; } if(count&lt;n-1)f2=0; //printf(&quot;f2=%d\\n&quot;,f2); char *per,*sur; per=s[n1],sur=s[n2]; if(f2)swap(per,sur); for(int i=0;i&lt;n-1;i++){ s[0][i]=per[i]; } s[0][n-1]=sur[n-2]; len[0]=n; //printf(&quot;s[0]=%s\\n&quot;,s[0]); int cs=0,cp=0; for(int i=1;i&lt;=m;i++){ //prefix int flagp=1; for(int j=0;j&lt;len[i];j++){ if(s[i][j]!=s[0][j]){ flagp=0; break; } } //suffix int flags=1; for(int j=0;j&lt;len[i];j++){ if(s[i][j]!=s[0][j+n-len[i]]){ flags=0; break; } } if(flagp==0){ ps[i]='S'; marks[len[i]]=1; cs++; }else if(flags==0){ ps[i]='P'; markp[len[i]]=1; cp++; }else ps[i]='A'; } for(int i=1;i&lt;=m;i++){ if(cp==n-1)break; if(ps[i]=='A'&amp;&amp;!markp[len[i]]){ ps[i]='P'; cp++; markp[len[i]]=1; } } for(int i=1;i&lt;=m;i++){ if(cs==n-1)break; if(ps[i]=='A'&amp;&amp;!marks[len[i]]){ ps[i]='S'; marks[len[i]]=1; cs++; } } for(int i=1;i&lt;=m;i++){ cout&lt;&lt;char(ps[i]); } cout&lt;&lt;endl; return 0;} D1# D2# E# F#","link":"/posts/cf-1092/"},{"title":"Educational Codeforces Round 56","text":"题目 A# 12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int t; cin&gt;&gt;t; while(t--){ int n; cin&gt;&gt;n; if(n&amp;1)cout&lt;&lt;(n-3)/2+1&lt;&lt;endl; else cout&lt;&lt;n/2&lt;&lt;endl; } return 0;} B# 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int n; cin&gt;&gt;n; while(n--){ char s[1005]; int c[305]={0}; cin&gt;&gt;s; int len=strlen(s); for(int i=0;i&lt;len;i++){ c[s[i]]++; } int count=0; for(int i=0;i&lt;305;i++){ if(c[i]&gt;0)count++; } if(count==1)cout&lt;&lt;&quot;-1\\n&quot;; else{ for(int i=0;i&lt;305;i++){ if(c[i]&gt;0){ for(int j=0;j&lt;c[i];j++){ cout&lt;&lt;char(i); } } } cout&lt;&lt;endl; } } return 0;} C# 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;const int N=200005;const long long INF=(long long)(1e18+1);long long a[N];int main(){ //cout&lt;&lt;(long long)1e18&lt;&lt;endl; //freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); //freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); int n; cin&gt;&gt;n; int n2=n/2; for(int i=1;i&lt;=n2;i++){ cin&gt;&gt;a[n-i+1]; //printf(&quot;a[%d]=%lld\\n&quot;,n-i+1,a[n-i+1]); } a[0]=-1;a[n+1]=INF; for(int i=1;i&lt;=n2;i++){ if(a[i]&gt;=a[i-1]&amp;&amp;a[n-i+1]&lt;=a[n-i+2])continue; long long temp=max(a[i-1]-a[i],a[n-i+1]-a[n-i+2]); a[i]+=temp; a[n-i+1]-=temp; if(a[i]&gt;a[n-i+1])swap(a[i],a[n-i+1]); } for(int i=1;i&lt;=n;i++){ cout&lt;&lt;a[i]&lt;&lt;' '; } cout&lt;&lt;endl; return 0;} D# memset改成手动清零 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;const int N=300005;const int M=998244353;vector&lt;int&gt; G[N];int vis[N],col[N],deg[N];int cnt[2];int kpow(int x,int y){ int ans=1; while(y){ if(y&amp;1)ans=(1ll*ans*x)%M; x=(1ll*x*x)%M; y&gt;&gt;=1; } return ans;}int dfs(int x,int p=0){ //printf(&quot;when dfs(%d):\\n&quot;,x); vis[x]=1; col[x]=p; cnt[p]++; for(auto i:G[x]){ int f=1; if(vis[i]&amp;&amp;col[i]==col[x])return 0; if(!vis[i])f=dfs(i,!p); if(f==0)return 0; } return 1;}int main(){ //freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); //freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); int t; scanf(&quot;%d&quot;,&amp;t); while(t--){ int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++){ G[i].clear(); vis[i]=col[i]=deg[i]=0; } //memset(vis,0,sizeof(vis)); //memset(col,0,sizeof(col)); //memset(deg,0,sizeof(deg)); for(int i=1;i&lt;=m;i++){ int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); G[u].push_back(v); G[v].push_back(u); deg[u]++,deg[v]++; } int f=1,ans=1; for(int i=1;i&lt;=n;i++){ if(deg[i]==0){ ans=(ans*3ll)%M; continue; } if(!vis[i]){ cnt[0]=cnt[1]=0; if(!dfs(i))f=0; else{ //printf(&quot;count[0]=%d,count[1]=%d\\n&quot;,cnt[0],cnt[1]); ans=(1ll*ans*(kpow(2,cnt[0])+kpow(2,cnt[1])))%M; } } if(f==0)break; } if(f==0)puts(&quot;0&quot;); else printf(&quot;%d\\n&quot;,ans); } return 0;} E# F# G#","link":"/posts/cf-1093/"},{"title":"Hello 你好","text":"欢迎来到头头博客！ Welcome to tootal blog! 这篇文章主要用于测试。 Markdown# Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 Markdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。 以下文字来自《女王的教室》 读书学习的意义究竟是什么？ 读书，不是非做不可的事，而是想要去做的事。今后你们会碰到很多很多你们不知道的、不能理解的事情，也会碰到很多你们觉得美好的、开心的、不可思议的事物。这个时候，作为一个人自然地想了解更多、学习更多。失去好奇心和求知欲的人，不能称为人，连畜生都不如。连自己生存的这个世界都不想了解，还能做什么呢？不论如何学习，只要人活着，就有很多不懂的东西。这个世界上有很多大人好像什么都懂的样子，那都是骗人的。进了好大学也好，进了好公司也好，如果有活到老学到老的想法，那就有无限的可能性。失去好奇心的那一瞬间，人就死了。读书，不是为了考试，而是为了成为出色的大人。 开始的碎碎念# 20181226# 重新更改本文内容。 删去了一些无意义的内容。 今天上午考线性代数期末考试，深深感受到了被爆算支配的恐惧，不过有四道大题是原题还是很开心的。 明天就要考C++了，赶紧复习一下C++。 20181225# wget命令记录 wget -r -p -np -k [URL] -r 递归下载 -p 下载所有文件 -np 不进入父目录 -k 转换成本地链接 –user-agent=“wget” -w 1 vmware共享文件夹目录 /mnt/hgfs/swapfile/ 20181224# C++类的前置声明 C++前置声明和头文件 20181223# Qt 虽然快期末考了但静不下心来一直复习，MFC觉得太复杂了，就先研究了一下QT，感觉还不错。 链接： Qt下载 qt开源社区 Qt好书推荐 20181215# 重新更改本文布局。 这篇改成折腾过程中杂事随笔记录，以日期为标题分割，按日期倒序排列。 更改hello你好博文布局。 本地source改用vnote管理 用微博做图床。 20181208# 在基本完成博客的部署后。 我觉得应该在前面写点什么。 是啊。写点什么呢？ 都8102年了，谁还看博客啊？ 虽然现在自媒体公众号满地走。 虽然我也创建了一个公众号。 但我觉得一些技术性的文章 比如代码啊。放在公众号上很丑 各种博客网站啊有广告也很丑 于是花了一天的时间自己搞了一个网站。 （也许这上面什么都不会发） bye！ 初始的自我介绍# 博主 tootal 曾经的OIer 现在的ACMer Minecraft原版生存玩家 魔方CFOP学习者 Jump, Just Run！ 我是博主tootal，计算机技术爱好者。 坚持写博客是为了记录、整理、分享。虽然我写的不好，但反正也没人看总会有进步的。 如果有任何问题，可以通过邮箱联系我：tootal@yeah.net","link":"/posts/hello-welcome/"},{"title":"LeetCode链表与二叉树模板总结","text":"链表和二叉树是非常经典的数据结构，许多算法都是基于这两个数据结构之上的。最近刷了不少LeetCode上面相关的题目，发现这两种数据结构由于没有适当的输出函数或是表示形式，难以在本地进行调试，因此就想写一个关于链表与二叉树的相关模板。 模板基于LeetCode上的结构体定义，使用C++语言编写，支持链表和二叉树的创建与输出。 单链表# 结构体定义# 以LeetCode第二题两数相加为例，代码模板中给出了单链表的结构体定义： 12345678// 单链表定义struct ListNode { int val; ListNode *next; ListNode() : val(0), next(nullptr) {} ListNode(int x) : val(x), next(nullptr) {} ListNode(int x, ListNode *next) : val(x), next(next) {}}; 表示形式# 链表由于是线性结构，因此表示形式比较简单。采用3 -&gt; 2 -&gt; 1的形式来表示单链表。 创建单链表# 通常来说创建上面的链表需要写如下代码： 1ListNode *root = new ListNode(3, new ListNode(2, new ListNode(1))); 非常不直观，而且当结点数较多时编码麻烦，容易出错。采用C++11提供的可变参数模板技术编写create_list函数来创建一个单链表，目标是简化创建链表的过程。例如上面的代码块可以写成： 1ListNode *root = create_list(3, 2, 1); create_list的源代码如下： 12345678910// 创建空链表ListNode *create_list() { return nullptr; }// 创建单链表template &lt;typename T, typename... Args&gt;ListNode *create_list(const T &amp;first, const Args &amp;...rest) { static_assert(std::is_same&lt;T, int&gt;::value); ListNode *head = new ListNode(first); head-&gt;next = create_list(rest...); return head;} 输出单链表# 输出的本质就是转换为字符串，因此先重载了to_string函数来将单链表转换为字符串。实现代码如下： 123456789string to_string(ListNode *head) { string res; while (head) { res.append(to_string(head-&gt;val)); head = head-&gt;next; if (head) res.append(&quot; -&gt; &quot;); } return res;} 然后通过重载输出流的&lt;&lt;运算符即可用标准输出语法来进行输出了。 1234// 输出单链表（指针形式）ostream &amp;operator&lt;&lt;(ostream &amp;out, ListNode *head) { return (out &lt;&lt; to_string(head));} 使用示例# 以两数相加这题为例，在编写完成类的成员函数之后，可以添加一个简单的main函数来进行测试： 1234567int main() { cout &lt;&lt; Solution().addTwoNumbers( create_list(2,4,3), create_list(5,6,4) ) &lt;&lt; endl; return 0;} 输出结果： 17 -&gt; 0 -&gt; 8 二叉树# 结构体定义# 以翻转二叉树为例，代码模板中给出了二叉树的结构体定义： 12345678910// 二叉树结点定义struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}}; 表示形式# 想为二叉树找到一种方便易用的表示形式不是那么容易。不同于链表，二叉树并非线性结构。一开始的想法是使用特殊字符在控制台以文本形式直接绘制二叉树，如下所示： 12345 1 ┌───┴───┐ 2 3┌─┴─┐ ┌─┴─┐4 5 6 7 由于不同系统的字体不同，因此上面的显示可能出现乱码的情况，实际的效果可以参考下图所示： 这确实非常直观，但给解析带来了非常大的难度，而且不方便输入。实际需要的是一种能快速进行转换的、线性的表示形式。参考算法竞赛中的树结构的输入形式，通常是指定结点数以及每个节点的左右孩子，例如上面的二叉树可以表示成： 1234567871 2 32 4 53 6 74 -1 -15 -1 -16 -1 -17 -1 -1 这样解析和输入都很方便，缺点就是不够直观。最终选择了一种括号表示法，上面的二叉树可以表示成： 11 (2 4 5) (3 6 7) 总体还是非常容易理解的，也比较直观，该表示法详细定义如下： 二叉树T可以按如下方式表示： 若T为空树，可表示为()。 若T只包含一个节点，则可表示为一个数字。 设T的左子树表示为L，右子树表示为R，T的值为N，则T可表示为(N L R)。 最终结果的最外层括号可以省略。 一个更复杂的例子如下图所示： 它可以表示成：3 (5 6 (2 7 4)) (1 0 8)。 创建二叉树# 明确了表示形式后，下一个目标就是实现从字符串解析出二叉树结构。这里采用了编译原理中的递归下降子程序的方法进行解析，实现代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 创建一个空二叉树（返回空指针）TreeNode *create_tree() { return nullptr; }// 从字符串创建一颗二叉树// 格式类似于：1 (2 3 4) (5 () 6)TreeNode *create_tree(const std::string &amp;str) { string s(str); if (s.front() != '(') { s.insert(s.begin(), '('); s.insert(s.end(), ')'); } size_t n = s.length(); auto expect_int = [&amp;](size_t &amp;i) { int ans = 0; while (i &lt; n &amp;&amp; s[i] == ' ') i++; if (i == n || !isdigit(s[i])) return -1; while (i &lt; n &amp;&amp; isdigit(s[i])) { ans = ans * 10 + s[i] - '0'; i++; } return ans; }; std::function&lt;TreeNode *(size_t &amp;)&gt; expect_node = [&amp;](size_t &amp;i) { while (i &lt; n &amp;&amp; s[i] != '(' &amp;&amp; !isdigit(s[i])) i++; TreeNode *node = nullptr; bool flag = false; if (i &lt; n &amp;&amp; s[i] == '(') { flag = true; i++; } int val = expect_int(i); if (val &gt;= 0) { node = new TreeNode(val); if (flag) { node-&gt;left = expect_node(i); node-&gt;right = expect_node(i); } } if (flag &amp;&amp; i &lt; n &amp;&amp; s[i] == ')') i++; return node; }; size_t i = 0; return expect_node(i);} 算法过程如下，首先尝试在最外层添加括号，将整个表达式看作一个非终结符（节点），对应的子程序为expect_node。flag用于记录是否存在括号，接着尝试匹配终结符（数字），对应于子程序expect_int，它尝试从当前位置解析出一个数字，若不可行，则返回-1。若存在括号的话，就递归解析左右子节点。 输出二叉树# 与单链表类似，同样重载to_string来将二叉树转换为字符串再进行输出，实现代码如下： 1234567// 将二叉树转换为字符串形式string to_string(TreeNode *root) { if (!root) return &quot;()&quot;; if (!root-&gt;left &amp;&amp; !root-&gt;right) return to_string(root-&gt;val); return &quot;(&quot; + to_string(root-&gt;val) + &quot; &quot; + to_string(root-&gt;left) + &quot; &quot; + to_string(root-&gt;right) + &quot;)&quot;;} 即递归地将当前节点以及左右子树转换为字符串形式。同样重载&lt;&lt;运算符以支持标准流输出： 1234// 输出二叉树ostream &amp;operator&lt;&lt;(ostream &amp;out, TreeNode *root) { return (out &lt;&lt; to_string(root));} 使用示例# 以翻转二叉树这题为例，可以使用如下代码进行测试： 123456int main() { cout &lt;&lt; Solution().invertTree( create_tree(&quot;4 (2 1 3) (7 6 9)&quot;) ) &lt;&lt; endl; return 0;} 输出结果如下所示： 1(4 (7 9 6) (2 3 1)) 总结# 将上面的所有代码以及对STL容器的输出支持整合成单个文件，使用时只要包含leetcode.h头文件即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#ifndef LEETCODE_H#define LEETCODE_H// LeetCode 刷题模板 by tootal 20210331#include &lt;bits/stdc++.h&gt;using namespace std;// 单链表定义struct ListNode { int val; ListNode *next; ListNode() : val(0), next(nullptr) {} ListNode(int x) : val(x), next(nullptr) {} ListNode(int x, ListNode *next) : val(x), next(next) {}};// 创建空链表ListNode *create_list() { return nullptr; }// 创建单链表template &lt;typename T, typename... Args&gt;ListNode *create_list(const T &amp;first, const Args &amp;...rest) { static_assert(std::is_same&lt;T, int&gt;::value); ListNode *head = new ListNode(first); head-&gt;next = create_list(rest...); return head;}// 二叉树结点定义struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}};// 创建一个空二叉树（返回空指针）TreeNode *create_tree() { return nullptr; }// 从字符串创建一颗二叉树// 格式类似于：1 (2 3 4) (5 () 6)TreeNode *create_tree(const std::string &amp;str) { string s(str); if (s.front() != '(') { s.insert(s.begin(), '('); s.insert(s.end(), ')'); } size_t n = s.length(); auto expect_int = [&amp;](size_t &amp;i) { int ans = 0; while (i &lt; n &amp;&amp; s[i] == ' ') i++; if (i == n || !isdigit(s[i])) return -1; while (i &lt; n &amp;&amp; isdigit(s[i])) { ans = ans * 10 + s[i] - '0'; i++; } return ans; }; std::function&lt;TreeNode *(size_t &amp;)&gt; expect_node = [&amp;](size_t &amp;i) { while (i &lt; n &amp;&amp; s[i] != '(' &amp;&amp; !isdigit(s[i])) i++; TreeNode *node = nullptr; bool flag = false; if (i &lt; n &amp;&amp; s[i] == '(') { flag = true; i++; } int val = expect_int(i); if (val &gt;= 0) { node = new TreeNode(val); if (flag) { node-&gt;left = expect_node(i); node-&gt;right = expect_node(i); } } if (flag &amp;&amp; i &lt; n &amp;&amp; s[i] == ')') i++; return node; }; size_t i = 0; return expect_node(i);}// to_string系列函数定义string to_string(bool x);string to_string(char c);string to_string(const char *s);string to_string(string s);template &lt;typename T1, typename T2&gt;string to_string(pair&lt;T1, T2&gt; x);template &lt;typename T&gt;string to_string(vector&lt;T&gt; x);template &lt;typename T&gt;string to_string(stack&lt;T&gt; x);template &lt;typename T&gt;string to_string(queue&lt;T&gt; x);string to_string(ListNode *head);string to_string(TreeNode *root);// to_string系列函数实现string to_string(bool x) { return x ? &quot;true&quot; : &quot;false&quot;; }string to_string(char c) { return &quot;\\'&quot; + string(1, c) + &quot;\\'&quot;; }string to_string(const char *s) { return &quot;\\&quot;&quot; + string(s) + &quot;\\&quot;&quot;; }string to_string(string s) { return &quot;\\&quot;&quot; + s + &quot;\\&quot;&quot;; }template &lt;typename T1, typename T2&gt;string to_string(pair&lt;T1, T2&gt; x) { return &quot;(&quot; + to_string(x.first) + &quot;, &quot; + to_string(x.second) + &quot;)&quot;;}template &lt;typename T&gt;string to_string(vector&lt;T&gt; x) { string res = &quot;{&quot;; bool first = true; for (auto &amp;&amp;i : x) { if (first) { first = false; } else { res += &quot;, &quot;; } res += to_string(i); } return res + &quot;}&quot;;}// 将栈转换为字符串表示，形式如下：// 栈底 栈顶// | |// [1, 3, 2, 4)template &lt;typename T&gt;string to_string(stack&lt;T&gt; x) { string res; bool first = true; while (!x.empty()) { if (first) { first = false; } else { res = &quot;, &quot; + res; } res = to_string(x.top()) + res; x.pop(); } return &quot;[&quot; + res + &quot;)&quot;;}// 将队列转换为字符串表示，形式如下：// 队首 队尾// | |// (1, 3, 2, 4)template &lt;typename T&gt;string to_string(queue&lt;T&gt; x) { string res; bool first = true; while (!x.empty()) { if (first) { first = false; } else { res = res + &quot;, &quot;; } res = res + to_string(x.front()); x.pop(); } return &quot;(&quot; + res + &quot;)&quot;;}string to_string(ListNode *head) { string res; while (head) { res.append(to_string(head-&gt;val)); head = head-&gt;next; if (head) res.append(&quot; -&gt; &quot;); } return res;}// 将二叉树转换为字符串形式string to_string(TreeNode *root) { if (!root) return &quot;()&quot;; if (!root-&gt;left &amp;&amp; !root-&gt;right) return to_string(root-&gt;val); return &quot;(&quot; + to_string(root-&gt;val) + &quot; &quot; + to_string(root-&gt;left) + &quot; &quot; + to_string(root-&gt;right) + &quot;)&quot;;}// 输出单链表（指针形式）std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, ListNode *head) { return (out &lt;&lt; to_string(head));}// 输出单链表（引用形式）std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, ListNode &amp;head) { return (out &lt;&lt; &amp;head);}// 输出二叉树std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, TreeNode *root) { return (out &lt;&lt; to_string(root));}template &lt;typename T&gt;ostream &amp;operator&lt;&lt;(ostream &amp;out, vector&lt;T&gt; x) { return (out &lt;&lt; to_string(x));}template &lt;typename T&gt;ostream &amp;operator&lt;&lt;(ostream &amp;out, stack&lt;T&gt; x) { return (out &lt;&lt; to_string(x));}template &lt;typename T&gt;ostream &amp;operator&lt;&lt;(ostream &amp;out, queue&lt;T&gt; x) { return (out &lt;&lt; to_string(x));}template &lt;typename T1, typename T2&gt;ostream &amp;operator&lt;&lt;(ostream &amp;out, pair&lt;T1, T2&gt; x) { return (out &lt;&lt; to_string(x));}// 使用示例int showcase() { // 单链表 ListNode *mylist = create_list(5, 4, 3, 2, 1); cout &lt;&lt; mylist &lt;&lt; '\\n'; // 二叉树 TreeNode *mytree = create_tree(&quot;1 (2 3 4) (5 () 6)&quot;); cout &lt;&lt; mytree &lt;&lt; '\\n'; // pair cout &lt;&lt; make_pair('a', 1) &lt;&lt; '\\n'; cout &lt;&lt; pair{1, pair{'a', &quot;123&quot;}} &lt;&lt; '\\n'; cout &lt;&lt; make_pair(create_list(3, 2), 123) &lt;&lt; '\\n'; // vector cout &lt;&lt; vector{1, 2, 3, 4, 5} &lt;&lt; '\\n'; cout &lt;&lt; vector{&quot;abc&quot;, &quot;123&quot;} &lt;&lt; '\\n'; cout &lt;&lt; vector{true, false, false} &lt;&lt; '\\n'; cout &lt;&lt; vector{'1', '2', '3'} &lt;&lt; '\\n'; // stack stack&lt;int&gt; st; for (int i = 0; i &lt; 5; i++) st.push(i); cout &lt;&lt; st &lt;&lt; '\\n'; // queue queue&lt;int&gt; que; for (int i = 0; i &lt; 5; i++) que.push(i); cout &lt;&lt; que &lt;&lt; '\\n'; return 0;}#endif // LEETCODE_H","link":"/posts/leetcode-template/"},{"title":"Minecraft Server Tootal World","text":"服务器已不再维护，以下信息可能已过时。 版本：1.13.2 地址：120.79.171.171:23333 模式：原版生存 难度：4 序言# 这篇博客主要用于记录Minecraft服务器相关事项。 服务器可能稳定，可能不稳定，一般24小时开放。 该服主要用于探索Minecraft技术与服务器相关技术。 2018年12月14日开服 20181214# screen命令：# 新建窗口 screen -S name 查看窗口列表 screen -ls 打开窗口 screen -r id 暂时退出窗口 Ctrl+A D 退出窗口 exit 服务端运行命令# java -Xmx1024M -Xms1024M -jar minecraft_server.jar nogui 20190125# 压缩文件命令# tar -zcvf 打包后生成的文件名全路径 要打包的目录 sftp文件传输命令# bye finish your SFTP session cd change your remote working directory clear clear screen exit finish your SFTP session explore explore your local directory get download a file from the server to your local machine help give help lcd change and/or print local working directory lls list contents of a local directory lpwd print your local working directory ls list contents of a remote directory mkdir create a directory on the remote server mv move or rename a file on the remote server put upload a file from your local machine to the server pwd print your remote working directory quit finish your SFTP session rename move or rename a file on the remote server rm delete a file rmdir remove a directory on the remote server","link":"/posts/mc-server/"},{"title":"hello world","text":"最近上午下午都在搞ACM，晚上实在不想做题，就打起了其他编程语言的主意。虽然编程的水平不能用通晓的编程语言数目来衡量，但多接触一些其他类型的编程语言也可以增长见识，开阔视野，了解一下计算机语言的发展进程。 初步打算是利用helloworld这个著名的程序来体验一下，各种语言的helloworld程序也比较容易查询，更难的其实是编程环境的配置。 工具软件# 编辑器：# SublimeText3，通过更改SublimeText3中的build系统实现多种语言的快速编译。 编译器：# 目前实现的有：（点击可跳转到实现部分） C、C++、Pascal、Markdown、LaTeX、Html、JavaScript、PHP、Java、Python、Batch、Shell、R、Ruby、Perl、Lua、Ada、Fortran、Lisp C 和 C++ ：mingw-w64 mingw-w64下载链接 HTML：任何网页浏览器即可打开。 Firefox 火狐浏览器 JAVA：jdk和jre，jre为运行环境，jdk为开发环境 Java SE Runtime Environment 8 Downloads Java SE Development Kit 8 Downloads 点击Accept License Agreement后即可下载。 Markdown：找单独的渲染器实在麻烦，采用SublimeText3插件运行 编辑：MarkdownEditing 预览（转换为Html）：OmniMarkupPreviewer LaTeX：texlive Acquiring TeX Live as an ISO image Pascal：Free Pascal fpc-3.0.4.i386-win32.exe Python：Python2和Python3 Python 3.7.2 Python 2.7.15 Windows x86-64 MSI installer Batch：cmd windows系统自带 Shell：git bash Git for Windows (2.20.1) 64-bit version JavaScript：Node.js nodejs LTS10.15.0 长期支持版 Fortran：G95 compiler g95-Mingw_2012120 Ada：Mingw gnatlink（C++安装的即可编译） Lua：Lua for Windows Lua for Windows v5.1.5-52 Released Ruby： RubyInstallers Ruby+Devkit 2.5.3-1 (x64) Perl：Strawberry Perl Strawberry Perl 5.28.1.1 (64bit) PHP：为了方便使用了wnmp安装包 Windows, Nginx, MariaDB &amp; PHP(Wnmp) R R-3.5.2 for Windows (32/64 bit) Lisp： CLisp CLISP - an ANSI Common Lisp 实现# 能实现读入功能的语言就实现读入一个整数n，输出n行hello world!，其余就展示hello world!。 命令的执行一般都需要把可执行文件添加到环境变量PATH中。 C# 非常常见，使用广泛，能进行底层开发，操作系统内核基本都是用C语言写的。C语言接近汇编，可以通过指针操控内存，因此速度非常快，可移植性也好。缺点在于初学往往不知道学了能干嘛，很难用C语言写出一个漂亮的程序界面，但用来学习算法和数据结构非常好。 hello.c 123456789#include &lt;stdio.h&gt; int main(){ int i,n; scanf(&quot;%d&quot;,&amp;n); for(i=0;i&lt;n;i++){ printf(&quot;hello world!\\n&quot;); } return 0; } 编译运行命令：gcc hello.c -o hello &amp; hello C++# C语言的一个超集，在C语言的基础上添加了许多功能，最主要的就是面向对象的支持，功能繁杂全面。学习C++有一定难度，但C++在编程语言中非常有代表性。这也是我目前唯一比较了解的编程语言。（C++最强，不接受反驳） hello.cpp 12345678910#include &lt;iostream&gt; using namespace std; int main(){ int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++){ cout&lt;&lt;&quot;hello world!&quot;&lt;&lt;endl; } return 0; } 编译运行命令：g++ hello.c -o hello &amp; hello Pascal# 我第一个学习的语言，当时用的是Turbo Pascal。Pascal的主要特点就是结构比较严谨，Pascal主要是一个教学向的语言，或许由于C等语言的流行或是其他一些原因，已经很少有人用了。 hello.pas 12345678910program hello; var i,n:integer; begin readln(n); for i:=1 to n do begin writeln('hello world!'); end; end. 编译运行命令：fpc hello.pas &amp; hello Markdown# 一种非常简单的标记语言，常用在博客，笔记，留言，帮助文档中，可以用少量的语法来进行文字排版标记，这篇博客也是用Markdown写的。我认为Markdown主要是用来简化html的繁琐标记，使得可读性更强。 hello.md 1# hello world LaTeX# 专业的排版系统，尤其是对于复杂的数学公式，使用也很广泛，学术论文排版经常用到。 hello.tex 1234\\documentclass{article} \\begin{document} hello world! \\end{document} Html# 超文本标记语言，一般的网页所呈现的效果就是浏览器渲染html文件形成的。 hello.html 123456789&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;hello&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello world! &lt;/body&gt; &lt;/html&gt; 用浏览器打开即可。 JavaScript# 网络脚本语言，一般内嵌在html里用来实现网页的动态内容，也可单独执行。常常用来写网页脚本，一般运行在浏览器里。这里利用nodejs直接运行。 hello.js 1234567process.stdin.on('readable', () =&gt; { n=process.stdin.read(); for(var i=1;i&lt;=n;i++){ console.log(&quot;hello world!&quot;); if(i==n)process.stdin.emit('end'); } }); 运行命令：node hello.js PHP# 同样是脚本语言，不过一般运行在服务器，许多入侵服务器都是利用的PHP语言的漏洞，比如一句话木马：&lt;?php @eval($_POST[value]);?&gt; hello.php 123456&lt;?php $n=fgets(STDIN); for($i=0;$i&lt;$n;$i++){ echo &quot;hello world!\\n&quot;; } ?&gt; 运行命令：php hello.php Java# 许多企业用的开发语言，C++改造而来，更强化了面向对象的概念，C++实质还是和C一样，用函数组织程序，而Java直接改用对象组织程序。 hello.java 12345678910import java.util.Scanner; public class hello{ public static void main(String[] args){ Scanner input=new Scanner(System.in); int n=input.nextInt(); for(int i=0;i&lt;n;i++){ System.out.println(&quot;hello world!&quot;); } } } 编译运行命令：javac hello.java &amp; java hello Python# 非常流行的一种编程语言，简单易学又功能强大，可供调用的包很多。因此往往很短的代码就能实现很高级的功能。但我感觉Python不利于理解程序底层原理，而且运行速度慢，但确实很实用。目前我有时用Python写一写数据生成器来对拍（主要是其他高级的功能也不会）。 hello.py 123n=int(input()) for i in range(n): print('hello world!') 运行命令：python hello.py Batch# 其实就是windows下的批处理文件，功能虽说比不上C等编程语言，但用来处理windows相关的问题非常好用，如删除文件夹内所有exe文件：del /s *.exe,从文件输入输出：program.exe &lt; input.txt &gt; output.txt。目前偶尔用来写对拍程序。 hello.bat 123@echo off set /p n= for /L %%i in (1,1,%n%) do echo hello world! 运行命令：hello.bat Shell# linux下的批处理，常用的解释器有bash，由于在windows下运行，就不加#!/bin/bash了。 hello.sh 12345read n for((i=1;i&lt;=$n;i++)); do echo &quot;hello world!&quot; done 运行命令：bash hello.sh R# 多用于统计分析绘图。由于一些其妙的问题，读入只能暂时先放在源代码里了。 hello.r 1234567n&lt;-scan(what=integer(0)) 5 for(i in 1:n){ cat('hello world!\\n') } 运行命令：rscript hello.r Ruby# 完全面向对象的脚本语言。 hello.ruby 1234n=gets.to_i for i in 1..n puts &quot;hello world&quot; end 运行命令：ruby hello.ruby Perl# 特点是内部集成了正则表达式，想来擅长字符串处理？ hello.pl 1234$n=&lt;STDIN&gt;; for($i=1;$i&lt;=$n;$i++){ print &quot;hello world!\\n&quot;; } 运行命令：perl hello.pl Lua# 速度快、小巧的脚本语言，很容易嵌入其他语言中使用。 hello.lua 1234n=io.read(&quot;*n&quot;) for i=1,n do print(&quot;hello world!&quot;) end 运行命令：lua hello.lua Ada# 第一次听说Ada是在一场CTF比赛中把最佳女生奖称为Ada奖。这才知道世界上第一位程序员是Ada Lovelace，而且是女性。以后Ada就是我女神 为了纪念她，美国国防部花费巨资研制出用于军事系统开发的Ada语言，据称是迄今为止最复杂，最完备的软件工具。 资料实在缺乏，故没有写读入。 Ada Reference hello.adb 123456with Ada.Text_IO; use Ada.Text_IO; procedure hello is begin Put_Line(&quot;hello world!&quot;); end hello; 编译运行命令：gnatmake hello.adb &amp; hello Fortran# 世界上第一种高级编程语言，至今仍然活跃在科学计算等领域中。 采用古老的固定格式写法，空六格真是经典。 hello.for 注意代码前有6个半角空格，这里为了显示用了3个全角空格。 123456 PROGRAM HELLO READ *,n DO i=1,n WRITE(*,'(A)') &quot;hello world!&quot; END DO END PROGRAM HELLO 编译运行命令：gfortran hello.for -o hello &amp; hello Lisp# 超奇妙古怪古老神秘自由非凡的一种语言，貌似用在人工智能领域。 hello.lisp 1234567(defun hello () (let (n (read)) (loop for i from 1 to n (print(&quot;hello world!&quot;)) ) ) 放到最后就是压轴的。 其实是还没搞好编译运行问题","link":"/posts/hello-world/"},{"title":"《高级语言程序设计C++（一）》样卷","text":"答案不一定正确，水平有限。 仅用于自己记录整理。 一. 单项选择题# ADBAB DCCAD DABBD CDBDB 注：13题AB选项均错误，但个人觉得B错的更明显。 二．分析程序，写输出结果# 12345621310 123456i=0 s=0i=1 s=1i=2 s=3i=3 s=5i=4 s=7 123t1=200,*t2=50,*rt=200c=200,p=200,*q=50 按理应该是*p=200… 123aafcfdbd 1234561 2 0 0 00 3 4 0 00 0 5 6 00 0 0 7 80 0 0 0 9 1234##****###******* 三．根据程序功能填空# 123(1) n % 10(2) n &gt;= 10 或 n/10 != 0(3) n / 10 12345(4) pa[j] = &amp;classOne[j] (5) pa[j+1]-&gt;score &lt; pa[j]-&gt;score(6) temp = pa[j+1](7) pa[j+1] = pa[j](8) pa[j] = temp 题意有点混乱。。 3. 12345(9) head==NULL(10) s-&gt;data &lt; head-&gt;data(11) q-&gt;next = s(12) s-&gt;next = p(13) p = head 四．程序设计# 1.(1) 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;int main(){ int a[3][4],b[3][4]; for(int i=0;i&lt;3;i++){ for(int j=0;j&lt;4;j++){ cin&gt;&gt;a[i][j]; } } for(int i=0;i&lt;3;i++){ for(int j=0;j&lt;4;j++){ cin&gt;&gt;b[i][j]; } } int count=0; for(int i=0;i&lt;3;i++){ for(int j=0;j&lt;4;j++){ if(a[i][j]==b[i][j])count++; } } cout&lt;&lt;count&lt;&lt;endl; return 0;} (2) 12345678910int int_to_str(int num,char *str){ if(num&lt;10){ str[0]=num+'0'; return 1; } int count=int_to_str(num/10,str); str[count]=num%10+'0'; return count+1;} 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;int isPrime(int x){ for(int i=2;i&lt;int(sqrt(x))+1;i++){ if(x%i==0)return 0; } return 1;}int main(){ int n; cin&gt;&gt;n; int *f=new int[n]; f[0]=0,f[1]=1; for(int i=2;i&lt;n;i++){ f[i]=f[i-1]+f[i-2]; } int count=0; for(int i=0;i&lt;n;i++){ if(isPrime(f[i])){ count++; cout&lt;&lt;setw(10)&lt;&lt;f[i]; if(count%5==0)cout&lt;&lt;endl; } } return 0;}","link":"/posts/cppprograming-test1/"},{"title":"三角函数和差化积、积化和差公式推导记忆","text":"三角函数的和差化积和积化和差公式在求积分和极限时经常出现，但公式又种类繁多，不便记忆。在此记录公式的推导过程，以便日后回顾。 和差化积# 核心代换过程 $$ \\begin{cases} \\alpha = \\frac{\\alpha+\\beta}{2}+\\frac{\\alpha-\\beta}{2}\\\\ \\beta = \\frac{\\alpha+\\beta}{2}-\\frac{\\alpha-\\beta}{2}\\\\ \\end{cases} $$ 由此即可推导出所有和差化积公式，例如： $$ \\begin{align} &\\quad\\ \\cos\\alpha-\\cos\\beta\\\\ &=\\cos(\\frac{\\alpha+\\beta}{2}+\\frac{\\alpha-\\beta}{2})-\\cos(\\frac{\\alpha+\\beta}{2}-\\frac{\\alpha-\\beta}{2})\\\\ &=\\cos(\\frac{\\alpha+\\beta}{2})\\cos(\\frac{\\alpha-\\beta}{2})-\\sin(\\frac{\\alpha+\\beta}{2})\\sin(\\frac{\\alpha-\\beta}{2})-\\cos(\\frac{\\alpha+\\beta}{2})\\cos(\\frac{\\alpha-\\beta}{2})-\\sin(\\frac{\\alpha+\\beta}{2})\\sin(\\frac{\\alpha-\\beta}{2})\\\\ &=-2\\sin(\\frac{\\alpha+\\beta}{2})\\sin(\\frac{\\alpha-\\beta}{2}) \\end{align} $$ 积化和差# 核心代换过程 $$ \\sin\\alpha\\cos\\beta=\\frac{1}{2}(\\sin\\alpha\\cos\\beta+\\cos\\alpha\\sin\\beta+\\sin\\alpha\\cos\\beta-\\cos\\alpha\\sin\\beta)\\\\ \\cos\\alpha\\cos\\beta=\\frac{1}{2}(\\cos\\alpha\\cos\\beta+\\sin\\alpha\\sin\\beta+\\cos\\alpha\\cos\\beta-\\sin\\alpha\\sin\\beta)\\\\ $$ 即凑出和差角公式形式，例如： $$ \\begin{align} \\sin\\alpha\\sin\\beta&=\\frac{1}{2}\\left[(\\cos\\alpha\\cos\\beta+\\sin\\alpha\\sin\\beta)-(\\cos\\alpha\\cos\\beta-\\sin\\alpha\\sin\\beta)\\right]\\\\ & =\\frac{1}{2}\\left[\\cos(\\alpha-\\beta)-\\cos(\\alpha+\\beta)\\right] \\end{align} $$","link":"/posts/trigo-deduction/"},{"title":"为什么是996？","text":"今天做ECNU 比赛的时候发现有一道题是讲996的。我这才知道了996是怎么来的。 As a programmer, you might know that programmers have a self-invented way to represent their workinghours, namely std, which means, start working at s a.m., end working at t p.m. and working d days a week. You might also know that recently there has been a campaign called 996.ICU which objects to long working hours and demands rights. 作为程序员，你可能知道程序员发明了一种方法来表示他们的工作时间，叫做std表示法，意思是从上午s点开始工作，直到下午t点，一周工作d天。你可能还了解到最近有一个如火如荼的运动叫996.ICU，它就是为了反对长时间工作以及争取合法权益而兴起的。 输入类似std的表达式 计算每周工作时间 function calcSTD(){ //alert(\"hello world!\"); var s=String(document.getElementById(\"std\").value); var len=s.length; var st,t,d; d=s[len-1]-'0'; // alert(d); var p=1; if(s[p-1]=='1'){ st=10+Number(s[p])-'0'; p+=2; }else{ st=s[p-1]-'0'; p+=1; } // alert(st); if(s[p-1]=='1'){ t=10+Number(s[p])-'0'; p+=2; }else{ t=s[p-1]-'0'; p+=1; } // alert(t); document.getElementById(\"answer\").innerHTML=(t-st+12)*d; } 《中华人民共和国劳动法》第四章第三十六条 国家实行劳动者每日工作时间不超过八小时、平均每周工作时间不超过四十四小时的工时制度。","link":"/posts/why-996/"},{"title":"四种最简真分式的积分","text":"有理函数的原函数一定是初等函数，因此，理论上说有理函数的积分是一定能算出来的。有理函数可以写成多项式的商的形式，且根据多项式除法知，假分式=多项式+真分式，而多项式的积分是容易计算的，根据代数学有关知识，真分式又可化为四种最简真分式之和。因此，有理函数的积分可以归结为四种最简真分式的积分。 最简真分式只有以下四种： $$ \\begin{aligned} (1)&\\frac{A}{x-a}\\\\ (2)&\\frac{A}{(x-a)^m}\\qquad\\quad (m>1)\\\\ (3)&\\frac{Mx+N}{x^2+px+q}\\qquad (p^2-4q1,p^2-4q","link":"/posts/simplest-integral/"},{"title":"我的第一行代码","text":"RQNOJ - 陶陶摘苹果 2013年江西省计算机奥赛源程序公示（JX-609037） 目前能找到的有记录的最早的代码，编写时间：2013年11月8日14：30左右。上面那个陶陶摘苹果的时间更早，可惜因为RQNOJ的原因找不到代码了。 12345678910111213141516171819202122program count;var i,n,x,j,ans:longint; a:string; b:char;begin assign(input,'count.in');reset(input); assign(output,'count.out');rewrite(output); readln(n,x); ans:=0; b:=chr(x+ord('0')); for i:= x to n do begin str(i,a); for j:=1 to length(a) do if a[j]=b then inc(ans); end; writeln(ans); close(input); close(output);end. 至于我记忆中的第一行代码，应该是在2012年年末左右，使用Pascal语言编写的Hello World程序。使用的IDE是Free Pascal，现在仍然可以在官网下载到。 大概是这样： 1234program hello;begin writeln('hello world!');end. 可惜现在Windows10下Free Pascal的IDE没法打开了（打开会闪退，目测是有兼容性问题），命令行还可以使用。有点怀念当时蓝底白字的编程界面了。。以后有时间可以用虚拟机打开试试。","link":"/posts/first-code/"},{"title":"批量下载网易云音乐歌单歌曲","text":"可执行文件下载链接# 下载链接：http://pk7zp438g.bkt.clouddn.com/tootal/exe/NetCloudMusicPlaylistDownload.exe 百度云分享链接：https://pan.baidu.com/s/1DjqqwqvoCxuEPTwei8BPjw 网易云音乐链接格式# 歌曲网页链接 歌单网页链接 歌曲MP3外链 注意外链获取的文件名是乱码。 批量下载网易云歌单歌曲# 由于python还不熟悉，暂时用C++写的下载程序。 获取html源码# 用于读取歌单名称创建文件夹，以及获取歌单包含的歌曲名、歌曲ID。 分离ID，支持粘贴页面网址。 https://music.163.com/playlist?id=2017449331&amp;userid=390866393 https://music.163.com/#/playlist?id=814646918 分离歌单名# 失落少年｜如果你太累 及时地道别没有罪 - 歌单 - 网易云音乐 分离歌曲名以及歌曲ID# Have Yourself A Merry Little ChristmasFirestone (Live Acoustic Version)All of MeNo TearsIn Time 发现歌单html里面竟然没有每首歌的作者！！ 先不弄作者了，以后有时间再加上去。 &lt;a href=&quot;/song?id= 强烈谴责VS的自动加空格行为，使得字符串查找频繁出BUG。 下载歌曲# 中文一直有乱码问题。 已经可以下载。 已经解决中文乱码问题。 默认输出到文件的编码是UTF8，但在windows下中文的编码是GBK。 有时会出现一两首歌曲下载失败。 有时会出现某些歌单不能下载，找不出问题，先这样吧。 下载单曲# https://music.163.com/song?id=1330348068 已经可以下载，文件名为songs.mp3 有些歌曲仍然无法下载，比如love story。 http://music.163.com/song/media/outer/url?id=19292984.mp3 专辑下载# https://music.163.com/album?id=39723739 有问题，可能会下载一些奇妙的东西。 目前代码# pch.h头文件： 123456789101112131415#ifndef PCH_H#define PCH_H#include &lt;Windows.h&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;fstream&gt;#include &lt;cstdio&gt;#include &lt;direct.h&gt;#include &lt;cstdlib&gt;#include &lt;io.h&gt;#endif //PCH_H 主程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304#include &quot;pch.h&quot;#pragma comment(lib,&quot;URlmon&quot;)using namespace std;static char* U2G(const char* utf8) { int len = MultiByteToWideChar(CP_UTF8, 0, utf8, -1, NULL, 0); wchar_t* wstr = new wchar_t[len + 1]; memset(wstr, 0, len + 1); MultiByteToWideChar(CP_UTF8, 0, utf8, -1, wstr, len); len = WideCharToMultiByte(CP_ACP, 0, wstr, -1, NULL, 0, NULL, NULL); char* str = new char[len + 1]; memset(str, 0, len + 1); WideCharToMultiByte(CP_ACP, 0, wstr, -1, str, len, NULL, NULL); if (wstr) delete[] wstr; return str;}/*void get_downlist_and_songsname(const char *html_source_name,const char *download_link_name,const char *song_name) { const string pre_song_id = &quot;data-res-id=\\&quot;&quot;; const string pre_song_name = &quot;data-res-name=\\&quot;&quot;; const string pre_author_name = &quot;data-res-author=\\&quot;&quot;; const string link_type_pre = &quot;http://music.163.com/song/media/outer/url?id=&quot;; const string file_type_suf = &quot;.mp3&quot;; const string songs_name_mid = &quot; - &quot;; ifstream fin1(html_source_name); ofstream fout1(download_link_name); ofstream fout2(song_name); string s; while (getline(fin1, s)) { int pos_id = s.find(pre_song_id) + pre_song_id.length(); int pos_song_name = s.find(pre_song_name) + pre_song_name.length(); int pos_author_name = s.find(pre_author_name) + pre_author_name.length(); //get downlist fout1 &lt;&lt; link_type_pre; while (s[pos_id] != '\\&quot;') { fout1 &lt;&lt; s[pos_id]; pos_id++; } fout1 &lt;&lt; file_type_suf &lt;&lt; endl; //get songname and author while (s[pos_author_name] != '\\&quot;') { fout2 &lt;&lt; s[pos_author_name]; pos_author_name++; } fout2 &lt;&lt; songs_name_mid; while (s[pos_song_name] != '\\&quot;') { fout2 &lt;&lt; s[pos_song_name]; pos_song_name++; } fout2 &lt;&lt; file_type_suf &lt;&lt; endl; } fin1.close(); fout2.close(); fout2.close();}*/int urldownload(const char *URL, const char *save_name, const char *save_folder = &quot;&quot;) { char buffer[MAX_PATH]; _getcwd(buffer, MAX_PATH); strcat_s(buffer, &quot;\\\\&quot;); //cout &lt;&lt; &quot;test:save_folder=&quot; &lt;&lt; save_folder &lt;&lt; endl; if (strlen(save_folder) &gt; 1) { strcat_s(buffer, save_folder); //_mkdir(buffer); //cout &lt;&lt; &quot;test:buffer=&quot; &lt;&lt; buffer &lt;&lt; endl; CreateDirectory(buffer, NULL); strcat_s(buffer, &quot;\\\\&quot;); } strcat_s(buffer, U2G(save_name)); //cout &lt;&lt; &quot;_getcwd=&quot; &lt;&lt; buffer &lt;&lt; endl; getchar(); return 0; HRESULT Result = URLDownloadToFileA(NULL, URL, buffer, 0, NULL); switch (Result) { case S_OK:printf(&quot;The %s download successfully!\\n&quot;, U2G(save_name)); break; case E_OUTOFMEMORY: printf(&quot;The buffer length is invalid, or there is insufficient memory to complete the operation.\\n&quot;); break; } return 0;}void download_them(const char *link_file_path, const char *name_file_path, const char *folder_name = &quot;&quot;) { ifstream fin1(link_file_path); ifstream fin2(name_file_path); /*string folder_name_read; if (folder_name.length() &gt; 1) { ifstream fin3(folder_name.c_str()); getline(fin3, folder_name_read); fin3.close(); }*/ //cout &lt;&lt; &quot;test:folder_name=&quot; &lt;&lt; folder_name &lt;&lt; endl; string dlink, fname; while (getline(fin1, dlink)) { getline(fin2, fname); //cout &lt;&lt; &quot;dlink=&quot; &lt;&lt; dlink &lt;&lt; ' ' &lt;&lt; &quot;fname=&quot; &lt;&lt; fname &lt;&lt; endl; return; //urldownload(dlink.c_str(), fname.c_str(), folder_name_read); urldownload(dlink.c_str(), fname.c_str(), folder_name); } fin1.close(); fin2.close();}void get_source(const char *html_path) { const char *foldername_save = &quot;foldername.txt&quot;; const char *downlink_save = &quot;downlink.txt&quot;; const char *songsname_save = &quot;songname.txt&quot;; //get foldname ifstream fin1(html_path); ofstream fout1(foldername_save); //fout1 &lt;&lt; &quot;This is a test message!&quot; &lt;&lt; endl; const string find_foldname_substr = &quot;&lt;title&gt;&quot;; const string find_foldname_midstr = &quot;- 歌单 - 网易云音乐&lt;/title&gt;&quot;; const string find_foldname_sufstr = &quot;&lt;/title&gt;&quot;; string read_html; while (getline(fin1, read_html)) { int foldername_flag = read_html.find(find_foldname_substr); //cout &lt;&lt; &quot;test:flag=&quot; &lt;&lt; foldername_flag &lt;&lt; endl; if (foldername_flag == -1)continue; else { foldername_flag += find_foldname_substr.length(); //cout &lt;&lt; &quot;test:flag=&quot; &lt;&lt; foldername_flag &lt;&lt; endl; int foldername_pos = read_html.find(find_foldname_sufstr); //cout &lt;&lt; &quot;test:pos=&quot; &lt;&lt; foldername_pos &lt;&lt; endl; while (foldername_flag &lt; foldername_pos - find_foldname_midstr.length()) { fout1 &lt;&lt; read_html[foldername_flag]; foldername_flag++; } fout1 &lt;&lt; endl; } } fin1.close(); fout1.close(); cout &lt;&lt; &quot;Get songs list name successfully!\\n&quot;; //get songs name and songs id ifstream fin2(html_path); ofstream fout2(songsname_save); ofstream fout3(downlink_save); const string find_songs_place_substr = &quot;&lt;ul class=\\&quot;f-hide\\&quot;&gt;&lt;li&gt;&quot;; const string find_songs_id_prestr = &quot;&lt;a href=\\&quot;/song?id=&quot;; const string link_type_pre = &quot;http://music.163.com/song/media/outer/url?id=&quot;; while (getline(fin2, read_html)) { int find_songs_place_flag = read_html.find(find_songs_place_substr); //if(read_html[1]=='u')cout &lt;&lt; &quot;test:&quot; &lt;&lt; read_html &lt;&lt; endl; //cout &lt;&lt; &quot;test:flag=&quot; &lt;&lt; find_songs_place_flag &lt;&lt; endl; if (find_songs_place_flag == -1) continue; else { //cout &lt;&lt; &quot;test:true!\\n&quot;; int find_html_pos = 0; int find_songs_id_pos = read_html.find(find_songs_id_prestr); while (find_songs_id_pos != -1) { find_songs_id_pos += find_songs_id_prestr.length(); //cout &lt;&lt; &quot;test:pos=&quot; &lt;&lt; find_songs_id_pos &lt;&lt; endl; string songs_id_download_link = link_type_pre; while (read_html[find_songs_id_pos] != '\\&quot;') { songs_id_download_link += read_html[find_songs_id_pos]; find_songs_id_pos++; } fout3 &lt;&lt; songs_id_download_link &lt;&lt; endl; find_songs_id_pos += 2; while (read_html[find_songs_id_pos] != '&lt;') { fout2 &lt;&lt; read_html[find_songs_id_pos]; find_songs_id_pos++; } fout2 &lt;&lt; &quot;.mp3\\n&quot;; find_html_pos = find_songs_id_pos; find_songs_id_pos = read_html.find(find_songs_id_prestr, find_html_pos); } } } fin2.close(); fout2.close(); fout3.close(); cout &lt;&lt; &quot;Get songs name and ID successfully!\\n&quot;;}/*void temp_main() { get_downlist_and_songsname(&quot;source.txt&quot;, &quot;downlink.txt&quot;, &quot;songname.txt&quot;); //urldownload(&quot;http://music.163.com/song/media/outer/url?id=29734857.mp3&quot;, &quot;Hans Zimmer - Cornfield Chase.mp3&quot;,&quot;震撼心灵的史诗音乐&quot;); string folder_name; ifstream fin1(&quot;foldername.txt&quot;); getline(fin1, folder_name); download_them(&quot;downlink.txt&quot;, &quot;songname.txt&quot;, folder_name.c_str()); cout &lt;&lt; &quot;All songs are download successfully!Press enter to exit.&quot; &lt;&lt; endl; getchar();}*/string get_id(string pre, int &amp;flag) { const string songs_check = &quot;song?id=&quot;; const string find_playlist_pos = &quot;playlist?id=&quot;; const string find_album = &quot;album?id=&quot;; if (pre.find(songs_check) != -1) { flag = 0; string id_temp; int pos_id = pre.find(songs_check) + songs_check.length(); while (pos_id &lt; pre.length() &amp;&amp; pre[pos_id] &gt;= '0' &amp;&amp; pre[pos_id] &lt;= '9') { id_temp += pre[pos_id]; pos_id++; } return id_temp; } else if (pre.find(find_playlist_pos) != -1) { flag = 1; string id_temp; int pos_id = pre.find(find_playlist_pos) + find_playlist_pos.length(); while (pos_id &lt; pre.length() &amp;&amp; pre[pos_id] &gt;= '0' &amp;&amp; pre[pos_id] &lt;= '9') { id_temp += pre[pos_id]; pos_id++; } return id_temp; } else if (pre.find(find_album) != -1) { flag = 1; string id_temp; int pos_id = pre.find(find_album) + find_album.length(); while (pos_id &lt; pre.length() &amp;&amp; pre[pos_id] &gt;= '0' &amp;&amp; pre[pos_id] &lt;= '9') { id_temp += pre[pos_id]; pos_id++; } return id_temp; } return pre;}void get_html_source(string playlist_id,int flag) { const string playlist_type_link = &quot;https://music.163.com/playlist?id=&quot;; const string songs_type_link = &quot;https://music.163.com/song?id=&quot;; const string album_type_link = &quot;https://music.163.com/album?id=&quot;; string download_list_html_link; if (flag == 0)download_list_html_link = songs_type_link; else if (flag == 1)download_list_html_link = playlist_type_link; else if (flag == 2)download_list_html_link = album_type_link; download_list_html_link += playlist_id; urldownload(download_list_html_link.c_str(), &quot;playlist.html&quot;); cout &lt;&lt; &quot;Download playlist html source successfully!\\n&quot;;}int main1() { //temp_main(); string playlist_id_pre; cout &lt;&lt; &quot;Please input paste the link:\\n&quot;; getline(cin, playlist_id_pre); int download_flag = -1; string playlist_id = get_id(playlist_id_pre, download_flag); //cout &lt;&lt; &quot;playlist_id=&quot; &lt;&lt; playlist_id &lt;&lt; endl; getchar(); return 0; //urldownload(&quot;https://music.163.com/playlist?id=2017449331&quot;, &quot;test.html&quot;); get_html_source(playlist_id, download_flag); if (download_flag == 1) { get_source(&quot;playlist.html&quot;); string foldername_read; ifstream finf(&quot;foldername.txt&quot;); getline(finf, foldername_read); finf.close(); //_mkdir(foldername.c_str()); //cout &lt;&lt; &quot;test:foldername_read=&quot; &lt;&lt; U2G(foldername_read.c_str()) &lt;&lt; endl; getchar(); return 0; download_them(&quot;downlink.txt&quot;, &quot;songname.txt&quot;, U2G(foldername_read.c_str())); //download_them(&quot;downlink.txt&quot;, &quot;songname.txt&quot;, &quot;foldername.txt&quot;); //download_them(&quot;downlink.txt&quot;, &quot;songname.txt&quot;, foldername); //string temp_cmd = &quot;ren abc &quot; + foldername; //system(temp_cmd.c_str()); cout &lt;&lt; &quot;All songs are download successfully!Press enter to exit.&quot; &lt;&lt; endl; remove(&quot;playlist.html&quot;); remove(&quot;downlink.txt&quot;); remove(&quot;foldername.txt&quot;); remove(&quot;songname.txt&quot;); } else if (download_flag == 2) { get_source(&quot;playlist.html&quot;); string foldername_read; ifstream finf(&quot;foldername.txt&quot;); getline(finf, foldername_read); finf.close(); //_mkdir(foldername.c_str()); //cout &lt;&lt; &quot;test:foldername_read=&quot; &lt;&lt; U2G(foldername_read.c_str()) &lt;&lt; endl; getchar(); return 0; download_them(&quot;downlink.txt&quot;, &quot;songname.txt&quot;, U2G(foldername_read.c_str())); //download_them(&quot;downlink.txt&quot;, &quot;songname.txt&quot;, &quot;foldername.txt&quot;); //download_them(&quot;downlink.txt&quot;, &quot;songname.txt&quot;, foldername); //string temp_cmd = &quot;ren abc &quot; + foldername; //system(temp_cmd.c_str()); cout &lt;&lt; &quot;All songs are download successfully!Press enter to exit.&quot; &lt;&lt; endl; remove(&quot;playlist.html&quot;); remove(&quot;downlink.txt&quot;); remove(&quot;foldername.txt&quot;); remove(&quot;songname.txt&quot;); } else if (download_flag == 0) { urldownload(string(&quot;http://music.163.com/song/media/outer/url?id=&quot;+ playlist_id+&quot;.mp3&quot;).c_str(), &quot;songs.mp3&quot;); remove(&quot;playlist.html&quot;); } return 0;}/*void test_main() { //get_source(&quot;playlist.html&quot;); //system(&quot;ren abc 钢琴与爵士的完美邂逅&quot;); //cout &lt;&lt; &quot;中文测试！\\n&quot;; ifstream fin(&quot;文件读写测试.txt&quot;); string ss_temp; while(getline(fin, ss_temp)) cout &lt;&lt; &quot;测试输出文件内容:&quot; &lt;&lt; ss_temp &lt;&lt; endl; fin.close();}*/int main() { main1(); //test_main(); getchar(); return 0;}","link":"/posts/163music-spider/"},{"title":"提取知乎问题下回答和评论数据","text":"惊闻知乎上某高中生声称证明了哥德巴赫猜想，并要在2019年1月1日在知乎贴出证明过程。 作为新年第一瓜、这个当然不能错过了。 作为高级吃瓜群众，在围观的同时还要分析一波教育程度对盲目看戏的影响，并以一月一日前的关注者作为样本，统计这些用户在一月一日后的情况。因变量为是否取关，自变量为用户信息。基于一月一日这个自然实验，把教育分为高教育组和低教育组（或分性别），然后用DiD的方法判定目标组与对照组取关的差异。（好了，编不下去了…） 具体可到项目地址Goldbach Research Group查看。 正值期末考完军训前难得的空闲日子，利用这个项目学习一下科研范式与python爬虫也是不错的。 本文记录如何爬取知乎问题下回答和评论数据。 以下均以知乎问题如果高中生能证明哥德巴赫猜想，会被清华北大数学系保送吗？为例分析，如需爬取其他问题，只需切换questionID即可。 分析API# 这部分是有前端大佬已经分析出来的，这里就简要记录一下。（自己也不是很懂） 用浏览器打开知乎问题，F12调出控制台，切换到网络，刷新，查看类型为json的请求，把其中的网址逐个排查可以得到以下API。 answer https://www.zhihu.com/api/v4/questions/306537777/answers?include=data[*].is_normal%2Cadmin_closed_comment%2Creward_info%2Cis_collapsed%2Cannotation_action%2Cannotation_detail%2Ccollapse_reason%2Cis_sticky%2Ccollapsed_by%2Csuggest_edit%2Ccomment_count%2Ccan_comment%2Ccontent%2Ceditable_content%2Cvoteup_count%2Creshipment_settings%2Ccomment_permission%2Ccreated_time%2Cupdated_time%2Creview_info%2Crelevant_info%2Cquestion%2Cexcerpt%2Crelationship.is_authorized%2Cis_author%2Cvoting%2Cis_thanked%2Cis_nothelp%2Cis_labeled%3Bdata[*].mark_infos[*].url%3Bdata[*].author.follower_count%2Cbadge[*].topics&amp;limit=1&amp;offset=0&amp;platform=desktop&amp;sort_by=default comment https://www.zhihu.com/api/v4/answers/559871763/root_comments?include=data[*].author%2Ccollapsed%2Creply_to_author%2Cdisliked%2Ccontent%2Cvoting%2Cvote_count%2Cis_parent_author%2Cis_author&amp;order=normal&amp;limit=1&amp;offset=0&amp;status=open child_comments https://www.zhihu.com/api/v4/comments/565399549/child_comments?include=%24[*].author%2Creply_to_author%2Ccontent%2Cvote_count&amp;limit=1&amp;offset=0&amp;include=%24[*].author%2Creply_to_author%2Ccontent%2Cvote_count&amp;tdsourcetag=s_pctim_aiomsg python程序# 以下是比较完整的python程序，可以爬取该问题下所有的回答、评论、子评论数据。 注意：由于水平有限，未写多线程，因此此程序运行较慢。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#coding=utf-8import requestsimport jsonimport sysimport os#questionId = 306537777questionId = 307595822startAns = 0headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:64.0) Gecko/20100101 Firefox/64.0'}##Get URLdef getAnsUrl(num): url = 'https://www.zhihu.com/api/v4/questions/'+str(questionId)+'/answers' \\ '?include=data%5B%2A%5D.is_normal%2Cadmin_closed_comment%2Creward_info%2Cis_collapsed' \\ '%2Cannotation_action%2Cannotation_detail%2Ccollapse_reason%2Cis_sticky%2Ccollapsed_by%2' \\ 'Csuggest_edit%2Ccomment_count%2Ccan_comment%2Ccontent%2Ceditable_content%2Cvoteup_count%2' \\ 'Creshipment_settings%2Ccomment_permission%2Ccreated_time%2Cupdated_time%2Creview_info%2Crele' \\ 'vant_info%2Cquestion%2Cexcerpt%2Crelationship.is_authorized%2Cis_author%2Cvoting%2Cis_thanked' \\ '%2Cis_nothelp%2Cis_labeled%3Bdata%5B%2A%5D.mark_infos%5B%2A%5D.url%3Bdata%5B%2A%5D.' \\ 'author.follower_count%2Cbadge%5B%2A%5D.topics&amp;limit=1&amp;offset='+str(num)+'&amp;platform=' \\ 'desktop&amp;sort_by=default' return url def getComUrl(ansId,offset): url = 'https://www.zhihu.com/api/v4/answers/'+str(ansId)+'/root_comments' \\ '?include=data%5B*%5D.author%2Ccollapsed%2Creply_to_author%2Cdisliked%2Ccontent%2Cvoting%2C' \\ 'vote_count%2Cis_parent_author%2Cis_author&amp;order=normal&amp;limit=1&amp;offset='+str(offset)+'&amp;status=open' return urldef getChildComUrl(comId,offset): url = 'https://www.zhihu.com/api/v4/comments/'+str(comId)+'/child_comments' \\ '?include=%24%5B%2A%5D.author%2Creply_to_author%2Ccontent%2Cvote_count&amp;limit=1' \\ '&amp;offset='+str(offset)+'&amp;include=%24%5B*%5D.author%2Creply_to_author%2C'\\ 'content%2Cvote_count&amp;tdsourcetag=s_pctim_aiomsg' return url## Make dirdef mkdir(path): isExists = os.path.exists(path) #print(isExists) if not isExists: os.makedirs(path)mkdir('./answers')mkdir('./comments')mkdir('./child_comments')##Get Answer NumansUrl = getAnsUrl(0)ansResponse = requests.get(ansUrl,headers = headers)ansJson = json.loads(ansResponse.text)#print(firstJson['paging']['totals'])totalAns = ansJson['paging']['totals']##Get Json#os.chdir('answers')for i in range(startAns,totalAns):#for i in range(0,2): print('Get answer'+str(i)+'.json') ansUrl = getAnsUrl(i) ansResponse = requests.get(ansUrl,headers = headers) ansJson = json.loads(ansResponse.text) f = open(&quot;./answers/answer&quot;+str(i)+&quot;.json&quot;,&quot;w&quot;,encoding='utf-8') f.write(ansResponse.text) f.close() if ansJson['data']: ansId = ansJson['data'][0]['id'] ##Get Comment Num comUrl = getComUrl(ansId,0) comResponse = requests.get(comUrl,headers = headers) comJson = json.loads(comResponse.text) totalCom = comJson['paging']['totals'] # 0-14 for Selected Comments if totalCom &gt; 0: mkdir('./comments/answer'+str(i)) for j in range(0,totalCom): print('Get answer'+str(i)+'--comment'+str(j)+'.json') comUrl = getComUrl(ansId,j) comResponse = requests.get(comUrl,headers = headers) f = open(&quot;./comments/answer&quot;+str(i)+&quot;/comment&quot;+str(j)+&quot;.json&quot;,&quot;w&quot;,encoding='utf-8') f.write(comResponse.text) f.close() comJson = json.loads(comResponse.text) if comJson['data']: comId = comJson['data'][0]['id'] totalChCom = comJson['data'][0]['child_comment_count'] ##Get Child Comment if totalChCom &gt; 0 : mkdir('./child_comments/answer'+str(i)) mkdir('./child_comments/answer'+str(i)+'/comment'+str(j)) for k in range(0,totalChCom): print('Get answer'+str(i)+'--comment'+str(j)+''+'--child_comment'+str(k)+'.json') chComUrl = getChildComUrl(comId,k) comResponse = requests.get(chComUrl,headers = headers) f = open(&quot;./child_comments/answer&quot;+str(i)+&quot;/comment&quot;+str(j)+&quot;/child_comment&quot;+str(k)+&quot;.json&quot;,&quot;w&quot;,encoding='utf-8') f.write(comResponse.text)f.close() 后记# 证明准时发布，被指出明显错误，（not even wrong）题主注销帐号，一场闹剧就此结束。 2018年结束，2019年开始。","link":"/posts/zhihu-spider/"},{"title":"改革开放四十年与我的家庭变迁","text":"1978年12月，伴随着十一届三中全会的落幕，中国的改革开放自此拉开了帷幕。而今年正是2018年——改革开放40周年之际，作为其中的亲历者，即使只经历了其中一半的时间，但改革开放所给我的家庭所带来的变化是翻天覆地的。 在我童年的心里留下了深刻的印象，时至今日，我的笔记本电脑里依然装有童年时的游戏，虽然现在早已没有了当初的新鲜感。我相信，若是没有改革开放的政策，电话、电视、电脑这些新鲜事物想必不会这么早的出现在我的生活里。正如这些事物给我的单调的童年生活带来了光明与欢乐，改革开放也必定给整个国家的发展带来了光明。 后来电脑、手机开始普及，QQ等即时聊天软件也开始流行起来。很多人的通讯录里除了地址、电话、手机号码外，往往还会记下对方的QQ号，就连路边的广告标语也都会标注QQ号的联系方式。不得不说，QQ与之后出现的微信，真正把互联网连接了每一个人。由于我父亲常年在外地打工，这一点就显得格外重要。我们家人之间的交流就再也不局限于打电话了，而是几乎时时刻刻都可以通过网络沟通，甚至可以视频通话。这些都是改革开放所给我的家庭带来的变迁。 除了家人之间交流方式的变化，我家的住房甚至邻里关系也随着改革开放的浪潮在变化。一直以来，我家都是住在一栋四层高的小楼房里，这是父亲当年与人合资建造的。知道2014年，政府出台了城中村改造计划，我家的楼房也在拆迁计划中。与此同时，城市里各种小区也多了起来，楼房也越建越高，房价也随之节节攀升。虽然现在一栋楼里住的人变得比以前多得多了，但却远不如以前热闹了。改革开放所带来的，不仅仅是翻天覆地的物质变化，还给我们的精神也带来了很大的改变。伴随着经济的高速繁荣，GDP的连年增长，以前悠闲的时光仿佛也一去不复返了，每个人都开始忙忙碌碌，仿佛响应了那句改革开放的口号：时间就是金钱，效率就是生命。 改革开放四十年来，它带给我以及我的家庭变化太多太多。在改革开放这股时代潮流中，我们每个人都身处其中，都是其中的亲历者，参与者，也是社会的改变者，建设者，一起见证者国家的繁荣与时代的变迁。 参考文献： 蛇口春雷：“时间就是金钱，效率就是生命” https://baijiahao.baidu.com/s?id=1590428905655158259&amp;wfr=spider&amp;for=pc 改革开放40周年经济的变化 https://www.meipian.cn/1is7hj5l","link":"/posts/reform40-myhome/"},{"title":"文字笔记","text":"岁月不居，时节如流。 世界上最美丽最珍贵的，反而是听不见且看不清的，只有用心才能感受得到。 永恒是很长的时间，特别是对尽头而言。 Eternity is a very long time, especially towards the end. 天下事有难易乎？为之，则难者亦易矣，不为，则易者亦难矣。 见字如面，纸短情长。 神犇说世上的美有三种,一是优美精致的数据结构,二是巧夺天工的神奇算法,三是你温暖世界的笑容。 所有的相遇，都是久别重逢。所有的别离，都是再会有期。 人生如此复杂，机会多得像稠密图，我们没理由认输。尽管我们走不了最短路，但图仍是连通图，TLE之前，没有一个节点叫失败。 陪伴是最长情的告白。 努力的意义，不在于一定会让你取得多大成就，而是让你在平凡的日子里，与生活少一点妥协。多努力一点，也许会让你有更多力气去保护你喜欢的东西，让你与心仪的美好事物更加靠近，更重要是让你在时光的流逝中逐渐成为更好的自己。 抓住主要矛盾，始终把学习实验的焦点集中在最有趣的部分。如果对一个东西不理解，就不要对其进行修改，如果非改不可，则应根据自己的直觉和猜测尝试各种改法，不必过多的思考为什么要这样。 回想自己的高考岁月，遥不可及却也近在眼前。那道题其实我会做，那个人其实我爱过。 也许多少年后在某个地方，我将轻声叹息将往事回顾。一片树林里分出两条路，而我选择了人迹更少的一条，从此决定了我一生的道路。 哪有什么突然想起，只不过是一直藏在心里。 放弃什么都不要放弃尝试，尝试什么都不要尝试放弃。 我们的一些大学，包括北京大学，正在培养一些‘精致的利己主义者’，他们高智商，世俗，老到，善于表演，懂得配合，更善于利用体制达到自己的目的。这种人一旦掌握权力，比一般的贪官污吏危害更大。 吉德林法则：把难题清清楚楚地写出来，问题便已经解决了一半。 不管我做了什么，或她做了什么，就是不喜欢，故事的结局早已写在开头。可能人就是这样的，明知不可能，却还一步步小心的试探，感动了别人，其实是感动了自己。若干年后，回过头来，我会笑着对别人讲起这一段往事，心里自然会怀念，不过只是羡慕那时候自己多傻，多可爱。以前一位学长有句话很好，“明知其不可为而为之，善之善也。”这就是年少轻狂吧。 莫言喧懈只愿欢，无人相伴便独眠。 秋风清，秋风明；落叶聚还散，寒鸦栖复惊。相思相见知何日，此时此夜难为情。 研表究明，汉字序顺并不定一影阅响读。 卢梭说：人生而自由，但无往不再枷锁之中。所有事情都一样，人的命运也是如此，在注定的牢笼之中，我们享有充分的自由。纵然我们被某个命定论所束缚，但是大命运中的选择，依然由我们自由决定。所以历史进程固然不可逆转，但是自我奋斗依然可以逆天改命。我们仍然有充分的理由，在我们的生活中，勇往直前、百折不回。 你看到的容颜至少是$3 ps$之前的，你听到的呢喃至少是$30\\mu s$之前的，你嗅到的幽香至少是$300\\mu s$之前的，你也不要忘记了记入、传输、解码这些信号的时间。就连你触到她柔荑的感觉，也在躯体中走过了漫漫长路。看吧，就连你眼前的这个人儿，你也只能看到她的过去，可是这并不能阻止你满怀爱意的策划你们的未来。光速让我们生活在一个过去的世界，在无尽的过往中筹划触不到的未来，我们所能做的唯有把握现在。现在，你准备好了吗？ 愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。能做事的做事，能发声的发声。有一分热，发一分光，就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。此后如竟没有炬火：我便是唯一的光。","link":"/posts/words-note/"},{"title":"最长上升子序列（LIS）总结","text":"子序列：可以通过删除原序列中一些元素获得的序列。 子串：原序列中连续的一段。 子序列和子串的区别：子序列不需要连续，子串是连续的。如abcdef中acf是子序列，bcd是子串。显然子串都是子序列。 参考：Longest increasing subsequence n^2做法# POJ-2533 Longest Ordered Subsequence 求最长上升子序列，数据范围N&lt;=1000，n^2复杂度可过。 假设f[i]表示以a[i]结尾的最长上升子序列长度，对每个f[i]，在前面找一个比a[i]小的数a[j]，更新f[i] = max(f[i], f[j] + 1)，最终最大的f[i]即为答案。 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1005;int a[N], f[N];int main() { int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; int ans = 1; for (int i = 1; i &lt;= n; i++) { f[i] = 1; for (int j = 1; j &lt; i; j++) { if (a[j] &lt; a[i] &amp;&amp; f[j] + 1 &gt; f[i]) { f[i] = f[j] + 1; } } ans = max(ans, f[i]); } cout &lt;&lt; ans &lt;&lt; '\\n'; return 0;} nlgn做法# POJ-3903 Stock Exchange 题意一样，数据范围变成了10^5，显然n^2算法不能过了，需要使用nlogn算法。 假设f[i]表示长度为i的上升子序列的末尾元素的最小值。ans表示目前最长上升子序列的长度。初始值ans=1，f[1]=a[1]，依次考虑每个元素i，如果$a[i]&gt;f[ans]$，说明a[i]可以接在目前最长的上升子序列的末尾，答案+1。否则，答案不会更优。但是a[i]可以替换掉f数组中第一个大于等于a[i]的值所代表上升子序列的末尾元素，因为a[i]比他更小，所以更有可能使得答案变大。注意这个位置是a[i]唯一能替换的元素，小于a[i]的，替换后只会使答案可能变小，不是第一个大于等于a[i]的，不符合上升序列的定义。注意到f数组单调递增，因此可以使用二分查找。 参考：最长不下降子序列nlogn算法详解 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e5 + 5;int a[N], f[N];int main() { ios::sync_with_stdio(false);cin.tie(0); int n; while(cin &gt;&gt; n) { for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; } int ans = 1; f[1] = a[1]; for (int i = 2; i &lt;= n; i++) { if (a[i] &gt; f[ans]) { ans++; f[ans] = a[i]; } else { f[lower_bound(f + 1, f + 1 + ans, a[i]) - f] = a[i]; } } cout &lt;&lt; ans &lt;&lt; '\\n'; } return 0;} 最长公共子序列（LCS）# HDU-1159 Common Subsequence 求两个串的最长公共子序列，数据范围小于1000，n^2算法可过。 假设两个串为a、b，f[i][j]表示a串前i个字符与b串前j个字符的最长公共子序列长度。依次枚举i、j，若a[i] = b[j]，则f[i][j] = f[i - 1][j - 1] + 1，否则，f[i][j] = max(f[i - 1][j], f[i][j - 1])。 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1005;char a[N], b[N];int f[N][N];int main() { while (cin &gt;&gt; a + 1 &gt;&gt; b + 1) { int la = strlen(a + 1), lb = strlen(b + 1); for (int i = 1; i &lt;= la; i++) { for (int j = 1; j &lt;= lb; j++) { if (a[i] == b[j]) { f[i][j] = f[i - 1][j - 1] + 1; } else { f[i][j] = max(f[i][j - 1], f[i - 1][j]); } } } cout &lt;&lt; f[la][lb] &lt;&lt; '\\n'; } return 0;} LCS转LIS# Luogu-1439 【模板】最长公共子序列 数据范围10^5，因此不能用n^2的算法。 假设两个序列为a、b，构造一个新的序列c，c[i]表示b[i]在a[i]中出现的位置，即b[i] = a[c[i]]，则c序列的LIS即为a、b的LCS。例如：a = [3, 1, 2, 5, 4]，b = [4, 2, 3, 1, 5]，则c = [5, 3, 1, 2, 4]，c的LIS为[1, 2, 4]对应a，b的LCS为[3, 1, 5]。 注意：这种转换有特殊条件，只有在b中的元素能匹配较少的a中的元素时才有效，否则时间反而更慢。 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5;int a[N], b[N], f[N];int main() { int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { int x; cin &gt;&gt; x; a[x] = i; } for (int i = 1; i &lt;= n; i++) { int x; cin &gt;&gt; x; b[i] = a[x]; } int ans = 1; f[1] = b[1]; for (int i = 2; i &lt;= n; i++) { if (b[i] &gt; f[ans]) { ans++; f[ans] = b[i]; } else { f[lower_bound(f + 1, f + 1 + ans, b[i]) - f] = b[i]; } } cout &lt;&lt; ans &lt;&lt; '\\n'; return 0;} 参考：LIS 问题与 LCS 问题可以互相转换 把最长公共子序列LCS问题转化为最长上升子序列LIS问题 Junior Dynamic Programming——动态规划初步·各种子序列问题 LCS转为LIS UVA-10635 Prince and Princess 和Luogu-1439差不多，代码改改就能过了。 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 250 * 250 + 5;int a[N], b[N], f[N];int main() { int T; cin &gt;&gt; T; for (int t = 1; t &lt;= T; t++) { int n, p, q; cin &gt;&gt; n &gt;&gt; p &gt;&gt; q; for (int i = 1; i &lt;= p + 1; i++) { int x; cin &gt;&gt; x; a[x] = i; } n = 0; for (int i = 1; i &lt;= q + 1; i++) { int x; cin &gt;&gt; x; if (a[x]) b[++n] = a[x]; } int ans = 1; f[1] = b[1]; for (int i = 2; i &lt;= n; i++) { if (b[i] &gt; f[ans]) { ans++; f[ans] = b[i]; } else { f[lower_bound(f + 1, f + 1 + ans, b[i]) - f] = b[i]; } } cout &lt;&lt; &quot;Case &quot; &lt;&lt; t &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; '\\n'; } return 0;} Luogu-4303 【AHOI2006】基因匹配 和上一题同样的思路，构造新序列b，数组a用来记录第一个序列中的元素出现的位置。关键在代码第19行，for (int j = c[x] - 1; j &gt;= 0; j–)，这里是逆序构造的。至于为什么要逆序，可以参考最长公共子序列是否存在低于 O(n^2) 的算法？这个答案。简单说一下就是：之前构造的新序列c中的每一个元素对应一个b中的元素，如果有多个对应，则这些元素就形成了一个组。即每一组只能选一个元素，为了方便实现，直接将每一组逆序。 参考：【AHOI2006】基因匹配 Match 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5;int a[N][5], c[N], b[N * 5], f[N * 5];int main() { int n; cin &gt;&gt; n; n *= 5; for (int i = 1; i &lt;= n; i++) { int x; cin &gt;&gt; x; a[x][c[x]] = i; c[x]++; } int bn = 0; for (int i = 1; i &lt;= n; i++) { int x; cin &gt;&gt; x; for (int j = c[x] - 1; j &gt;= 0; j--) { bn++; b[bn] = a[x][j]; } } int ans = 1; f[1] = b[1]; for (int i = 2; i &lt;= bn; i++) { if (b[i] &gt; f[ans]) { ans++; f[ans] = b[i]; } else { f[lower_bound(f + 1, f + 1 + ans, b[i]) - f] = b[i]; } } cout &lt;&lt; ans &lt;&lt; '\\n'; return 0;} 加权LIS# 计蒜客 - A1288 The Heaviest Non-decreasing Subsequence Problem 在LIS的基础上引入权值，要求权值最大。 这种问题如果权值非常小的话，有一种简单的解决办法： 权值小于等于0的数不要选，即使权值全部为负数，也可以一个都不选，这样总权值为0反而更大。 将权值为n（正整数）的数拆分成n个数，构造一个新序列 求新序列的LIS即为原序列的最大权值 注意是优先长度还是优先权值 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;typename T, typename F&gt;int LIS(T first, T last, F cmp) { if (first == last) return 0; int ans = 1; vector&lt;int&gt; f(1, *first); for (T i = first + 1; i != last; i++) { if (cmp(f.back(), *i)) f.push_back(*i); else *lower_bound(f.begin(), f.end(), *i, cmp) = *i; } return f.size();}int main() { vector&lt;int&gt; a; int x; while (cin &gt;&gt; x) { if (x &lt; 0) continue; if (x &gt;= 10000) { x -= 10000; vector&lt;int&gt; t(5, x); a.insert(a.end(), t.begin(), t.end()); } else { a.push_back(x); } } cout &lt;&lt; LIS(a.begin(), a.end(), less_equal&lt;int&gt;()); return 0;} 二维# 滑雪 就是求一个二维的LIS，假设f[i][j]表示以（i，j）结尾的LIS长度，显然f[i][j]可以从四个方向中高度更高的地方更新答案。注意这里的更新顺序不再是方向了，而是按高度从低到高更新答案。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int N = 105;int h[N][N], f[N][N];const int dx[]{-1, 0, 1, 0}, dy[]{0, 1, 0, -1};struct node { int x, y;};bool cmp(node u, node v) { return h[u.x][u.y] &lt; h[v.x][v.y];}int main() { int r, c; cin &gt;&gt; r &gt;&gt; c; vector&lt;node&gt; a; for (int i = 1; i &lt;= r; i++) { for (int j = 1; j &lt;= c; j++) { cin &gt;&gt; h[i][j]; node t; t.x = i; t.y = j; a.push_back(t); } } sort(a.begin(), a.end(), cmp); int ans = 1; for (int i = 0; i &lt; a.size(); i++) { int x = a[i].x, y = a[i].y; f[x][y] = 1; for (int j = 0; j &lt; 4; j++) { int xx = x + dx[j], yy = y + dy[j]; if (h[xx][yy] &lt; h[x][y] &amp;&amp; f[x][y] &lt; f[xx][yy] + 1) { f[x][y] = f[xx][yy] + 1; if (f[x][y] &gt; ans) ans = f[x][y]; } } } cout &lt;&lt; ans &lt;&lt; '\\n'; return 0;} 模板# 将该算法抽象成一个模板函数，不依赖外部状态，同时支持数组与容器，支持不下降（传入less_equal&lt;int&gt;()即可）。 上面部分题目用到了封装好的算法。 1234567891011template &lt;typename T, typename F&gt;int LIS(T first, T last, F cmp) { if (first == last) return 0; int ans = 1; vector&lt;int&gt; f(1, *first); for (T i = first + 1; i != last; i++) { if (cmp(f.back(), *i)) f.push_back(*i); else *lower_bound(f.begin(), f.end(), *i, cmp) = *i; } return f.size();} 使用示例： 1234vector&lt;int&gt; a{1, 4, 2, 2, 3};LIS(a.begin(), a.end(), less&lt;int&gt;()); // 3int b[]{1, 4, 2, 2, 3};LIS(b, b + 5, less_equal&lt;int&gt;()); // 4 其他# LCS+位压缩 HDU-2253 Longest Common Subsequence Again 用之前的办法做了一下，MLE了，先留个坑在这里。 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 3e4 + 5;char a[N], b[N];int main() { while (cin &gt;&gt; a &gt;&gt; b) { int la = strlen(a), lb = strlen(b); vector&lt;int&gt; fa[26]; for (int i = 0; i &lt; la; i++) { fa[a[i] - 'A'].push_back(i + 1); } vector&lt;int&gt; c(1); for (int i = 0; i &lt; lb; i++) { auto &amp;fb = fa[b[i] - 'A']; for (auto j = fb.rbegin(); j != fb.rend(); j++) { c.push_back(*j); } } int ans = 1, n = c.size() - 1; vector&lt;int&gt; f(n + 1); f[1] = c[1]; for (int i = 2; i &lt;= n; i++) { if (c[i] &gt; f[ans]) { f[++ans] = c[i]; } else { f[lower_bound(f.begin() + 1, f.begin() + 1 + ans, c[i]) - f.begin()] = c[i]; } } cout &lt;&lt; ans &lt;&lt; '\\n'; } return 0;} 贪心 LIS 先增后减子序列 CodeChef-GMB04 Mountain Engineering 这题更大的难点是需要统计这种序列的个数。","link":"/posts/lis-summary/"},{"title":"给PDF文件添加目录","text":"最近在找一些教材的PDF版本，有时候找到了PDF版本却没有目录，对于教材这种需要经常查阅的电子书来说，没有书签目录会导致效率大大降低。之前一直将就着用了，正好暑假小学期结束了，有一些空闲时间，这次我决定给PDF加上目录。 以我下学期的课程计算机网络为例，教材为《计算机网络（第五版）》清华大学出版社。百度搜索一下，在脚本之家找到了这本书的电子版。下载后发现虽然是扫描版的，质量还不错，但是缺点就是没有目录，不方便查阅。 首先使用PDF Password Remover去除PDF内置的密码，否则无法编辑。接下来就可以使用常规的PDF编辑软件对PDF进行编辑了，我使用Adobe Acrobat DC删去了一些多余的页面。虽然也可以添加目录，不过需要一个一个手动添加，对于有七百多页的大部头来说效率实在太低，于是我借助了其他一些工具批量添加。 首先需要获取书籍的完整目录，不需要从PDF版本的目录页进行识别，一般来说书籍的目录页信息都是公开的，在网上书店或者出版社的网站一般可以找到，例如《计算机网络》的目录即可在清华大学出版社官网找到。将它复制下来，存放在一个文本文件中，我命名为data.txt。 结构类似下面这样： 123456789101112第1章 引言 11.1 使用计算机网络 21.1.1 商业应用 21.1.2 家庭应用 41.1.3 移动用户 81.1.4 社会问题 10（省略余下部分） 接着使用PDF Patcher，打开PDF文件，先添加几个书签，例如封面、前言等页，方便查看书签文件的结构。接着保存书签文件，即得到了类似以下格式的文件： 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;gb2312&quot;?&gt;&lt;PDF信息 程序名称=&quot;PDFPatcher&quot; 程序版本=&quot;0.3.3&quot; 导出时间=&quot;2020年08月30日 11:33:38&quot; PDF文件位置=&quot;C:\\Output\\[计算机网络（第5版）].（美）特南鲍姆.扫描版_Password_Removed.pdf&quot;&gt; &lt;度量单位 单位=&quot;点&quot; /&gt; &lt;文档书签&gt; &lt;书签 文本=&quot;封面&quot; 动作=&quot;转到页面&quot; 页码=&quot;1&quot; 显示方式=&quot;适合页宽&quot;/&gt; &lt;书签 文本=&quot;书名&quot; 动作=&quot;转到页面&quot; 页码=&quot;2&quot; 显示方式=&quot;适合页宽&quot;/&gt; &lt;书签 文本=&quot;版权&quot; 动作=&quot;转到页面&quot; 页码=&quot;3&quot; 显示方式=&quot;适合页宽&quot;/&gt; &lt;书签 文本=&quot;前言&quot; 动作=&quot;转到页面&quot; 页码=&quot;4&quot; 显示方式=&quot;适合页宽&quot;/&gt; &lt;书签 文本=&quot;目录&quot; 动作=&quot;转到页面&quot; 页码=&quot;6&quot; 显示方式=&quot;适合页宽&quot;/&gt; &lt;书签 文本=&quot;第1章 引言&quot; 动作=&quot;转到页面&quot; 页码=&quot;15&quot; 显示方式=&quot;适合页宽&quot;&gt; &lt;/文档书签&gt; &lt;页码样式 /&gt;&lt;/PDF信息&gt; 注意文件的编码格式是GB2312，使用文本编辑器打开和保存的时候均需要注意格式问题。 根据这两个信息我们就可以使用脚本来处理目录数据，自动生成书签文件了。 我用的是Python脚本： 123456789101112131415161718192021222324252627def wrap(info, page): return '&lt;书签 文本=&quot;{}&quot; 动作=&quot;转到页面&quot; 页码=&quot;{}&quot; 显示方式=&quot;适合页宽&quot;&gt;\\n'.format(info, int(page)+14)def handle(line): line = line.strip() p = line.rfind(' ') return line[:p], line[p + 1:]with open('data.txt', 'r', encoding='utf-8') as fin: with open('out.xml', 'w', encoding='utf-8') as fout: lines = list(filter(lambda x: len(x.strip()) &gt; 0, fin.readlines())) i = 0 while i &lt; len(lines) and '第' in lines[i] and '章' in lines[i]: info, page = handle(lines[i]) fout.write(wrap(info, page)) i += 1 while i &lt; len(lines) and (lines[i].split(' ')[0].count('.') == 1 or '习题' in lines[i]): info, page = handle(lines[i]) fout.write(wrap(info, page)) i += 1 while i &lt; len(lines) and lines[i].split(' ')[0].count('.') == 2: info, page = handle(lines[i]) fout.write(wrap(info, page)) fout.write('&lt;/书签&gt;\\n') i += 1 fout.write('&lt;/书签&gt;\\n') fout.write('&lt;/书签&gt;\\n') 得到输出文件out.xml后，手动将其复制到原来的书签文件对应位置即可。 然后使用PDF Patcher导入书签文件，注意把之前的书签删除。 此外，如果觉得扫描版的PDF文件大小太大了，可以使用Acrobat DC中的优化PDF功能，优化文件大小。","link":"/posts/pdf-table/"},{"title":"软件学院ACM集训队选拔赛第一场","text":"题目 A# U53614 电梯 注意不存在0楼。 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int main(){// freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int t; cin&gt;&gt;t; while(t--){ int h,l,n,m=1; cin&gt;&gt;h&gt;&gt;l&gt;&gt;n; for(int i=1;i&lt;=n;i++){ char c;int a; cin.get(); cin&gt;&gt;c&gt;&gt;a; if(c=='u'){ if(m&lt;0&amp;&amp;m+a&gt;=0)m++; m+=a; } else if(c=='d'){ if(m&gt;0&amp;&amp;m-a&lt;=0)m--; m-=a; } if(m&gt;h)m=h; else if(m&lt;l)m=l; } cout&lt;&lt;m&lt;&lt;endl; } return 0;} B# U53615 集训室的猫 解法比较多，这里采用了矩阵快速幂。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int M=1000007;struct Matrix{ long long a[3][3]; Matrix(){ memset(a,0,sizeof(a)); }};Matrix operator*(const Matrix &amp;x,const Matrix &amp;y){ Matrix ans; for(int i=1;i&lt;=2;i++){ for(int j=1;j&lt;=2;j++){ for(int k=1;k&lt;=2;k++){ ans.a[i][j]=(ans.a[i][j]+x.a[i][k]*y.a[k][j])%M; //while(ans.a[i][j]&gt;=M)ans.a[i][j]-=M; } } } return ans;}void init(Matrix &amp;x){ for(int i=1;i&lt;=2;i++){ x.a[i][i]=1; }}Matrix operator^(Matrix &amp;x,int y){ Matrix ans; init(ans); while(y){ if(y&amp;1){ ans=ans*x; } x=x*x; y&gt;&gt;=1; } return ans;}int main(){ //freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); //freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); int t; cin&gt;&gt;t; while(t--){ int n,a,b; cin&gt;&gt;n&gt;&gt;a&gt;&gt;b; for(int i=1;i&lt;=n;i++){ int x; cin&gt;&gt;x; if(x==1)cout&lt;&lt;a; else if(x==2)cout&lt;&lt;b; else{ Matrix m; m.a[1][1]=m.a[1][2]=m.a[2][1]=1; m=m^(x-2); cout&lt;&lt;(m.a[1][1]*b+m.a[1][2]*a)%M; } if(i==n)cout&lt;&lt;'\\n'; else cout&lt;&lt;' '; } } return 0;} C# U53616 步道乐骑 类似与生成树。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int N=100050;struct edge{ int u,v,w; edge(int u,int v,int w):u(u),v(v),w(w) {} bool operator&lt;(const edge &amp;x)const{ return w&gt;x.w; }};vector&lt;edge&gt; e;int x[N],y[N],w[N],Set[N];int Find(int x){ return (x==Set[x])?x:Set[x]=Find(Set[x]);}void Union(int x,int y){ Set[Find(x)]=Set[Find(y)];}int main(){ //freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n,m,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(int i=1;i&lt;=m;i++){ cin&gt;&gt;x[i]&gt;&gt;y[i]&gt;&gt;w[i]; } int u,v; cin&gt;&gt;u&gt;&gt;v; int ans=0; for(int i=1;i&lt;=m;i++){ if((x[i]==u&amp;&amp;y[i]==v)||(x[i]==v&amp;&amp;y[i]==u)){ ans=max(ans,w[i]); }else{ e.push_back(edge(x[i],y[i],w[i])); } } for(int i=1;i&lt;=n;i++)Set[i]=i; Union(u,v); k--; sort(e.begin(),e.end()); for(auto i:e){ if(k==0)break; if(Find(i.u)!=Find(i.v)){ ans+=i.w; Union(i.u,i.v); k--; } } cout&lt;&lt;ans&lt;&lt;endl; return 0;} D# U53617 翘爆团体 图论题。艰难 。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;using namespace std;const int N=5050;vector&lt;int&gt; edge[N];stack&lt;int&gt; stk;int dfn[N],low[N],instk[N],mark[N],match[N],vis[N];vector&lt;int&gt; cut[N];int times,scc,mat;void tarjan(int u){ //printf(&quot;tarjan(%d) begin!\\n&quot;,u); dfn[u]=low[u]=++times; stk.push(u); instk[u]=1; for(auto v:edge[u]){ if(!dfn[v]){ tarjan(v); low[u]=min(low[u],low[v]); //printf(&quot;when tarjan(%d),v not visted,low[%d]=%d\\n&quot;,u,u,low[u]); }else if(instk[v]){ low[u]=min(low[u],dfn[v]); //printf(&quot;when tarjan(%d),v in stack,low[%d]=%d\\n&quot;,u,u,low[u]); } } //printf(&quot;when tarjan(%d),dfn[%d]=%d,low[%d]=%d\\n&quot;,u,u,dfn[u],u,low[u]); if(dfn[u]==low[u]){ int v; do{ v=stk.top(); //printf(&quot;when tarjan(%d),v=%d\\n&quot;,u,v); instk[v]=0; mark[v]=scc; //for(auto i:edge[v]) // cut[scc].push_back(i); stk.pop(); }while(v!=u); scc++; } //printf(&quot;ans=%d,dfn[%d]=%d,low[%d]=%d,tarjan(%d) end!\\n&quot;,ans,u,dfn[u],u,low[u],u);}int dfs(int u){ for(auto v:cut[u]){ if(u!=v&amp;&amp;!vis[v]){ vis[v]=1; if(match[v]==-1||dfs(match[v])){ match[v]=u; //match[u]=v; //printf(&quot;match %d %d\\n&quot;,u,v); return 1; } } } return 0;}int main(){ //freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); //freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++){ int u,v; cin&gt;&gt;u&gt;&gt;v; edge[u].push_back(v); } /*for(int i=1;i&lt;=n;i++){ cout&lt;&lt;i&lt;&lt;&quot;:&quot;; for(auto j:edge[i]){ cout&lt;&lt;j&lt;&lt;' '; } cout&lt;&lt;endl; }*/ for(int i=1;i&lt;=n;i++){ if(!dfn[i])tarjan(i); } //printf(&quot;after tarjan scc=%d\\n&quot;,scc); /*for(int i=1;i&lt;=n;i++){ printf(&quot;mark[%d]=%d\\n&quot;,i,mark[i]); }*/ //cut the more for(int i=1;i&lt;=n;i++){ for(auto j:edge[i]){ cut[mark[i]].push_back(mark[j]); //printf(&quot;mark[%d]=%d,cut[%d].push(%d)\\n&quot;,i,mark[i],mark[i],mark[j]); } } /*for(int i=0;i&lt;scc;i++){ for(auto j:edge[i]){ printf(&quot;cut[%d][..]=%d\\n&quot;,i,j); } }*/ //hungarian algorithm memset(match,-1,sizeof(match)); for(int i=0;i&lt;scc;i++){ memset(vis,0,sizeof(vis)); if(dfs(i)){ mat++; //printf(&quot;dfs(%d)=true\\n&quot;,i); } //printf(&quot;hungarian:i=%d,mat=%d\\n&quot;,i,mat); } //printf(&quot;after hungarian mat=%d\\n&quot;,mat); //printf(&quot;scc=%d,mat=%d\\n&quot;,scc,mat); cout&lt;&lt;scc-mat&lt;&lt;endl; return 0;} E# U53618 骗分的回忆 分类讨论。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;const int N=50050;const int M=100050;vector&lt;int&gt; son[N];int f[N],size[N],op[M],u[M];int dfs(int x){ int ans=1; for(auto v:son[x]){ if(f[v]==x)ans+=dfs(v); } return size[x]=ans;}int main(){ int n,m,root; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;f[i]); if(f[i]==0)root=i; else son[f[i]].push_back(i); } int count0=0,count1=0; for(int i=1;i&lt;=m;i++){ scanf(&quot;%d%d&quot;,&amp;op[i],&amp;u[i]); if(op[i]==1)count1++; else if(op[i]==0)count0++; } f[root]=root; if(count0&lt;=100){ dfs(root); for(int i=1;i&lt;=m;i++){ if(op[i]==1) printf(&quot;%d\\n&quot;,size[u[i]]); else if(op[i]==0){ int tu=u[i]; while(f[tu]!=root){ size[f[tu]]-=size[u[i]]; tu=f[tu]; } f[u[i]]=root; } } }else if(count1&lt;=100){ for(int i=1;i&lt;=m;i++){ if(op[i]==1){ dfs(root); printf(&quot;%d\\n&quot;,size[u[i]]); }else if(op[i]==0){ if(f[u[i]]!=root)son[root].push_back(u[i]); f[u[i]]=root; } } } return 0;} F# U53619 太空中的箱与球 模拟。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;const double eps=1e-8;int main(){ //freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); //freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); double x,y,z,bx,by,bz,r,vx,vy,vz,t; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z&gt;&gt;bx&gt;&gt;by&gt;&gt;bz&gt;&gt;r&gt;&gt;vx&gt;&gt;vy&gt;&gt;vz&gt;&gt;t; x-=r,y-=r,z-=r; //printf(&quot;x=%lf,y=%lf,z=%lf\\n&quot;,x,y,z); double dx,dy,dz,tx,ty,tz,tt; while(1){ dx=(vx&gt;0)?(x-bx):(bx-r); dy=(vy&gt;0)?(y-by):(by-r); dz=(vz&gt;0)?(z-bz):(bz-r); tx=(dx&lt;eps)?1e9:(dx/fabs(vx)); ty=(dy&lt;eps)?1e9:(dy/fabs(vy)); tz=(dz&lt;eps)?1e9:(dz/fabs(vz)); tt=min(min(tx,ty),tz); //printf(&quot;vx=%lf,vy=%lf,vz=%lf,dx=%lf,dy=%lf,dz=%lf,tx=%lf,ty=%lf,tz=%lf,tt=%lf\\n&quot;,vx,vy,vz,dx,dy,dz,tx,ty,tz,tt); if(tt&gt;1e9-1)break; else if(tt&gt;t)break; else{ bx=bx+vx*tt; by=by+vy*tt; bz=bz+vz*tt; if(fabs(tx-tt)&lt;eps){ vx=-vx; } if(fabs(ty-tt)&lt;eps){ vy=-vy; } if(fabs(tz-tt)&lt;eps){ vz=-vz; } } t-=tt; //printf(&quot;t=%lf,bx=%lf,by=%lf,bz=%lf\\n&quot;,t,bx,by,bz); } if(t&gt;eps&amp;&amp;tt&lt;1e9-1){ bx=bx+vx*t; by=by+vy*t; bz=bz+vz*t; } printf(&quot;%.2lf %.2lf %.2lf\\n&quot;,bx,by,bz); return 0;} G# U53620 小南瓜与猫窝 H# U53621 YHF与他的薯(mei)片(zi) I# U53622 编码 J# U53623 题目是什么能吃吗 sort# 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int a[1000005];int main(){ int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]); } sort(a+1,a+n+1); a[0]=a[n+1]=-1; for(int i=1;i&lt;=n;i++){ if(a[i]!=a[i-1]&amp;&amp;a[i]!=a[i+1])printf(&quot;%d &quot;,a[i]); } return 0;}","link":"/posts/scutpc2018-c1/"},{"title":"软件学院ACM集训队选拔赛第二场","text":"A# 我，小南瓜，队列 B# 我，小南瓜，橘猫捕捉计划，启动！ C# 我，小南瓜，某乎，启动！ stl容器荟萃。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;map&gt;using namespace std;const int N=105;string tag[N];string tags[N][N];set&lt;string&gt; sset;map&lt;string,int&gt; smapn;map&lt;int,string&gt; nmaps;vector&lt;int&gt; ans[N];int tagn[N];int main(){ //freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n; cin&gt;&gt;n;cin.get(); for(int i=0;i&lt;n;i++){ getline(cin,tag[i]); //cout&lt;&lt;&quot;when i=&quot;&lt;&lt;i&lt;&lt;&quot;,tag[i]=&quot;&lt;&lt;tag[i]&lt;&lt;endl; //int len=tag[i].length(); auto j=tag[i].begin(); auto k=j; for(;k!=tag[i].end();){ if(*k=='/'){ tags[i][tagn[i]++]=string(j,k); k++; j=k; }else{ k++; } } tags[i][tagn[i]++]=string(j,k); } for(int i=0;i&lt;n;i++){ for(int j=0;j&lt;tagn[i];j++){ //cout&lt;&lt;&quot;tags[&quot;&lt;&lt;i&lt;&lt;&quot;][&quot;&lt;&lt;j&lt;&lt;&quot;]=&quot;&lt;&lt;tags[i][j]&lt;&lt;endl; sset.insert(tags[i][j]); } } int num=0; for(auto i:sset){ //cout&lt;&lt;&quot;test_sset:&quot;&lt;&lt;i&lt;&lt;endl; nmaps[num]=i; smapn[i]=num++; } for(int i=0;i&lt;n;i++){ for(int j=0;j&lt;tagn[i];j++){ ans[smapn[tags[i][j]]].push_back(i); } } for(int i=0;i&lt;num;i++){ cout&lt;&lt;nmaps[i]&lt;&lt;&quot;:&quot;; for(auto j:ans[i]){ cout&lt;&lt;' '&lt;&lt;j+1; } cout&lt;&lt;endl; } return 0;} D# 我，BPM，连连看，启动！ E# 我，胡老师，需要梳子 F# 我，BPM，四级没过 1234567891011121314151617181920212223//#include &lt;bits\\stdc++.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int M=1000000007;long long fpow(long long x,int y){ long long ans=1; while(y){ if(y&amp;1)ans=(ans*x)%M; x=(x*x)%M; y&gt;&gt;=1; } return ans;}int main(){ long long m,n; while(~scanf(&quot;%lld%lld&quot;,&amp;m,&amp;n)){ long long ans=(fpow(m-1,n)+n*fpow(m-1,n-1))%M; printf(&quot;%lld\\n&quot;,ans); } return 0;} G# 我，小南瓜，打钱，出原题 H# 我，czq，H，JHSeng，猪头 线段树。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int N=(1&lt;&lt;17)+5;const int NN=(N&lt;&lt;2);int n,m,a[N],s[NN];void build(int p,int l,int r,int t){ //printf(&quot;build(%d,%d,%d,%d)\\n&quot;,p,l,r,t); if(l==r){ s[p]=a[l]; //printf(&quot;l==r,s[%d]=a[%d]=%d\\n&quot;,p,l,a[l]); return; } int mid=(l+r)&gt;&gt;1; build(p&lt;&lt;1,l,mid,t+1); build(p&lt;&lt;1|1,mid+1,r,t+1); if(t&amp;1)s[p]=s[p&lt;&lt;1]|s[p&lt;&lt;1|1]; else s[p]=s[p&lt;&lt;1]^s[p&lt;&lt;1|1];}int update(int x,int y){ //printf(&quot;update(%d,%d)\\n&quot;,x,y); x=(1&lt;&lt;n)-1+x; //printf(&quot;x=%d\\n&quot;,x); s[x]=y; x&gt;&gt;=1; //printf(&quot;x=%d\\n&quot;,x); int t=1; while(x){ if(t&amp;1)s[x]=s[x&lt;&lt;1]|s[x&lt;&lt;1|1]; else s[x]=s[x&lt;&lt;1]^s[x&lt;&lt;1|1]; t++; x&gt;&gt;=1; } return s[1];}int main(){ //cout&lt;&lt;NN; //freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=(1&lt;&lt;n);i++){ scanf(&quot;%d&quot;,&amp;a[i]); } build(1,1,(1&lt;&lt;n),n&amp;1); /*for(int i=1;i&lt;=4*n;i++){ printf(&quot;s[%d]=%d\\n&quot;,i,s[i]); }*/ for(int i=1;i&lt;=m;i++){ int p,q; scanf(&quot;%d%d&quot;,&amp;p,&amp;q); printf(&quot;%d\\n&quot;,update(p,q)); } return 0;} I# 我，czq，就是喜欢英文，JHSeng，就是要出英文题！ J# 我，小甜甜，才是正义的化身","link":"/posts/scutpc2018-c2/"},{"title":"2019 Java 复习题","text":"选择/填空/判断题知识点# Java 的关键字# 说明：上图是根据书上内容总结的。在Java文档中有特别提到： true, false, and null might seem like keywords, but they are actually literals; you cannot use them as identifiers in your programs. 这三个实际上不是关键字，而是字面量 继承的知识点# Java不支持多重继承 extends子句格式如下 12class SubClass extends SuperClass{} 子类可以继承父类中访问权限设定为public、protected、default的成员变量和方法，但是不能继承访问权限为private的成员变量和方法。 Java中的所有的类最终都是对java.lang.Object类的扩展。 如果没有调用父类的构造方法，Java将自动调用它，在子构造方法的首行执行。 如果不存在(没有参数的)父类构造方法，并且也没有在子类构造方法首行调用其他的(父类)构造方法，这个类将不能编译。 子类通过成员变量的隐藏和方法的重写可以把父类的状态和行为改变为自身的状态和行为。 实现的知识点# implements 实现格式： 123class Calculate extends Computer implements Summary,Substractable{...} 实现一个接口，必须实现该接口的所有方法。 Import# import语句用来引入所需要的类 import语句格式 1import package1[.package2...].(classname|*); package1.package2表示文件目录，classname指明要引入的类，*可以代表该目录下所有类（不包括子目录） Java编译器自动引入包java.lang Try/Catch/Final的运行流程# 捕获异常语法： 123456789try{...}catch(Exception1 e){...}catch(Exception2 e){...}finally{...} 先执行try中的语句，当异常对象抛出时，catch语句从上至下逐个匹配，当捕获一个异常时，剩下的catch语句就不再匹配，执行catch块中的语句。try块中无论是否发生异常，最终都将执行finally语句。 float/int/char/byte/double等类型# 这些都属于Java的数据类型中的基本类型，基本类型还包括布尔类型（boolean）。Java中的数值类型占用位数和数的范围参考下表。 数据类型 所占位数 数的范围 byte 8 $-2^7\\sim (2^7-1)$ short 16 $-2^{15}\\sim (2^{15}-1)$ int 32 $-2^{31}\\sim (2^{31}-1)$ long 64 $-2^{63}\\sim (2^{63}-1)$ float 32 $3.4\\times 10^{-38}\\sim (3.4\\times 10^{38})$ double 64 $1.7\\times 10^{-308}\\sim (1.7\\times 10^{308})$ break/continue# break用于跳出一层（最近的）循环或switch语句、或跳出指定标号的语句块（必须包围break）。 continue用于跳过一次循环，或跳过一次指定标号的循环语句。 String加其他类型的输出结果# 当Java对象与String相加时，会自动调用对象的toString方法把对象转化成字符串再与String相连接。 null对象会转化为“null”，boolean会转换为“true”或者“false”。 其他数据也转换为对应的字符串。 什么是整型数据、整型数据的运算方式# 整型数据即Java的整数类型数据，包括整型常量和整型变量。 表示形式： 表示数据 表示方法 例子 十进制 用0~9的数值表示，首位不能是0 124，-100 八进制 以0开头 0134 十六进制 以0x或0X开头 0x23FE 二进制 以0b开头（可以用下划线分割） 0b1001_1111_1111 long类型 以l或L结尾 41L 整型变量包括byte、short、int、long四种。 整型数据采用补码存储，先计算优先级较高的运算，整型数据与整型数据运算结果也为整型数据。不同类型的数据混合运算时，会先自动转换为表达范围大的类型。 JDK的编译和运行命令# 编译命令javac，后面加文件名（以.java）结尾。中间可以加入编译选项。输入javac -help可以查看编译选项的帮助信息。 12345678910111213141516171819202122232425262728293031323334Usage: javac &lt;options&gt; &lt;source files&gt;where possible options include: -g Generate all debugging info -g:none Generate no debugging info -g:{lines,vars,source} Generate only some debugging info -nowarn Generate no warnings -verbose Output messages about what the compiler is doing -deprecation Output source locations where deprecated APIs are used -classpath &lt;path&gt; Specify where to find user class files and annotation processors -cp &lt;path&gt; Specify where to find user class files and annotation processors -sourcepath &lt;path&gt; Specify where to find input source files -bootclasspath &lt;path&gt; Override location of bootstrap class files -extdirs &lt;dirs&gt; Override location of installed extensions -endorseddirs &lt;dirs&gt; Override location of endorsed standards path -proc:{none,only} Control whether annotation processing and/or compilation is done. -processor &lt;class1&gt;[,&lt;class2&gt;,&lt;class3&gt;...] Names of the annotation processors to run; bypasses default discovery process -processorpath &lt;path&gt; Specify where to find annotation processors -parameters Generate metadata for reflection on method parameters -d &lt;directory&gt; Specify where to place generated class files -s &lt;directory&gt; Specify where to place generated source files -h &lt;directory&gt; Specify where to place generated native header files -implicit:{none,class} Specify whether or not to generate class files for implicitly referenced files -encoding &lt;encoding&gt; Specify character encoding used by source files -source &lt;release&gt; Provide source compatibility with specified release -target &lt;release&gt; Generate class files for specific VM version -profile &lt;profile&gt; Check that API used is available in the specified profile -version Version information -help Print a synopsis of standard options -Akey[=value] Options to pass to annotation processors -X Print a synopsis of nonstandard options -J&lt;flag&gt; Pass &lt;flag&gt; directly to the runtime system -Werror Terminate compilation if warnings occur @&lt;filename&gt; Read options and filenames from file 运行命令java,后面加类名（不带.java后缀）。输入java -h可以查看java解释器的选项帮助信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051Usage: java [-options] class [args...] (to execute a class) or java [-options] -jar jarfile [args...] (to execute a jar file)where options include: -d32 use a 32-bit data model if available -d64 use a 64-bit data model if available -server to select the &quot;server&quot; VM The default VM is server. -cp &lt;class search path of directories and zip/jar files&gt; -classpath &lt;class search path of directories and zip/jar files&gt; A ; separated list of directories, JAR archives, and ZIP archives to search for class files. -D&lt;name&gt;=&lt;value&gt; set a system property -verbose:[class|gc|jni] enable verbose output -version print product version and exit -version:&lt;value&gt; Warning: this feature is deprecated and will be removed in a future release. require the specified version to run -showversion print product version and continue -jre-restrict-search | -no-jre-restrict-search Warning: this feature is deprecated and will be removed in a future release. include/exclude user private JREs in the version search -? -help print this help message -X print help on non-standard options -ea[:&lt;packagename&gt;...|:&lt;classname&gt;] -enableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;] enable assertions with specified granularity -da[:&lt;packagename&gt;...|:&lt;classname&gt;] -disableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;] disable assertions with specified granularity -esa | -enablesystemassertions enable system assertions -dsa | -disablesystemassertions disable system assertions -agentlib:&lt;libname&gt;[=&lt;options&gt;] load native agent library &lt;libname&gt;, e.g. -agentlib:hprof see also, -agentlib:jdwp=help and -agentlib:hprof=help -agentpath:&lt;pathname&gt;[=&lt;options&gt;] load native agent library by full pathname -javaagent:&lt;jarpath&gt;[=&lt;options&gt;] load Java programming language agent, see java.lang.instrument -splash:&lt;imagepath&gt; show splash screen with specified imageSee http://www.oracle.com/technetwork/java/javase/documentation/index.html for more details. Java数据类型哪两类# 基本类型和引用类型。 Java中基本类型的内存空间，char的Unicode编码方式的内存空间，字符占多少个字节# 数据类型 所占位数 char 16 byte 8 short 16 int 32 long 64 float 32 double 64 注意：根据Java官方文档描述，boolean类型的大小并没有精确定义。 This data type represents one bit of information, but its “size” isn’t something that’s precisely defined. char的Unicode编码方式，无论中英文都是占用两个字节。 匿名内部类的定义、局部内部类的定义# 匿名内部类定义： 1234567891011121314class Out{ void show(){ ... }}public class Main{ public static void main(String[] args){ Out Annoy=new Out(){ void show(){ ... } } }} 局部内部类定义： 1234567891011121314class Out{ void show(){ ... }}public class Main{ public static void main(String[] args){ class Inner extends Out{ void show(){ ... } } }} super的几种用法# 访问父类被隐藏的成员变量 调用父类中被重写的方法 调用父类的构造方法 抽象方法和抽象类# 用abstract关键字修饰方法和类时，分别称为抽象方法和抽象类。 抽象方法不含方法体。 如果一个类中含有抽象方法，那么这个类必为抽象类。 抽象类中也可以没有抽象方法。 抽象类不能被实例化。 抽象类被继承时，抽象方法必须被重写。 接口中的方法默认为抽象方法。 变量、类、方法的命名规则# 变量、类、方法名均需要是合法的标识符。 Java中的标识符命名规则： 大小写敏感 没有长度限制 不能和关键词相同 不能为字面值常量（false、true、null） 不能包含空格，特殊符号 不能以数字开头 所含字符必须是Unicode字符集内字符 一些特殊例子： String String=new String(&quot;String&quot;); int 五=5; 接口及其修饰的关键词# 接口的定义格式如下： 123[public] interface interfaceName [extends listOfSuperInterface]{ ...} package# package语句作为Java源文件的第一条语句，指明该文件中定义的类所在的包。 Java编译器把包对应于文件系统的目录。 若省略了package语句，源文件中定义命名的类被隐含地认为是无名包的一部分。 ==和equals# 对于基本类型，==比较值是否相等。 对于类，==和equals都是比较对象在内存中的存放地址。 对于内置类（String、Date、Integer等），==比较内存地址，equals被重写（一般是比较值）。 JAVA当中所有的类都是继承于Object这个基类的，在Object中的基类中定义了一个equals的方法，这个方法的初始行为是比较对象的内存地址。 什么是Java的起始类# 注：起始类更通用的说法是主类 Java 应用程序是由若干类和接口组成的，为了使Java 应用程序能够运行，至少要有一个类含有main()主方法，因为main()主方法是Java 应用程序的入口点，Java 应用程序就是从这里开始运行的，我们把含有main()主方法的类称为Java 应用程序的主类。 main方法定义格式为： 123public static void main(String[] args){ ...} 简答题# 请简述Java集合框架中Collection和Map的区别# Collection接口是集合框架的基础，它声明所有类集合都将拥有的核心方法，主要有添加、删除、清空。 Map接口是一个存储关键字/值对的集合。给定一个关键字，可以得到它的值。关键字和值都是对象，每一对关键字/值，称为一项。关键字必须是唯一的，但值可以重复。Map接口中定义的主要方法有利用关键字获取值（get）、将项加入Map等（put）。 请简述Java和C++的异同# 同： 语法类似于C++ 均支持面向对象特性 均为静态显式强类型语言（即必须指定每个变量的类型、编译时即可确定变量的数据类型） 注：C++由于支持隐式类型转换，强弱界线比较模糊。 异： Java是完全面向对象的语言，无法定义全局变量，所有数据操作都封装在类中。 Java中无法使用指针操作内存。 Java中的数组使用类管理，避免数组越界。 Java自动地进行内存管理和垃圾收集。 C++中可以通过指针进行任意的类型转换，而Java会进行相容性检查。 Java不支持预处理、多重继承、运算符重载、默认函数参数、goto语句 C++性能好、Java效率高 Java中的泛型与C++中的模板本质上截然不同。Java中的泛型是通过“类型清除”来实现的，编译器在编译时根据类型信息生成强制类型转换代码。而C++中的模板实质是一套宏指令集，编译器会对每种类型创建一份模板代码副本。 默认类型访问权限和保护类型访问权限有何异同？# 默认类型访问权限限定在同一个类中和同一个包中，不同包中的类无法访问。 保护类型访问权限限定在同一个类、同一个包以及不同包中的子类，不同包中的非子类无法访问。 简述泛型的作用# 泛型提供了一种编译时类型安全检查功能，并能减少类型强制转化的麻烦。使用泛型可以清除不安全的类型转化，省去进行类型转换的代码。 当构造一个类的实例时，Java编译器主要完成的三个步骤是什么？# 第一步：对象的声明 第二步：为声明的对象分配内存 第三步：执行构造方法，进行初始化 TCP协议和UDP协议的区别# TCP协议具有高度的可靠性，能保证数据顺利抵达目的地，且收到的字节顺序和发出顺序一致。 而UDP协议不保证通信对端存在，在丢包时不负责重发，顺序混乱时也不会自动纠正，但速度快得多。 参考资料1 参考资料2 TCPIP网络协议层对应的RFC文档 RFC文档官网 TCP协议文档 UDP协议文档 请简述Java集合框架中迭代器和比较器的作用# 迭代器：使用迭代器可以依次访问类集中的元素，迭代器是一个实现Iterator或ListIterator接口的对象。Iterator可以遍历类集中的元素，获得和删除元素。ListIterator继承Iterator，允许双向遍历列表，并可以修改。 比较器：如果需要用不同方法对元素进行排序，可以在构造集合或映射时，指定一个Comparator对象。Comparator接口定义了两种方法：compare()和equals()。compare()方法比较了两个元素，确定它们的顺序。通过创建一个比较器，可以实现元素按自定义顺序排列。 请简述Java中的两种异常处理机制# 捕获异常 在Java程序运行过程中系统得到一个异常对象时，它将会沿着方法的调用栈逐层回溯，寻找处理这一异常的代码。找到能处理这一异常的方法后，运行时系统把当前异常对象交给这个方法处理，这一过程称为捕获异常。若找不到此方法，则运行时系统将终止。 声明抛出异常 在Java程序运行过程中系统得到一个异常对象时，如果一个方法并不知道如何处理所出现的异常，则可在方法声明时，声明抛出异常。 请简述Java异常处理中运行时异常和非运行时异常的区别# 运行时异常（RuntimeException），这类异常事件的生成是很普遍的，要求程序全部对这类异常做出处理可能对程序的可读性和高效性带来不好的影响，因此Java编译器允许程序不对它们做出处理。当然，必要时也可以处理运行时异常。 非运行时异常（Exception），对于这类异常来说，如果程序不进行处理，可能会带来意想不到的结果，因此Java编译器要求程序必须捕获或声明抛弃这种异常。 Java中的常见异常种类 请简述final关键字的具体作用# 修饰成员变量 这个成员变量就成了常量，一经赋值，无法更改。 修饰方法 表明该方法不能被子类覆盖。 修饰类 表示该类不能被继承（如String类）。 请简述static关键字的具体作用# 修饰成员变量 static修饰的成员变量称为类变量或静态变量，为该类的所有对象共享。 修饰方法 称为静态方法或类方法，是该类所有对象共享的方法。 修饰代码块 形成静态代码块，代码块可以放在类内任何地方，但不能是方法内部，不能放在内部类或匿名类中。代码在类加载时按照定义顺序运行一次。 请简述重载的作用# 方法重载就是一个类中可以有多个方法具有相同的名称，但这些方法的参数必须不同，或是返回值不同。当调用一个重载方法时，JVM自动根据当前对方法的调用形式在类的定义中匹配形式符合的成员方法。重载是Java实现（编译时）多态性的方式之一。 请简述重写覆盖的作用# 子类通过成员变量的隐藏和方法的重写可以把父类的状态和行为改变为自身的状态和行为。一个对象可以通过引用子类的实例来调用子类的方法，这实现了（运行时）多态。 请简述类、抽象类、接口的不同# 定义方式不同。抽象类需要在普通类定义前加abstract关键字，而接口通过interface关键字定义。 使用方法不同。类可以实例化为对象，抽象类和接口不能实例化。抽象类需要被类继承来使用，而接口需要被类实现来使用。类只能继承一个类，可以实现多个接口。 定义权限不同。类和抽象类中的方法需要指明修饰符，而接口中的只能定义常量和方法，常量默认具有public、static、final属性，方法默认具有public、abstract属性。抽象类和接口中均可添加非抽象的方法实现，但接口中需要用default关键字声明。 请对比类成员、类方法和对象成员、对象方法的区别# 类成员和类方法需要用static关键字声明，与类联系在一起，类无需实例化即可调用，但也可通过类的实例调用。 类方法中不能对类的对象成员进行操作。 类方法中不能使用this、super 请简述线程创建的几种方式，还有请简述各自的优缺点。# 线程创建主要有两种方法：继承Thread类或实现接口Runnable 1.继承Thread类，并覆盖run()方法，然后调用start()方法启动线程。 优点：实现简单，代码较少。 缺点：无法再继承其他类 2.实现Runnable接口中的run()方法。再创建Thread类的实例，使用构造方法初始化，再调用该实例的start()方法启动线程。 优点：还可以继承其他类 缺点：实现略微更复杂 请简述String中的equals的作用，用代码来解释它的功能# String中的equals的作用是比较当前字符串对象的实体与参数指定的字符串的实体是否相同。 例如有以下定义： 123String a=new String(&quot;a&quot;);String b=new String(&quot;b&quot;);String c=new String(&quot;a&quot;); 则a.equals(b)为false，而a.equals(c)为true。 注意a==c为false，因为字符串是对象，而==比较的是对象在内存中的地址。 看代码写结果# 内部类与外部类之间的访问# 12345678910111213141516171819202122public class GroupTwo { private int count; public class Student { String name; public Student(String n1) { name = n1; count++; } public void Output() { System.out.println(this.name); } } public void output() { Student s1 = new Student(&quot;Johnson&quot;); s1.Output(); System.out.println(&quot;count=&quot; + this.count); } public static void main(String args[]) { GroupTwo g2 = new GroupTwo(); g2.output(); }} 运行结果： 12Johnsoncount=1 内部类访问外部静态变量# 123456789101112131415161718192021222324public class GroupThree { private static int count; private String name; public class Student { private int count; private String name; public void Output(int count) { count++; this.count++; GroupThree.count++; GroupThree.this.count++; System.out.println(count + &quot; &quot; + this.count + &quot; &quot; + GroupThree.count+ &quot; &quot; + GroupThree.this.count++); } } public Student aStu() { return new Student(); } public static void main(String args[]) { GroupThree g3 = new GroupThree(); g3.count = 10; GroupThree.Student s1 = g3.aStu(); GroupThree.Student s1.Output(5); }} 运行结果： 16 1 12 12 构造方法的重载# 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Box{ double width; double height; double depth; //construct clone of an object Box(Box ob){//pass object to constructor width=ob.width; height=ob.height; depth=ob.depth; } //constructor used when all dimensions specified Box(double w,double h,double d){ width=w; height=h; depth=d; } //constructor used when no dimensions specified Box(){ width=-1; height=-1; depth=-1; } //constructor used when cube is created Box(double len){ width=height=depth=len; } //compute and return volume double volume(){ return width*height*depth; }}class OverloadCons2{ public static void main(String args[]){ //create boxes using the various constructors Box mybox1=new Box(10,20,15); Box mybox2=new Box(); Box mycube=new Box(7); Box myclone=new Box(mybox1); double vol; //get volume of first box vol=mybox1.volume(); System.out.println(&quot;Volume of mybox1 is &quot;+vol); //get volume of second box vol=mybox2.volume(); System.out.println(&quot;Volume of mybox2 is &quot;+vol); //get volume of cube vol=mycube.volume(); System.out.println(&quot;Volume of cube is &quot;+vol); //get volume of clone vol=myclone.volume(); System.out.println(&quot;Volume of clone is &quot;+vol); }} 运行结果： 1234Volume of mybox1 is 3000.0Volume of mybox2 is -1.0Volume of cube is 343.0Volume of clone is 3000.0 成员变量的覆盖# 123456789101112131415161718192021222324252627282930313233public class Class3 { public static void main(String args[]) { SubSubClass x = new SubSubClass(10, 20, 30); x.show(); }}class SuperClass { int a, b; SuperClass(int aa, int bb) { a = aa; b = bb; } void show() { System.out.println(&quot;a=&quot; + a + &quot;\\nb=&quot; + b); }}class SubClass extends SuperClass { int c; SubClass(int aa, int bb, int cc) { super(aa, bb); c = cc; }}class SubSubClass extends SubClass { int a; SubSubClass(int aa, int bb, int cc) { super(aa, bb, cc); a = aa + bb + cc; } void show() { System.out.println(&quot;a=&quot; + a + &quot;\\nb=&quot; + b + &quot;\\nc=&quot; + c); }} 运行结果： 123a=60b=20c=30 super关键字的使用# 1234567891011121314151617181920212223242526272829class superClass { int y; superClass() { y = 30; System.out.println(&quot;in superClass:y=&quot; + y); } void doPrint() { System.out.println(&quot;In superClass.doPrint()&quot;); }}class subClass extends superClass { int y; subClass() { super(); y = 50; System.out.println(&quot;in subClass:y=&quot; + y); } void doPrint() { super.doPrint(); System.out.println(&quot;in subClass.doPrint()&quot;); System.out.println(&quot;super.y=&quot; + super.y + &quot; sub.y=&quot; + y); }}public class inviteSuper { public static void main(String args[]) { subClass subSC = new subClass(); subSC.doPrint(); }} 运行结果： 12345in superClass:y=30in subClass:y=50In superClass.doPrint()in subClass.doPrint()super.y=30 sub.y=50 继承# 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class SmallPlate { SmallPlate(int i) { System.out.println(&quot;Plate constructor&quot;); }}class DinnerPlate extends SmallPlate { DinnerPlate(int i) { super(i); System.out.println(&quot;DinnerPlate constructor&quot;); }} class Utensil { Utensil(int i) { System.out.println(&quot;Utensil constructor&quot;); }}class Spoon extends Utensil { Spoon(int i) { super(i); System.out.println(&quot;Spoon constructor&quot;); }}class Fork extends Utensil { Fork(int i) { super(i); System.out.println(&quot;Fork constructor&quot;); }} class Knife extends Utensil { Knife(int i) { super(i); System.out.println(&quot;Knife constructor&quot;); }}// A cultural way of doing something:class Custom { Custom(int i) { System.out.println(&quot;Custom constructor&quot;); }} public class PlaceSetting extends Custom { private Spoon sp; private Fork frk; private Knife kn; private DinnerPlate pl; public PlaceSetting(int i) { super(i + 1); sp = new Spoon(i + 2); frk = new Fork(i + 3); kn = new Knife(i + 4); pl = new DinnerPlate(i + 5); System.out.println(&quot;PlaceSetting constructor&quot;); } public static void main(String[] args) { PlaceSetting x = new PlaceSetting(9); }} 运行结果： 12345678910Custom constructorUtensil constructorSpoon constructorUtensil constructorFork constructorUtensil constructorKnife constructorPlate constructorDinnerPlate constructorPlaceSetting constructor 编程题# 在本机建立一个多线程的服务端，接收本机客户端的连接请求，当客户端向服务端发送“Hello Java!”，服务端回复“Nice Work!”。（要求服务端，客户端都是多线程） 服务端程序： 123456789101112131415161718192021222324252627import java.io.*;import java.net.*;public class Server implements Runnable{ Socket client; BufferedReader in; PrintWriter out; public Server(Socket client)throws IOException{ this.client=client; in=new BufferedReader(new InputStreamReader(client.getInputStream())); out=new PrintWriter(new BufferedWriter(new OutputStreamWriter(client.getOutputStream())),true); } public void run(){ try{ String str=in.readLine(); System.out.println(str); out.println(&quot;Nice Work!&quot;); client.close(); }catch(IOException e){} } public static void main(String[] args)throws IOException{ ServerSocket server=new ServerSocket(1008); while(true){ Socket client=server.accept(); new Thread(new Server(client)).start(); } }} 客户端程序： 12345678910111213141516171819202122232425import java.io.*;import java.net.*;public class Client extends Thread{ Socket client; BufferedReader in; PrintWriter out; public Client()throws IOException{ client=new Socket(&quot;127.0.0.1&quot;,1008); in=new BufferedReader(new InputStreamReader(client.getInputStream())); out=new PrintWriter(new BufferedWriter(new OutputStreamWriter(client.getOutputStream())),true); } public void run(){ try{ out.println(&quot;Hello Java!&quot;); String str=in.readLine(); System.out.println(str); client.close(); }catch(IOException e){} } public static void main(String[] args)throws IOException{ for(int i=1;i&lt;=5;i++){ (new Client()).start(); } }} 运行结果：","link":"/posts/java-review/"},{"title":"Markdown学习","text":"Markdown与标记语言介绍# Markdown是一种轻量级标记语言。那么什么是标记语言（Markup Language）呢？记得以前在课本上看到关键句子的时候，我通常会用黑笔在句子下面划线，比如下面这样： 当代大学生要坚定理想信念，自觉做中国特色社会主义共同理想的坚定信仰者、忠诚实践者。为此，就要深入学习马克思主义基本原理及马克思主义中国化的理论成果，特别是学习习近平新时代中国特色社会主义思想，让真理武装我们的头脑，让真理指引我们的理想，让真理坚定我们的信仰。要坚持学而信、学而用、学而行，把学习成果转化为不可撼动的理想信念，转化为正确的世界观、人生观、价值观，用理想之光照亮奋斗之路，用信仰之力开创美好未来。当代青年要积极投身新时代中国特色社会主义事业，勇做担当中华民族伟大复兴大任的时代新人。要以勇于担当的精神，做走在新时代前列的奋进者、开拓者、奉献者，以执着的信念、优良的品德、丰富的知识、过硬的本领，同人民群众一道，担负起历史赋予的重任，在实现中华民族伟大复兴中国梦的生动实践中放飞青春梦想。 显然，在标记出重点之后，一眼就能看出大段文字中的关键之处。那么如何表达这种标记呢？用word的同学可能会告诉我：“很简单啊，先用鼠标选中需要标记的文字，然后点一下菜单上的下划线按钮就好了。”word的功能确实很强大，甚至有点臃肿了，而且安装起来不是很方便。更进一步的，word是如何保存这种标记的呢？用压缩软件打开一个word文档，你会发现里面有很多xml文件，而xml的全称是可扩展标记语言（Extensible Markup Language）。也就是说，word实际上也是通过一种标记语言来保存这些标记信息的。 通常来说，标记语言都是长这样的：（例子来自菜鸟教程） 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;note&gt; &lt;to&gt;Tove&lt;/to&gt; &lt;from&gt;Jani&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don't forget me this weekend!&lt;/body&gt;&lt;/note&gt; 不用我解释你大概也能知道上面标记语言表达的意思：它描述了一封Jani 写给 Tove 的便签，标题为Reminder，内容为Don’t forget me this weekend!。注意到上面的标记和我之前说的标记其实含义是不同的，这里的标记指的是内容的含义，而上面的标记指的是文字的外观。我今天准备学习的Markdown的标记就是指标记文字的外观。来看一个用标记语言描述外观的例子： 1&lt;p&gt;自三峡七百里中，两岸连山，略无&lt;b&gt;阙&lt;/b&gt;处。重岩叠&lt;b&gt;嶂&lt;/b&gt;，隐天蔽日，自非亭午夜分，不见&lt;b&gt;曦&lt;/b&gt;月。&lt;/p&gt; 可以发现，如果不解释的话，很难看出这些标记的意思，事实上这不是标记语言的缺陷，而是为了书写方便，把段落（paragraph）缩写成p，粗体（bold）缩写成b。这样大概就能看出它的意思了，描述了一个段落，其中加粗了三个字。这个例子的标记确实可以完成标记文字外观的功能，但是他有一个缺点——不直观。在word中，加粗、下划线都可以直观的看到，而不用像上面的标记一样在脑海中想象。为了解决这个问题，一种轻量级标记语言诞生了。 先来看看一个非常简单的Markdown的例子： 12至于夏水**襄陵**，沿**溯**阻绝。或王命急宣，有时朝发白帝，暮到江陵，其间千二百里，虽乘奔御风，不以疾也。 这和上面的标记语言的功能是类似的，同样是描述一个段落、加粗几个字。可以发现Markdown的语法非常直观，甚至你都没有感受到它用了Markdown的段落语法（空行）。 使用Markdown的方式# 由于简单的标记语法，你甚至可以直接使用系统自带的记事本软件来编写Markdown文档。但我并不推荐这样做，就像不推荐用记事本写C++代码一样。如果你对代码比较感兴趣，更喜欢手动编辑修改代码的话，我推荐使用左右分栏的预览模式，例如Cmd Markdown编辑阅读器，MarkdownEditor、马克飞象以及Editor.md，当然利用编辑模式和阅读模式区分的VNote也是一个不错的选择，能让你更加专注于写作。如果你比较厌烦这些标记，那么在原地渲染、隐藏标记的Typora，以及类似的网页端Writing Different也不错。另外，直接用现代的代码编辑器如Visual Studio Code、Sublime Text、Atom来编写Markdown也非常不错。网页端和本地客户端各有各的使用场景，选择适合自己的就好。另外，实现一个简单的Markdown编辑器并不难，难的是如何找到写作与排版二者的平衡，找到Markdown最合适的应用场景（如Github的README文件）。 Markdown语法指南# 事实上Markdown并没有一个标准的语法规则定义，各种平台所支持的Markdown标准也都大同小异。目前我看到最细致的定义可以在CommonMark找到。如果想进一步了解Markdown可以访问Github Mastering Markdown、SegmentFault Markdown 编辑器语法指南、牛客网 Markdown 语法说明、少数派 Markdown 完全入门（上） 、（下）。 下面把我以前学习Markdown时写的一篇文档再抄一遍，就当是测试页面的渲染效果了吧。注意Markdown往往是兼容HTML的，所以如果有些效果使用Markdown无法实现可以考虑使用HTML实现。以下仅仅说明一些广泛使用，兼容性好的Markdown语法。 标题# 123456# 第一部## 第一卷### 第一回#### 第一节##### 第一段###### 第一句 # 第一部 ## 第一卷 ### 第一回 #### 第一节 ##### 第一段 ###### 第一句 #之后一般需要至少一个空格 标题应该单独占一行 如果上面的内容没有显示出来，通常是为了不干扰文章目录而特殊处理了 标题还有一些特殊写法如文字下加---，在此不做介绍 字体# 12**粗体**和*斜体*往往用于产生强调作用，本质上是因为__粗体__和_斜体_对阅读者产生了干扰，降低了阅读者的阅读速度。因此大段的***粗斜体***，是不必要的，效果会___适得其反___。~~删除线~~使用的范围就比较广泛了，通常用于批改审阅，团队协作，公共编辑中保留证据，或许还是~~一种娱乐方式~~？ 粗体和斜体往往用于产生强调作用，本质上是因为 粗体 和 斜体 对阅读者产生了干扰，降低了阅读者的阅读速度。因此大段的 粗斜体，是不必要的，效果会 适得其反 。 删除线使用的范围就比较广泛了，通常用于批改审阅，团队协作，公共编辑中保留证据，或许还是一种娱乐方式？ 推荐使用更加通用的*写法 若出现错误可在标记前后添加一个空格 用删除线标记的内容并不会真的删除-_- 列表# 无序列表： 常见的编程语言有： 1234567* C* C++* Python * Python2 * Python3* Java* PHP C C++ Python Python2 Python3 Java PHP 有序列表： Windows版本历程： 1234567891. Windows 2000 （2000年-2005年）2. Windows XP （2001年-2014年） 1. Windows XP SP1 （2002年） 2. Windows XP SP2 （2004年） 3. Windows XP SP3 （2008年）4. Windows 7 （2009年-2015年） 1. Windows 7 SP1 （2011年）5. Windows 8 （2012年-2018年）6. Windows 10 （2015年至今） Windows 2000 （2000年-2005年） Windows XP （2001年-2014年） Windows XP SP1 （2002年） Windows XP SP2 （2004年） Windows XP SP3 （2008年） Windows 7 （2009年-2015年） Windows 7 SP1 （2011年） Windows 8 （2012年-2018年） Windows 10 （2015年至今） 有序列表前的序号通常会被重新标注 使用一个空行来结束列表 表格# 123456789101112131415linux主流发行版参考表：| 发行版 | 评价 || :--------: | :---------------------------------- || Ubuntu | Linux 新用户的完美起点 || Debian | 现代 Linux 版本的始祖 || Mint | 易于使用且功能强大,基于Ubuntu开发 || Deepin | 基于 Ubuntu 的发行版,界面简单直观 || Arch Linux | 为经验丰富的用户而设计的发行版 || Kali Linux | 渗透测试发行版 || Fedora | 社区构建的面向日常应用的发行版 || Red Hat | Fedora的商业衍生产品，专为企业客户设计 || CentOS | 由社区重建的Red Hat企业版Linux || SUSE Linux | 专为企业使用而设计 | linux主流发行版参考表： 发行版 评价 Ubuntu Linux 新用户的完美起点 Debian 现代 Linux 版本的始祖 Mint 易于使用且功能强大,基于Ubuntu开发 Deepin 基于 Ubuntu 的发行版,界面简单直观 Arch Linux 为经验丰富的用户而设计的发行版 Kali Linux 渗透测试发行版 Fedora 社区构建的面向日常应用的发行版 Red Hat Fedora的商业衍生产品，专为企业客户设计 CentOS 由社区重建的Red Hat企业版Linux SUSE Linux 专为企业使用而设计 可以利用冒号位置调节列的位置，如:---:表示居中，:---表示靠左。 一般在表格前后均添加一个空行 链接# 123http://www.baidu.com[搜狗](https://www.sogou.com/)[Yadex](https://yandex.com/) http://www.baidu.com Yadex Google 部分渲染器支持将纯文本链接转化为链接（自动链接） 图片# 12![黑客](../asset/hacker.webp)![矩阵](../asset/matrix.webp &quot;矩阵&quot;) 链接后面的说明信息会在鼠标悬停时显示 引用# 12345&gt; 《前赤壁赋》 苏轼&gt;&gt; 客曰：“‘月明星稀，乌鹊南飞’此非曹孟德之诗乎？西望夏口，东望武昌，山川相缪，郁乎苍苍，此非孟德之困于周郎者乎？方其破荆州，下江陵，顺流而东也，舳舻千里，旌旗蔽空，酾酒临江，横槊赋诗，固一世之雄也，而今安在哉？况吾与子渔樵于江渚之上，侣鱼虾而友麋鹿；驾一叶之扁舟，举匏樽以相属。寄蜉蝣于天地，渺沧海之一粟。哀吾生之须臾，羡长江之无穷。挟飞仙以遨游，抱明月而长终。知不可乎骤得，托遗响于悲风。”&gt;&gt;&gt;&gt; 苏子曰：“客亦知夫水与月乎？逝者如斯，而未尝往也；盈虚者如彼，而卒莫消长也，盖将自其变者而观之，则天地曾不能以一瞬；自其不变者而观之，则物与我皆无尽也，而又何羡乎？且夫天地之间，物各有主，苟非吾之所有，虽一毫而莫取。惟江上之清风，与山间之明月，耳得之而为声，目遇之而成色，取之无禁，用之不竭，是造物者之无尽藏也，而吾与子之所共适。” 《前赤壁赋》 苏轼 客曰：“‘月明星稀，乌鹊南飞’此非曹孟德之诗乎？西望夏口，东望武昌，山川相缪，郁乎苍苍，此非孟德之困于周郎者乎？方其破荆州，下江陵，顺流而东也，舳舻千里，旌旗蔽空，酾酒临江，横槊赋诗，固一世之雄也，而今安在哉？况吾与子渔樵于江渚之上，侣鱼虾而友麋鹿；驾一叶之扁舟，举匏樽以相属。寄蜉蝣于天地，渺沧海之一粟。哀吾生之须臾，羡长江之无穷。挟飞仙以遨游，抱明月而长终。知不可乎骤得，托遗响于悲风。” 苏子曰：“客亦知夫水与月乎？逝者如斯，而未尝往也；盈虚者如彼，而卒莫消长也，盖将自其变者而观之，则天地曾不能以一瞬；自其不变者而观之，则物与我皆无尽也，而又何羡乎？且夫天地之间，物各有主，苟非吾之所有，虽一毫而莫取。惟江上之清风，与山间之明月，耳得之而为声，目遇之而成色，取之无禁，用之不竭，是造物者之无尽藏也，而吾与子之所共适。” &gt;后面需要至少一个空格 需要一个空行来结束引用 分割线# 1234567891011121314分割线通常是用来分割装饰文字~~凑字数~~的，它可以让文字更加美观。！！！！！！这是一个分割线，看到这里想必也累了，可以放松一下！！！！！上面是假的分割线，下面的才是真的！-------******* 分割线通常是用来分割装饰文字凑字数的，它可以让文字更加美观。 ！！！！！！这是一个分割线，看到这里想必也累了，可以放松一下！！！！！ 上面是假的分割线，下面的才是真的！ 需要三个或三个以上标记 需要单独占据一行 显示效果可能会有粗细上的差别 行内代码# 1234有时候需要用到一些特殊符号，如`*`，`&gt;`这些与Markdown的标记相冲突，或是想`printf(&quot;代码&quot;);`在文字中，就可以使用行内代码。这时只需用两个`` ` ``包围内容。注意：* `` ` `` 是反引号，通常在Esc键下方（键盘的左上方）* 如果需要显示一个`` ` `` 那么要用两个`` ` `` 包围它 有时候需要用到一些特殊符号，如*，&gt;这些与Markdown的标记相冲突，或是想printf(&quot;代码&quot;);在文字中，就可以使用行内代码。这时只需用两个`包围内容。 ` 是反引号，通常在Esc键下方（键盘的左上方） 如果需要显示一个` 那么要用两个` 包围它 代码块# 代码块可以在文章中便捷地插入一段代码，来回顾一下经典的helloworld代码吧！ C++版本： 123456#include &lt;iostream&gt;using namespace std;int main(){ cout&lt;&lt;&quot;hello world!&quot;&lt;&lt;endl; return 0;} Java版本： 12345public class Main{ public static void main(String[] args){ System.out.println(&quot;hello world!&quot;); }} C++版本： 123456#include &lt;iostream&gt;using namespace std;int main(){ cout&lt;&lt;&quot;hello world!&quot;&lt;&lt;endl; return 0;} Java版本： 12345public class Main{ public static void main(String[] args){ System.out.println(&quot;hello world!&quot;); }} 还可以简单地选中代码后按tab键来形成代码块 任务列表# 123近代中国的两大历史任务：- [x] 求得民族独立和人民解放- [ ] 实现国家的繁荣富强和人民的共同富裕 近代中国的两大历史任务： [x] 求得民族独立和人民解放 [ ] 实现国家的繁荣富强和人民的共同富裕 数学公式# Markdown本身是不支持数学公式的，通常靠其他工具的支持如Mathjax、Katex。这些工具配置、学习起来都比较麻烦。想进一步了解可以访问官网，或者查阅以下资料： 前端整合MathjaxJS的配置笔记 MathJax的一些坑 行内公式 1在数理统计中，若$X \\sim \\Gamma(\\frac n 2 , \\frac 1 2)$，则称 $X$ 服从**自由度为** $n$ **的** $\\chi^2$ **分布**，记为$X\\sim \\chi^2(n)$ 在数理统计中，若 $X \\sim \\Gamma(\\frac n 2 , \\frac 1 2)$ ，则称 $X$ 服从自由度为 $n$ 的 $\\chi^2$ 分布，记为$X\\sim \\chi^2(n)$ 为了更好的兼容性，可以在$$外侧添加一个空格。 块公式 123$$x=\\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}$$ $$ x=\\frac{-b \\pm \\sqrt{b^2-4ac}}{2a} $$ 写在最后# 写本文的目的主要是总结整理一下我了解到的关于Markdown的知识，同时顺便测试一下目前博客的渲染效果和对Markdown的支持效果。并不是推荐Markdown或者是推荐某个软件。在我看来，使用Markdown能给我一种自由的感觉，这就足够了。顺便提一句，如果你想测试一下Markdown的话，下面评论框是个不错的选择。😀","link":"/posts/learn-markdown/"},{"title":"Windows下Web开发环境搭建","text":"虽然Web程序大多运行在Linux服务器上，从兼容性角度来说，当然是在与服务器一致的环境下开发最好。但是我本地的机器是Windows系统，实在要用Linux的时候是采用虚拟机的方式。在虚拟机里面写代码着实麻烦，因此还是决定在Windows下搭建一套Web开发环境，方便测试。 我选择的Web开发组件是WNMP（Windows+Nginx+MySQL+PHP）。 Nginx下载安装启动# Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。目前我主要使用它的HTTP代理功能。在下载页面可以选择需要的版本下载，用于测试可以选择Mainline version，当前的最新版本是1.19.0。我直接使用Scoop安装。 安装好后在命令行窗口运行：start nginx。（注意直接运行nginx可能导致命令行无法退出） 如果出现以下错误信息： 1234nginx: [alert] could not open error log file: CreateFile() &quot;logs/error.log&quot; failed (3: The system cannot find the path specified) 2020/06/14 21:39:05 [emerg] 1444#13520: CreateFile() &quot;C:\\Users\\awesome/conf/nginx.conf&quot; failed (3: The system cannot find the path specified) 说明当前路径不对，需要到安装目录下运行，我这里是[C:\\Users\\awesome\\scoop\\apps\\nginx\\current](file:///C:/Users/awesome/scoop/apps/nginx/current)，或者利用-p选项指定安装路径也可以。允许通过防火墙后，就运行成功了。注意命令行界面是没有显示的。可以打开浏览器，访问http://localhost/，如果出现以下画面就说明安装成功了。 如果要停止Nginx，可以输入nginx -s stop，官网的简短的使用说明可以参考一下。 将Nginx注册成系统服务# 如果想让Nginx自动运行，最好的办法是把它注册成系统服务。我这里使用了winsw这个小工具。在下载页面选择合适的版本下载，我选的是WinSW.NET461.exe，可以同时下载一份配置文件sample-minimal.xml。 下载好后，参考这篇博客进行配置。我就简单记录一下我的配置过程。将WinSW.NET461.exe复制一份到[nginx.exe所在目录](file:///C:/Users/awesome/scoop/apps/nginx/current)，重命名为nginx-server.exe，在同目录下创建配置文件nginx-server.xml，内容如下：（配置文档） 12345678&lt;service&gt; &lt;id&gt;nginx&lt;/id&gt; &lt;name&gt;Nginx&lt;/name&gt; &lt;description&gt;nginx [engine x] is an HTTP and reverse proxy server, a mail proxy server, and a generic TCP/UDP proxy server, originally written by Igor Sysoev. &lt;/description&gt; &lt;executable&gt;C:\\Users\\awesome\\scoop\\apps\\nginx\\current\\nginx.exe&lt;/executable&gt; &lt;startarguments&gt;-p C:\\Users\\awesome\\scoop\\apps\\nginx\\current&lt;/startarguments&gt; &lt;stoparguments&gt;-p C:\\Users\\awesome\\scoop\\apps\\nginx\\current -s stop&lt;/stoparguments&gt;&lt;/service&gt; 在当前目录下以管理员权限打开命令提示符运行以下命令安装服务： 12C:\\Users\\awesome\\scoop\\apps\\nginx\\current&gt;nginx-server.exe install2020-06-14 22:00:46,957 INFO - Installing the service with id 'nginx' 在命令行下可以使用sc命令查询服务情况（注意该命令在PowerShell下需要改为sc.exe）： 1234567C:\\Users\\awesome\\scoop\\apps\\nginx\\current&gt;sc query nginx SERVICE_NAME: nginx TYPE : 10 WIN32_OWN_PROCESS STATE : 1 STOPPEDWIN32_EXIT_CODE : 1077 (0x435)SERVICE_EXIT_CODE : 0 (0x0)CHECKPOINT : 0x0WAIT_HINT : 0x0 sc query命令文档 可以看到目前Nginx服务是关闭的，如果之前运行的nginx.exe还在运行可以在任务管理器中结束任务。此时应该是无法访问localhost的了。接下来使用服务运行nginx。 123C:\\Users\\awesome\\scoop\\apps\\nginx\\current&gt;net start nginxnginx 服务正在启动 . nginx 服务已经启动成功。 或者直接使用sc命令：sc start nginx。这两个命令有略微的区别，sc命令会马上退出，此时nginx在等待启动，而net命令则会等到服务启动完成后再退出。 以后系统开机会自动运行Nginx服务，如果想取消可以使用sc config nginx start= demand命令改为手动运行。 sc config命令文档，注意等号后面的空格是比不可少的，参考这里。 配置Nginx作为静态服务器# 假设现在写了一个简单的html文件，如何让nginx代理我的文件而不是默认的Welcome to Nginx！文件呢？下面记录几种方法： 假设HTML文件内容如下（来自Bootstrap） 12345678910111213141516171819202122&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;!-- Required meta tags --&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt; &lt;!-- Bootstrap CSS --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css&quot; integrity=&quot;sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk&quot; crossorigin=&quot;anonymous&quot;&gt; &lt;title&gt;Hello, world!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;!-- Optional JavaScript --&gt; &lt;!-- jQuery first, then Popper.js, then Bootstrap JS --&gt; &lt;script src=&quot;https://code.jquery.com/jquery-3.5.1.slim.min.js&quot; integrity=&quot;sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js&quot; integrity=&quot;sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js&quot; integrity=&quot;sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 保存到如下路径：[C:\\Users\\awesome\\Documents\\Projects\\www\\index.html](file:///C:/Users/awesome/Documents/Projects/www/index.html)，双击html文件，可以正常打开（使用file协议）。在Nginx安装目录附近找一下，可以找到Nginx的HTML文件的[默认位置](file:///C:/Users/awesome/scoop/persist/nginx/html)，把里面的html文件替换即可。 这时候打开localhost出现的就是新创建的HTML文件了。 如果不想更改文件夹位置，可以选择更改Nginx的配置，在[conf文件夹](file:///C:/Users/awesome/scoop/apps/nginx/current/conf)下有一个文件名为nginx.conf的文件。内容大致如下： 12345678910http { ... server { ... location / { root html; index index.html index.htm; } }} 其中root指定的就是网站根目录对应的路径。root指令文档。其他配置可以参考Configuring NGINX and NGINX Plus as a Web Server。 注意：Windows下路径中的\\需要转义。我这里改成： 1234567891011http { ... server { ... location / { #root html; root C:\\\\Users\\\\awesome\\\\Documents\\\\Projects\\\\www; index index.html index.htm; } }} 为了验证改动生效了，我把标题改成了Hello, new world!。重新启动nginx服务（可以先停止、再启动），打开localhost即可查看效果。 如果想再添加一个服务器，可以参考：Setting Up Virtual Servers。 实际上，重新加载配置是不需要重新启动Nginx服务的，可以使用nginx -s reload 来重新加载配置文件。（如果用服务方式启动，不要使用这种方式） 注意：start nginx和net start nginx两种启动方式不要混用，否则会启动多个nginx实例，造成冲突。 PHP下载安装运行# PHP即“超文本预处理器”，是一种通用开源脚本语言。PHP是在服务器端执行的脚本语言，与C语言类似，是常用的网站编程语言。PHP独特的语法混合了C、Java、Perl以及 PHP 自创的语法。利于学习，使用广泛，主要适用于Web开发领域。 打开PHP的下载页面，一般可以选择Non Thread Safe（nts）版本。解压安装好后，在[安装目录下](file:///C:/Users/awesome/scoop/apps/php/current)以管理员权限打开命令提示符，输入命令运行服务： 1C:\\Users\\awesome\\scoop\\apps\\php\\current&gt;php-cgi.exe -b localhost:9000 运行之后同样没有信息显示，按Ctrl+C可以退出。 Nginx配合PHP# 为了验证php服务运行正常，配置一下Nginx，使得它能解析php文件。同样打开nginx.conf，找到下面这段配置： 1234567#location ~ \\.php$ {# root html;# fastcgi_pass 127.0.0.1:9000;# fastcgi_index index.php;# fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name;# include fastcgi_params;#} 改为： 1234567location ~ \\.php$ { root C:\\\\Users\\\\awesome\\\\Documents\\\\Projects\\\\www; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params;} 大概解释一下原理吧。location指令用来定位，~表示后面的字符串是一个正则表达式，\\.php$匹配所有以.php结尾的字符串，因此当网址以.php结尾时，就会启用下面的配置。前面提到nginx是一个代理服务器，因此它还可以把请求转发到别的服务上，参考Passing a Request to a Proxied Server。这里的fastcgi_pass就是其中一种。通常这些服务还需要读取一些其他信息如HTTP请求头、HTTP参数等，这些信息通过参数传递，定义在fastcgi_params文件中，感兴趣可以查看一下Nginx传递了哪些参数。参考这里。$document_root等变量是Nginx内置的变量，指向root的地址，其他变量参考这里。 为了方便测试，在首页添加一个链接到info.php。 index.html更改内容： 1234&lt;h1&gt;Hello, new world!&lt;/h1&gt;&lt;ul&gt; &lt;li&gt;&lt;a href=&quot;info.php&quot;&gt;PHP Info&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 同目录下新建info.php，内容： 1&lt;?php phpinfo(); ?&gt; 显示效果： 说明PHP运行成功。 将PHP配置成系统服务# 把PHP配置成系统服务可以参考这里。同样简单记录一下我的配置方法。先下载winsw和xxfpm （winsw记得同时下载配置文件，xxfpm下载源代码即可） 将下载的xxfpm.exe 和 pthreadGC2.dll 扔进php-cgi.exe所在的目录，同样添加winsw的程序（php-server.exe）和配置文件（php-server.xml）： 123456789101112131415161718192021&lt;configuration&gt; &lt;id&gt;php&lt;/id&gt; &lt;name&gt;PHP&lt;/name&gt; &lt;description&gt;PHP is a popular general-purpose scripting language that is especially suited to web development.Fast, flexible and pragmatic, PHP powers everything from your blog to the most popular websites in the world.&lt;/description&gt; &lt;executable&gt;C:\\Users\\awesome\\scoop\\apps\\php\\current\\xxfpm.exe&lt;/executable&gt; &lt;startargument&gt;&quot;C:\\Users\\awesome\\scoop\\apps\\php\\current\\php-cgi.exe&quot;&lt;/startargument&gt; &lt;startargument&gt;-n&lt;/startargument&gt; &lt;startargument&gt;1&lt;/startargument&gt; &lt;startargument&gt;-i&lt;/startargument&gt; &lt;startargument&gt;127.0.0.1&lt;/startargument&gt; &lt;startargument&gt;-p&lt;/startargument&gt; &lt;startargument&gt;9000&lt;/startargument&gt; &lt;stopexecutable&gt;taskkill&lt;/stopexecutable&gt; &lt;stopargument&gt;/F&lt;/stopargument&gt; &lt;stopargument&gt;/IM&lt;/stopargument&gt; &lt;stopargument&gt;xxfpm.exe&lt;/stopargument&gt;&lt;/configuration&gt; 放置好后大概这个效果： 以管理员权限运行cmd： 12C:\\Users\\awesome\\scoop\\apps\\php\\current&gt;php-server.exe install2020-06-15 08:26:49,876 INFO - Installing the service with id 'php' 用PowerShell查询服务# 默认情况下sc命令在PowerShell是不起作用的。 1234PS C:\\Users\\awesome&gt; Get-Alias -name scCommandType Name ----------- ---- Alias sc -&gt; Set-Content 可以看到sc是Set-Content的别名。一种简单的方法是使用sc.exe 1234567PS C:\\Users\\awesome&gt; sc.exe query nginxSERVICE_NAME: nginx TYPE : 10 WIN32_OWN_PROCESSSTATE : 1 STOPPEDWIN32_EXIT_CODE : 0 (0x0)SERVICE_EXIT_CODE : 0 (0x0)CHECKPOINT : 0x0WAIT_HINT : 0x0 可惜的是sc别名是只读的，没法更改。 1234567PS C:\\Users\\awesome&gt; Set-Alias -Name sc -Value sc.exeSet-Alias : 别名不可写入，因为别名 sc 为只读别名或常量，无法写入。所在位置 行:1 字符: 1 + Set-Alias -Name sc -Value sc.exe+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+ CategoryInfo : WriteError: (sc:String) [Set-Alias], SessionStateUnauthorizedAccessException + FullyQualifiedErrorId : AliasNotWritable,Microsoft.PowerShell.Commands.SetAliasCommand 查询PHP服务是否正确安装： 1234567PS C:\\Users\\awesome&gt; sc.exe query phpSERVICE_NAME: php TYPE : 10 WIN32_OWN_PROCESSSTATE : 1 STOPPEDWIN32_EXIT_CODE : 1077 (0x435)SERVICE_EXIT_CODE : 0 (0x0)CHECKPOINT : 0x0WAIT_HINT : 0x0 启动PHP服务，注意之前启动的要先关闭。 123PS C:\\Users\\awesome&gt; sudo net start phpphp 服务正在启动 . php 服务已经启动成功。 我这里使用了scoop提供的sudo命令，它可以暂时提升为管理员权限，如果没有这个命令可以再打开一个管理员权限的窗口。 MySQL安装配置# MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。 可以在下载页面选择合适的版本下载安装，如果只需要命令行界面的话可以下载ZIP包，我同样使用Scoop命令行安装。由于MySQL自带了配置服务，因此安装非常简单，参考以下配置过程： 1234567891011121314151617181920212223242526PS C:\\Users\\awesome&gt; sudo mysqld --install mysql --defaults-file=&quot;C:\\Users\\awesome\\scoop\\apps\\mysql\\current\\my.ini&quot;Service successfully installed.PS C:\\Users\\awesome&gt; sudo net start mysqlmysql 服务正在启动 . mysql 服务已经启动成功。PS C:\\Users\\awesome&gt; mysqlWelcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 8Server version: 8.0.20 MySQL Community Server - GPLCopyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; SHOW DATABASES;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys |+--------------------+4 rows in set (0.01 sec) 如果安装服务失败，可以尝试删除之前的安装文件，如Scoop的persist。 PHP连接MySQL# 首先启用PHP扩展。 打开[PHP安装目录](file:///C:/Users/awesome/scoop/apps/php/current)，首先需要设置一下PHP的配置文件。找到php.ini-development文件，将它复制一份改名为php.ini。更改以下几个地方： 启用扩展目录： 12345; Directory in which the loadable extensions (modules) reside.; http://php.net/extension-dir;extension_dir = &quot;./&quot;; On windows:extension_dir = &quot;ext&quot; 设置时区： 1234[Date]; Defines the default timezone used by the date functions; http://php.net/date.timezonedate.timezone = Asia/Shanghai 之后需要启用扩展可以在对应的模块取消注释或添加即可。 123456789101112;;;;;;;;;;;;;;;;;;;;;;; Dynamic Extensions ;;;;;;;;;;;;;;;;;;;;;;;; If you wish to have an extension loaded automatically, use the following; syntax:;; extension=modulename;; For example:;; extension=mysqli 安装使用phpMyAdmin# 为了验证PHP与MySQL的正确安装配合，安装phpMyAdmin进行测试。同时方便对数据库进行管理。phpMyAdmin是一个非常受欢迎的基于web的MySQL数据库管理工具。它能够创建和删除数据库，创建/删除/修改表格，删除/编辑/新增字段，执行SQL脚本等。在官网下载即可。下载完成后解压，文件夹放到Nginx代理目录下。在index.html中添加一个入口： 1234&lt;ul&gt; &lt;li&gt;&lt;a href=&quot;info.php&quot;&gt;PHP Info&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;phpMyAdmin-5.0.2-all-languages/&quot;&gt;phpMyAdmin&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 这时候如果直接访问可能会出现403 Forbidden错误，这是因为默认的首页文件是index.html或index.htm，而phpMyAdmin提供的首页文件是index.php。我们可以改一下nginx的配置。 12345location / { #root html; root C:\\\\Users\\\\awesome\\\\Documents\\\\Projects\\\\www; index index.html index.htm index.php;} 重启一下Nginx，就可以访问了。 根据提示，在php.ini配置文件中启用mysqli扩展。 12345;extension=mbstring;extension=exif ; Must be after mbstring as it depends on itextension=mysqli;extension=oci8_12c ; Use with Oracle Database 12c Instant Client;extension=odbc 重新启动php服务： 1234567PS C:\\Users\\awesome&gt; sudo net stop phpphp 服务正在停止.php 服务已成功停止。PS C:\\Users\\awesome&gt; sudo net start phpphp 服务正在启动 .php 服务已经启动成功。 此时就能正常启动了。 默认是禁止空密码登录的，也可以启用。在phpMyAdmin根目录下找到config.sample.inc.php，复制为config.inc.php。 1$cfg['Servers'][$i]['AllowNoPassword'] = true; 修改好后就可以直接用root账号登录了，密码不用输入即可。","link":"/posts/webdev-setup/"},{"title":"为什么要写博客？","text":"以下内容摘自[BetterExplained]为什么你应该（从现在开始就）写博客 – 刘未鹏 | Mind Hacks，加入了我自己的一些注解，希望能对你我有所启发。 为什么你应该（从现在开始就）写博客# 用一句话来说就是，写一个博客有很多好处，却没有任何明显的坏处。（阿灵顿的情况属于例外，而非常态，就像不能拿抽烟活到一百岁的英国老太太的个例来反驳抽烟对健康的极大损伤一样） 让我说得更明确一点：用博客的形式来记录下你有价值的思考，会带来很多好处，却没有任何明显的坏处。Note：碎碎念不算思考、心情琐记不算思考、唠唠叨叨也不算思考、没话找话也不算思考，请以此类推。 下面是我个人认为写一个长期的价值博客的最大的几点好处： （1）能够交到很多志同道合的朋友。我自己既写博客，也读别人的博客，在这个时代，对于生活中的绝大多数人来说，拓宽朋友圈子的途径几乎只有一个，通过网络，而如何在网络中寻找到气味相投的朋友，如何判断别人和自己是否有共同语言？显然，通过天天在SNS上碎碎念的那些日记是难以做到的。我佩服的一些朋友几乎全都是长期用博客记录想法的人，因此，和他们即便不打照面，也是心照不宣。即便素未谋面也能坐下来就聊得热火朝天。 为什么博客在结交志同道合的朋友方面的潜力要远胜于原始的交谈方式？很简单，第一，博客无地域限制，整个互联网上从A到B只有一个点击的距离，而传统的建立朋友圈子的方法则受到地域限制。第二，也是更重要的一点，即如果按照以前结交朋友的方式，需要互相聊天，交流观点，然后才逐渐熟悉起来，这需要一个较长的过程，而且更糟糕的是，当你遇到另一个陌生人，又要把整个过程重复一次，表达你已经对老友表达过的那番想法。可博客却做到了“一次表达，无数次阅读”，当我看到一个写了好几年的博客，看完了之后我仿佛和这个人交谈了很久，用程序员们喜欢听的话来说就是，“博客极大地增强了话语的复用性”。 我曾在CSDN上写了近六年的博客，在一年半前建立了一个Google Groups（TopLanguage），由于我的博客的长期阅读者都是互相有共同语言的，因此这个Group一开始就热火朝天，而高质量的技术讨论则进一步吸引了更多的牛人的参与，雪球滚起来之后，就很难停下来了，将近一年半下来，从这个Group的讨论中我获益良多。而对于非程序员朋友，科学松鼠会则是一个很好的例子。 （2）书写是为了更好的思考。我在《书写是为了更好的思考》里面详细总结了书写的好处，这里就不拷贝粘贴了。有些想法如果不写下来，也就忘掉了，有一个广为流传的《数学牛人们的轶事》里面讲了希尔伯特的一个故事：一次在希尔伯特的讨论班上，一个年轻人报告，其中用了一个很漂亮的定理，希尔伯特说“这真是一个妙不可言（wunderbaschon）的定理呀,是谁发现的？”那个年轻人茫然地站了很久，对希尔伯特说：“是你.……”。 （3）“教”是最好的“学”。如果一件事情你不能讲清楚，十有八九你还没有完全理解。绝大多数人应该都知道在程序员行业面试官经常要求你讲解一个东西给他听，他会说他不懂这个东西（他如果真的不懂的话效果其实是最好的），而你的任务则是说到让他理解为止。 为了让一个不明白的人做到明白，你必须要知道从不明白到明白他究竟需要掌握哪些概念，这就迫使我们对我们大脑中整个的知识体系来个寻根究底，把藏在水面之下的那些东西统统挖出来，把大脑中的那些我们知道、但不知道自己知道的潜在概念或假设（assumptions）都挖出来，把它们从内隐记忆拉扯到外显记忆中。因为只有完全知道、并知道自己知道一切来龙去脉的人，才能真正把一件事情讲得通通透透。 但是，你可能会怀疑，那除了能够讲清楚之外，弄清自己到底知道哪些东西还有其他什么好处吗？如果没有其他好处，那我又何必费这个劲呢？我又不当老师。 TopLanguage上的一位朋友sagasw曾经讲了这样一个小故事：据说在某个著名软件公司里，开发组的桌上会放着一只小熊，大家互相问问题之前，先对着小熊把问题说一遍，看能不能把问题描述得清晰，基本上说得比较有条理以后，答案也就随之而来了。当然，你不一定要对小熊说，你可以在大脑中虚构一个听众，一个不懂行的听众，然后你说给他听。这是可行的，我经常在路上用。不过如果你能坐下来，我建议你还是说给实际的听众听——即写下你的思考，因为书写是更好的思考。 我们的绝大多数知识在绝大多数时候都隐藏在潜意识中，其实我们意识的窗口很小，我们的工作记忆只能容纳寥寥数个条目（记得那个“看你能够记住屏幕上同时闪现的多少个数字”的flash小游戏吗？），我们平时所作的推理过程很大部分都是自动的，发生在潜意识中，而我们只能感知到一些中间结论。不信你回忆一下你在和别人讨论问题的时候有多少次觉得“反正就是这样，我感觉得到它是对的，但是你问我，我也说不清到底怎么回事”，对此你不觉得很奇怪吗？如果你都不能从逻辑上支持你的结论，你怎么就能确信它是对的呢？仅仅因为你的直觉强烈地告诉你它是对的？那如果旁边有另一个人，他和你持相反的观念，而他的直觉也强烈地告诉他他是对的。这时候你又怎么想？“他的直觉错了，我的直觉是对的”？难道你这么自信你的直觉是世界上最可靠的？ 我自己则是非常珍惜类似这样的机会，即当“我强烈地觉得它是对的，但我却说不出所以然来”，这时候往往是到大脑中翻箱倒柜的时候，弄清来龙去脉的时候，深入反思的时候，纠正一直以来错误的潜在前提假设的时候。另一方面，“我强烈地觉得这个说法有问题，但我却说不清它为什么有问题，到底哪有问题”，这也是一个极有意义的瞬间，它几乎总是意味着你对一个问题的认识有潜在的偏差，肯定是在你自己都没有觉知到的地方引入了一个潜在的假设、偷换了一个重要的概念，等等。而这种时候就是深入反思的时候，当你终于潜到问题的底层，触摸到问题的实质，把水面之下的冰山整体看清了的时候你会有一种通体舒泰的感觉。 为什么说以上这些？因为刚才说的是你必须等待这样的反思机会，但如果你选择经常总结自己的知识体系，并说出来给你的读者听，你就会发现你自己创造了这样的机会。如果我们平时不反思，我们觉得很多事情都是当然的，但结果如果要你一开口说给别人听，常常会发现事情就开始变得不那么明显了，你说着说着，就开始莫名其妙地发现自己需要用到“反正”这个词了。 于是，反思的机会就来了。 一旦你把自己潜意识里面的东西从幕后拉出来，你就有了面对并反思它们的可能，而不是任它们在幕后阴险地左右你的思维。很多时候我们的思路出了问题并不是我们不会反思，而是不知道自己的思维中有哪些隐含的假设（assumptions），如果你只感觉到答案，却不知道你大脑得到这个答案之前做了哪些推理，你又怎么知道哪一环可能出了问题呢？另一方面，一旦你弄清了自己到底是怎么想的，离意识到问题就不远了，很简单的道理——如果别人和你争辩的时候总是只摆立场，你就很难和他辩，但如果他把自己的推理过程原原本本暴露给你，批判起来总是容易得多的。（也正因为这个原因有很多人总是把逻辑藏在背后，不敢暴露出来） 绝大多数时候其实我们都会不假思索地得出一些结论，就像上了发条的自动机，但其实我们并不知道这些结论到底怎么来的，在思维的背后到底发生了哪些事情，故而当我们发现我们的结论错了的时候，一头雾水，没法着手寻找到底在哪错了。如果你注意一下很多人的发言（论坛、博客等等），如果你把他们的发言分为“前提”、“假设”、“逻辑”、“结论”这四个部分，你会发现一大堆人只会不停地下结论，摆立场，却见不到这些结论或立场的前提、假设和各种逻辑，倒也不是他们不愿意写出逻辑，而是因为反思自己的思维过程实在是一件困难非常的事情，我们的推理过程很大一部分发生在意识的水面之下，只有当有了重要结论的时候这条逻辑链才会浮出来冒一个泡，让我们的意识捕捉到。更何况绝大多数时候我们用的其实并不是完整严密的逻辑思维，而是思维捷径。 去教一个完全不懂的人，则是一种最最强大和彻底的反思途径——因为他没有任何预备的知识，所以要让他弄懂你所知道的，你就必须彻底反思你的知识体系，弄清这座大厦的根基在什么地方，弄清它的骨架在什么地方，一砖一瓦到底是怎么垒起来的，你不能自己站在11层上，然后假设你的读者站在第10层，指望着只要告诉他第11层有那些内容就让他明白。你的读者站在第一层，你必须知道你脚下踩着的另外10层到底是怎么构造的。这就迫使你对你所掌握的、或之前认为正确的那些东西作彻彻底底地、深刻地反思，你的受众越是不懂，你需要反思得就越深刻。 （4）讨论是绝佳的反思。另一方面，很多时候我们并不是有机会说给完全不懂的人听，更大的可能性是说给同领域有一定基础的人听，这个时候并不代表就不能促使反思了，实际上，你会发现，如果你公开你的想法，几乎总能看到与你持不同意见的人，然后你通过比较你和他的观念之间的差别，会发现你们在一开始的思路上就存在差异，差异从哪里来的？在进一步讨论中你们就会不断地迫使对方拿出更深层次的理由，这同样也是一种非常有效地促使自己反思的方法，在讨论的过程中双方的理由自然会变得越来越深入，越来越接近问题的本质，一些平时难以注意到的深层面的差异性就会逐渐浮现出来，你也就多了一次难得的机会去审视自己的思维中到底存放了哪些错误的信息。 （5）激励你去持续学习和思考。如果你没有持续学习和思考的习惯，你的博客很快就会没有内容可写，就只能整点碎碎念或者转载，然后你就会失去读者，然后你就会关掉博客，然后一旦关掉博客之后你也就死了写博客的心，然后就少了一条激励你去思考和总结的途径，然后你变得更不高兴总结和思考，然后… 为了打破这个死循环，不要永久停止更新你的博客，就算你两个月，三个月都不写，只要你每篇都是写自己思考的产物，写有价值的东西，在互联网上，金子的确总是会发光的，因为有无数的信息聚合平台在期待这些有价值的内容，有搜索引擎为你的内容提供海量的潜在读者，有海量的人肉在手动挖掘和转载那些有价值的东西。我们所能做的最差的一个决策莫过于停止做一件没有任何坏处，却有一大堆好处的事情。 为了让你的博客有价值，你必须不断总结自己学习的结果，你必须不断思考，给出比别人深刻、独到的见解。这看起来有点本末倒置，但很快本和末就会正过来。 （6）学会持之以恒地做一件事情。很多人在生活中容易觉得迷失，不知道想要做什么，是因为没有一件能够持续地做的事情，用俗话来说就是没有主心骨。用积极心理学的话来说就是没有一件能够创造流体验的事情，而书写自己的思想则是一件容易产生流体验的事情，在书写的时候，特别是理性地书写的时候，大脑逐渐进入推理分析模块，一切不愉快的情绪，烦躁感都会逐渐消隐下去。不过前提是你得开始，并且坚持过一开始的困难期，以后的一切便成了习惯成自然。 （7）一个长期的价值博客是一份很好的简历。这里的“简历”并非是狭义上的求职简历，毕竟现在还没有到价值博客的时代，很多人写博客都是到处转载或者干脆碎碎念，正因此面试官未必拿个人博客当成了解一个人的更可靠窗口。这里的“简历”是指一个让别人了解自己的窗口，虽然我们未必做得到像罗永浩、Keso这样的博客，个人的影响力已经足以支撑出一份事业（牛博和5gme），但至少你会因此而结识更多的人，你的博客价值越高，你结识的人就越牛，跟牛人交流又会让你的眼界得到极大的开阔，打开一扇又一扇你原本不知道的门，于是你就变得更牛… 这是一个良性循环。 怎么做到长期写一个价值博客# 注意到我并没有说“怎么做到长期坚持写一个价值博客”，因为当思考和总结成为习惯之后，诉诸文字以及借助书写来进一步思考就变成了一件自然而然的事情，就变成了一件“因为你在思考和总结从而必须书写下来”的事情，博客就变成了副产品。 一开始的时候你是因为要写博客而去使劲地思考和总结，指望给出令人眼睛一亮的东西，到了后来，就变成了因为你习惯了思考和总结，因为你意识到书写是更好的思考，你就必须使你的想法成为文字。至此本和末就会各归原位，不再颠倒。 怎样做到长期写一个价值博客？也许有人会给出很多有趣有用的小技巧来提供动机和激励，譬如如何做SEO，如何鼓励读者留言等等，但是这些我都不想说，我只想说最最重要的，那就是： 让你自己成为一个持续学习和思考的人，并只写你真正思考和总结之后的产物，其他一切就会随之而来。 就像那句经常被人传阅的话：只做你最感兴趣的事情，钱会随之而来。 这方面的具体例子大家可以留意一下，随处可见，就不一一列举了。我想再重复一下的是，千万不要碎碎念，我能理解每个人都想偶尔发发牢骚的冲动，但是现在已经有了一个很好的窗口：twitter，所以立即停止在你的博客上碎碎念，阅读博客的人希望得到信息而非噪音。如果实在忍不住想碎碎念的话不妨换一下位置，这么来告诉自己：如果你看到别人博客来上这么一段，你会有兴趣看吗？ 可能出现的问题以及怎样应付# 即便上文给出了N条写博客的理由，但有时候只要一条不写的理由就会让人停止做一件事情。所以我特别加上一节“可能出现的问题以及怎样应付”，《影响力2》第五章雄辩地证明，“Much of Will is Skill”，意志力很大程度上来源于有正确的方法，而非天生。 （1）担心别人认为没有价值。事实是，你面临过的问题总会有人面临过，你独立思考了，别人没有，你的文章对他们就会有价值。当然，肯定会对某些人没有价值，他们早就知道了，但就算你再厉害，也总是有人比你厉害的，不能说因为这些原因就不记录你自己的想法了，你自己思考了之后理解得最深刻，就算有别人想过了，总有人没有想到的。况且，思考成了习惯，你的思考能力也会越来越强，你的文章也会越来越有价值。重复，无论你面临什么困惑，总会有很多人同样面临过，于是你苦苦思索之后的结果，肯定会对很多人有意义。 或者，你想通了之后觉得其实也很简单于是不愿意或者不好意思写了，但要知道，问题在想通了之后总是简单的，问题的困难程度不在于想通了之后还觉得有多难，而在于从你觉得它难到你觉得它简单需要耗费多少思维体力，你耗费的时间越长，说明有越多的人最终还是没有想明白（路越长走到底的人越少）。 最后，虽然我现在看一年前的文章觉得挺不成熟，但是如果没有那些不成熟的思考，也不会有现在更成熟的思考，我几年后来看现在写的东西，还是会觉得不成熟。 （2）担心想法太幼稚或有漏洞等等被别人笑话。人非圣贤。正是因为单个人的想法总是有漏洞，才值得拿出来交流（《书写是更好的思考》，讨论是绝佳的反思），被别人指出问题正是改进的空间，藏着掖着的想法永远不可能变得更成熟。 Much of intelligence is knowledge，有这么一个非常发人深省的经典心理学实验： 将孩子们分成两组，通过给他们不同的阅读材料让一组相信智力是天生的，不可在后天改变的，另一组则让他们相信智力其实只是知识和技能的代名词，完全是后天习得的。接下来让他们做一组任务，那些相信智力天生说的孩子，倾向于回避困难的任务，选择较容易的任务，这里的逻辑想必是这样的：如果做困难的任务，就增大了失败的几率，就降低了自己在别人和自己心目中的智力的值。为了保护这个智力的值不被降低，应该避免那些有失败风险的项目。而另一组孩子则对于有挑战性的事情跃跃欲试，并且在失败的时候明显没有前者沮丧，因为失败也是学得新的东西，不管怎样都是“智力”的提高。 况且，只会批判乃至嘲笑别人的人是最不知道怎么建设的人，忽略他们。 （3）得不到激励。这其实是个最无聊的问题了，只有写碎碎念的博客才会面对“激励”的问题。如果写自己的总结，写自己独立的思考，那么书写下来、理解通透，本身就是一个极大的激励。就算放在自己的私密笔记本里面也一样有成就感。况且，如果你真做到了书写价值博客，那么绝对不用担心你的观点得不到传播，也许一开始会耗时长一点，但是这在任何事情上都是必要的初始阶段，Gmail小组的核心人物、FriendFeed创始人Paul Buchheit，和编程界名博Coding Horror的博主Jeff Atwood都曾经感叹过：Overnight success takes a long time （(1)，(2)），不过对于价值博客来说，现在网络上的聚合类服务这么多，机器的、人肉的、半人肉的都有，情况又要好得多了，而且我相信情况还会越来越好。 （4）写不出来。这个问题也比较无聊，思考本不是一件急于求成的事情。长期订阅我的博客的朋友知道我一般发文频率在一个月三五篇，实际上有不少次我个把月也不发布文章，原因很简单，要么是有手头的事情要处理，思考的时间被压缩了，要么是遇到比较大或者比较困难的问题需要长时间的思考和积淀，没有关系，如果没有想清楚就再想想，爱思考的人和不爱思考的人有一个本质的区别，前者在生活中总是挂着几个问题在大脑中，它们时常都会冒出来骚扰你一下，让你琢磨琢磨，不爱思考的则是没事不主动想问题，遇到问题还要先想想是否能找捷径（找人帮忙）解决。 无论如何，不用急于求成，在一个主题上深入下去思考，总能挖到别人挖不到的角落。你能让一个问题在大脑中停留的时间越长，就越是能够发现新的东西，一般来说，我认为有价值的问题我会让他在意识或潜意识中待短则一个星期，长则一个月（视问题大小而定），利用走路吃饭的时间琢磨（我发现很多我佩服的人也都有这个习惯），有时即便已经想通了写下来了发出去了，大脑仍然还是会在回味问题，还没有把它撤出潜意识，然后看到某篇文章或某本书的时候忽然又有所新的感悟。 能够把问题长时间停靠在潜意识中是一种技能，能够带来很大的好处，停留得越长你越琢磨得透彻，比别人看到的就越多。我们必须要带着问题的眼镜看待事物才能发现新的视角，否则就会出现视而不见效应，别的不说，广为人知的例子是阿基米德的“尤里卡！”，如果不是长时间琢磨着一个问题，一直把它放在思维中，是不会从洗澡领悟到“排水测体积”的，否则他洗了那么多年澡怎么不早发现呢？ 所以，如果你习惯了思考问题，就总会有东西写，先有思考，然后有总结，然后在总结中进一步思考。 当然你也可以试试把不成熟的想法写下来，试图整理成条理清晰的文字，然后看看能否在整理的过程中走得更远。这往往是可行的。比如这篇文章在我的简记里面原本其实只有三行字（包含大约十来个备忘关键词），而最初在我的大脑里面其实只有一个走路时冒出来的问题——为什么要写博客？","link":"/posts/why-blog/"},{"title":"数据库实验总结","text":"最近由于数据库课程的需要，做了一些数据库相关的实验，在此做一些总结与记录。 版本选择与环境安装# 之前用数据库都是选择开源的MySQL或是轻便的SQLite，这次想尝试一下更强大的数据库产品。课程推荐使用的是Oracle Database或者SQL Server，目前市场上主流也是这两个数据库产品。其中占比更多的是Oracle的产品，但是简单对比了一下我还是选择了SQL Server，主要原因就是SQL Server提供中文的文档，对新手也比较友好。想详细了解一下可以参考：Oracle的文档和Microsoft的文档。 接下来就是确定安装的数据库版本了，针对学习用途，SQL Server提供了两种版本： SQL Server 2019 Developer 是一个全功能免费版本，许可在非生产环境下用作开发和测试数据库。下载链接 SQL Server 2019 Express 是 SQL Server 的一个免费版本，非常适合用于桌面、Web 和小型服务器应用程序的开发和生产。下载链接 上面列出了版本的介绍和安装需要占用的空间以及下载的大小，可以根据自己的需要选择，我选择了Developer版本，下载好后直接双击开始安装。 等待一段时间后就安装好了： 注意这里安装的是一个服务，它并不带有常见软件的界面，是悄悄运行在后台的。如果需要一个界面可以选择安装SSMS。（大小约550M）点击下面的按钮即可跳转到下载页面，下载链接，初学者还是比较推荐安装的，当然也可以选择使用命令行操作。后面的操作虽然在SSMS中进行，但主要还是通过SQL语句操作的。 安装好后即可开始使用。 服务器名称一般是计算机名称，可以在计算机–属性中查看。 连接成功！至此SQL Server环境已经安装好了。 数据库基本操作# 点击新建查询，即可创建一个SQL文件，在此文件里即可输入SQL语句。 执行SQL# 下面介绍一些执行语句的操作。 点击执行按钮即可执行整个SQL文件，也可用F5快捷键。 有时候只想执行一部分的SQL语句。这时可以选中这部分的语句，再点击执行按钮，即可只执行这部分的语句。 接下来涉及比较多的SQL语句，为了统一格式，SQL关键词采用大写模式、数据库名/表名采用小写字母加数字加下划线命名、数据类型使用小写字母。SQL语句尽量简洁，不使用过多的T-SQL特性。SQL语句末尾不使用分号。 数据库# 创建students数据库 CREATE DATABASE students 删除students数据库 DROP DATABASE students 使用students数据库（默认是在master数据库） USE students 创建表# 创建student表（学生表） 123456789CREATE TABLE student( sno varchar(50) PRIMARY KEY,-- 学号 sname varchar(50) NOT NULL,-- 姓名 sex varchar(50) NOT NULL,-- 性别 bdate date NOT NULL,-- 出生日期 height float NOT NULL,-- 身高/米 dept varchar(50)--所在系) 其中--后面的文字是注释。参考：数据类型、CREATE TABLE 创建course表（课程表） 12345678CREATE TABLE course( cno varchar(50) PRIMARY KEY,--课程号 cname varchar(50) NOT NULL,--课程名 lhour varchar(50) NOT NULL,--课时 credit int NOT NULL,--学分 semester varchar(50) NOT NULL--学期) 创建sc表（选课表） 123456789CREATE TABLE sc( sno varchar(50),--学号 cno varchar(50),--课程号 grade int,--成绩 PRIMARY KEY(sno, cno), FOREIGN KEY(sno) REFERENCES student(sno), FOREIGN KEY(cno) REFERENCES course(cno)) 注意此处主码与外码约束的写法。 查询数据# SQL语句中最重要的就是查询语句了，为了方便查询，先插入一些数据，这里使用数据库课程提供的测试数据，仅供测试使用。 查询所有课程名称 SELECT cname FROM course 结果显示非常直观，后面的结果采用文本的方式展现。 查询秋季开设的课程名 1SELECT cname FROM course WHERE semester = '秋' 1234567cname--------------------------------------------------数据结构编译原理体系结构数字电路控制电机 查询身高大于1.84m的男生的学号和姓名 12SELECT sno, sname FROM studentWHERE height &gt; 1.84 AND sex = '男' 123456sno sname-------------------------------------------------- --------------------------------------------------201530371763 郑佳炜201530541340 何浩宁201536061248 柯皓文 查询选修计算机系秋季所开课程的杨姓男生的姓名、课程号（计算机系课程的课程号以CS开头） 1234SELECT sname, sc.cno FROM student, course, scWHERE sc.sno = student.sno AND sc.cno = course.cno AND sc.cno LIKE 'CS%' AND semester = '秋' AND sex = '男' AND sname LIKE '杨%' 1234567sname cno-------------------------------------------------- --------------------------------------------------杨晓虹 CS4杨晓虹 CS5杨心语 CS1杨心语 CS5 查询至少选修一门电机系课程的女生的姓名（电机系课程的课程号以EE开头） 12345SELECT sname FROM student, sc WHERE student.sno = sc.sno AND student.sex = '女' AND cno LIKE 'EE%'GROUP BY sname 1234567891011121314151617181920sname--------------------------------------------------陈庄智范港平冯嘉昌古超文何伟健何盈盈李研梁浩赞刘亚威孙越唐仁杰王锦杰吴松树许哲杨奕彬游德鸿赵飞扬 查询总平均成绩 1SELECT AVG(grade) FROM sc 173 查询每门课程的平均成绩 1234SELECT course.cno, AVG(grade) AS 平均成绩FROM course LEFT JOIN sc ON course.cno = sc.cno GROUP BY course.cno 注意这里不能从sc表中直接统计，要考虑所有课程（可能有没人选的课），可以把course表和sc表左连接。 123456789101112cno 平均成绩-------------------------------------------------- -----------CS1 77CS2 73CS3 75CS4 76CS5 71EE1 73EE2 72EE3 73EE4 71 查询所有课程的成绩都在80分以上的学生的姓名、学号、且按学号升序排列 12345SELECT sname, sc.sno FROM student, sc WHERE student.sno = sc.sno GROUP BY sc.sno, sname HAVING MIN(grade) &gt; 80ORDER BY sc.sno 123456789sname sno-------------------------------------------------- --------------------------------------------------徐映雪 201530381885胡景铨 201530541418刘俊彦 201530541807沈强 201530541937杨晓虹 201530542262刘亚威 201592450587 查询有一门以上(含一门)三个学分以上课程的成绩低于51分的学生的姓名 1234SELECT sname FROM student, sc, course WHERE student.sno = sc.sno AND course.cno = sc.cno AND credit &gt; 3 AND grade &lt; 51GROUP BY sname 123456sname--------------------------------------------------何亿孙越许树雄 查询1984年2月到3月出生的学生的姓名,总平均成绩及已修学分数 12345SELECT sname, AVG(grade) AS 总平均成绩, SUM(credit) AS 已修学分数FROM student, sc, courseWHERE student.sno = sc.sno AND course.cno = sc.cno AND bdate &gt;= '1984-02-01' AND bdate &lt;= '1984-3-31'GROUP BY sname 123456sname 总平均成绩 已修学分数-------------------------------------------------- ----------- -----------李研 74 8吴伟斌 69 9张朝晖 74 9 插入数据# 其实从测试数据里面就可以看到插入数据的格式，下面列出课程数据参考： 123456789INSERT INTO course VALUES('CS1', '数据结构', '64', 3.0, '秋');INSERT INTO course VALUES('CS2', '数据库', '64', 4.0, '春');INSERT INTO course VALUES('CS3', '人工智能', '48', 2.0, '春');INSERT INTO course VALUES('CS4', '编译原理', '64', 4.0, '秋');INSERT INTO course VALUES('CS5', '体系结构', '48', 3.0, '秋');INSERT INTO course VALUES('EE1', '数字电路', '64', 2.0, '秋');INSERT INTO course VALUES('EE2', '电子技术', '64', 4.0, '春');INSERT INTO course VALUES('EE3', '控制电机', '64', 4.0, '秋');INSERT INTO course VALUES('EE4', '数字逻辑', '32', 2.0, '春'); 修改数据# 为了不影响测试数据的稳定，添加一个临时的数据。 1INSERT INTO course VALUES('EE5', '电工实习', '48', 1.0, '春'); 将学分修改为2 123UPDATE courseSET credit = 2WHERE cno = 'EE5' 查询： 1SELECT cno, credit FROM course WHERE cno = 'EE5' 1234cno credit-------------------------------------------------- -----------EE5 2 删除数据# 删除之前插入的临时数据： 12DELETE FROM courseWHERE cno = 'EE5' 进阶查询# 统计各系的男生和女生的人数 12345SELECT dept, COUNT(CASE WHEN sex='男' THEN 1 ELSE NULL END) AS '男生数', COUNT(CASE WHEN sex='女' THEN 1 ELSE NULL END) AS '女生数'FROM studentGROUP BY dept 1234dept 男生数 女生数-------------------------------------------------- ----------- -----------电机系 23 17计算机系 25 10 列出学习过‘编译原理’，‘数据库’或‘体系结构’课程，且这些课程的成绩之一在90分以上的学生的名字。 1234567SELECT sname FROM studentWHERE sno IN (SELECT sc.sno FROM sc, course WHERE sc.cno = course.cno AND sc.grade &gt; 90 AND (cname = '编译原理' OR cname = '数据库' OR cname = '体系结构')) 12345678910sname--------------------------------------------------黄喜全李心妍林世畅刘俊彦杨晓虹杨心语郑晓燕黄琳 列出未选修‘电子技术’课程，但选修了‘数字电路’或‘数字逻辑’课程的学生数。 12345678SELECT COUNT(*) FROM studentWHERE (sno NOT IN (SELECT sc.sno FROM sc, course WHERE sc.cno = course.cno AND course.cname = '电子技术')) AND (sno IN (SELECT sc.sno FROM sc, course WHERE sc.cno = course.cno AND (course.cname = '数字电路' OR course.cname = '数字逻辑'))) 113 列出平均成绩最高的学生名字和成绩。（不得使用TOP或LIMIT关键字） 123456789SELECT sname, avg_grade FROM ( SELECT sno, AVG(grade) AS avg_grade, RANK() OVER (ORDER BY AVG(grade) DESC) AS rk FROM sc GROUP BY sno) ranked_sc, studentWHERE ranked_sc.rk = 1 AND ranked_sc.sno = student.sno 注意这种方式可以查出并列最高的情况。 参考RANK 1234sname avg_grade-------------------------------------------------- -----------徐映雪 95 结构化查询# 参考如下例题： 对每门课增加“先修课程”的属性，用来表示某一门课程的先修课程，每门课程应可记录多于一门的先修课程。列出有资格选修数据库课程的所有学生。(该学生已经选修过数据库课程的所有先修课，并达到合格成绩。) 创建先修课程记录表 12345678CREATE TABLE precourse( cno VARCHAR(50),--课程号 pre_cno VARCHAR(50),--先修课程号 PRIMARY KEY(cno, pre_cno), FOREIGN KEY(cno) REFERENCES course(cno), FOREIGN KEY(pre_cno) REFERENCES course(cno)) 插入测试数据 1234567INSERT INTO precourse(cno, pre_cno)VALUES('CS2', 'CS5'),('CS2', 'CS4'),('CS4', 'CS1') 先修关系如下： 数据库–体系结构 |–编译原理–数据结构 创建临时表 12345IF EXISTS ( SELECT name FROM sysobjects WHERE name = 'tmp_pre')DROP TABLE tmp_pre 将数据库课程号插入临时表 12SELECT cno INTO tmp_preFROM course WHERE cname = '数据库' 找出数据库课程所有的先修课、间接先修课…… 1234567WHILE (@@ROWCOUNT &gt; 0)BEGIN INSERT tmp_pre(cno) SELECT pre_cno FROM precourse WHERE (cno IN (SELECT cno FROM tmp_pre)) AND (pre_cno NOT IN (SELECT cno FROM tmp_pre))END 参考：@@ROWCOUNT 过程类似于BFS。 从中删除数据库本身课程号（从实际情况出发，有资格选数据库的应该是还没选这门课的人） 12DELETE FROM tmp_preWHERE cno=(SELECT cno FROM course WHERE cname = '数据库') 找出选修了所有先修课的人 1234SELECT sno FROM scWHERE cno IN (SELECT cno FROM tmp_pre)GROUP BY snoHAVING COUNT(*) = (SELECT COUNT(*) FROM tmp_pre) 结果如下 12345sno--------------------------------------------------201530471586201530541128201530541210 删除临时表 1DROP TABLE tmp_pre 数据库进阶操作# 视图# 创建视图student_grade(sname,cname,grade)，表示学生选修课程及成绩的详细信息。 可以发现之前查询学生的姓名及成绩需要把三个表连接起来，比较麻烦，利用视图可以解决这个问题。 123CREATE VIEW student_grade(sname, cname, grade) ASSELECT sname, cname, grade FROM student, sc, course WHERE sc.cno = course.cno AND sc.sno = student.sno 利用视图查询一下：查询所有陈姓同学选了数据库课程的成绩。 12SELECT sname, grade FROM student_gradeWHERE sname LIKE '陈%' AND cname = '数据库' 12345678sname grade-------------------------------------------------- -----------陈浩鑫 79陈海康 60陈嘉健 82陈润森 51陈钊浩 80 可以看到，利用视图查询非常简洁直观。 触发器# 新增表credit_stat(sno, sum_credit, no_pass)，表示每个学生已通过选修课程的合计学分数，以及不及格的课程数。 1234567CREATE TABLE credit_stat( sno VARCHAR(50) PRIMARY KEY,--学号 sum_credit INT NOT NULL,--已通过课程合计学分数 no_pass INT NOT NULL,--不及格的课程数 FOREIGN KEY(sno) REFERENCES student(sno)) 插入已有的数据： 123456INSERT INTO credit_statSELECT sno, SUM(credit), COUNT(CASE WHEN grade&lt;60 THEN 1 ELSE NULL END)FROM sc, course WHERE sc.cno = course.cno GROUP BY sno 利用触发器，在sc表中插入数据时自动更新credit_stat 1234567891011121314151617CREATE TRIGGER update_creditON sc AFTER INSERT ASBEGIN IF (SELECT grade FROM inserted) &gt;= 60 BEGIN UPDATE credit_stat SET sum_credit = sum_credit + (SELECT credit FROM course, inserted WHERE course.cno = inserted.cno) WHERE sno = (SELECT sno FROM inserted) END ELSE BEGIN UPDATE credit_stat SET no_pass = no_pass + 1 WHERE sno = (SELECT sno FROM inserted) ENDEND 参考inserted和deleted、CREATE TRIGGER 查看原始数据 1SELECT * FROM credit_stat WHERE sno = '201592450588' 1234sno sum_credit no_pass-------------------------------------------------- ----------- -----------201592450588 8 0 更新sc表，查看数据 12INSERT INTO sc VALUES('201592450588', 'EE3', 59) 1234sno sum_credit no_pass-------------------------------------------------- ----------- -----------201592450588 8 1 可以发现credit_stat表被触发器自动更新了。 约束# 实际上，创建表时指定的主码、外码就是一种约束。这里演示一下怎么删除约束。 查询sc表上的所有约束 12SELECT constraint_name FROM information_schema.key_column_usageWHERE TABLE_NAME = 'sc' 1234567constraint_name---------------------------------------------------FK__sc__cno__29572725FK__sc__sno__286302ECPK__sc__905C05333DE99711PK__sc__905C05333DE99711 当然利用SP_HELP命令也可以。 参考：SP_HELP、系统信息架构视图、KEY_COLUMN_USAGE 删除约束 12ALTER TABLE scDROP CONSTRAINT FK__sc__cno__29572725 过程# 有时候有一些重复的操作可以抽象出来，创建一个过程。例如下面这个过程可以输出问候语句。 123456CREATE PROC welcome @name varchar(50)ASBEGIN PRINT 'hello ' + @nameEND 执行 1EXEC welcome tootal 就会输出： 1hello tootal 参考：CREATE PROCEDURE 用户# 用户权限控制是保证数据库安全的一个重要措施。在SQL Server里，登录名和用户名是分开来的，需要分别创建。 例：创建一个学生用户，可以查询所有的课程信息，可以根据学号和课程号来查询成绩。但不允许修改任何数据。 创建登录名和用户 12345CREATE LOGIN student_userWITH PASSWORD = '123456',DEFAULT_DATABASE = students,CHECK_POLICY = OFF CREATE USER student_user FOR LOGIN student_user 参考：CREATE LOGIN 接下来配置一下SQL Server，允许使用用户名登录。 在对象资源管理器上右键点击已连接的实例，选择属性。 在安全性板块中切换到“SQL Server和Windows身份验证模式”，确定后会弹出提示：“直到重新启动 SQL Server 后，您所做的某些配置更改才会生效。” 注意，需要重启的是SQL Server而不是SSMS，把窗口关闭再打开是没有用的。可以先关闭SSMS，在开始菜单中找到SQL Server 2019配置管理器， 在这里把SQL Server停止后再启动即可。注意在这里还可以更改服务的启动模式，如果你不想电脑启动时自动运行SQL Server服务，可以把启动模式改为手动。（不推荐） 当然此过程也可以使用命令完成，由于不是SQL相关内容，就不加赘述了。参考sc查询。 重新启动之后就可以输入用户名和密码登录了，为了方便演示，我这里同时登录两个用户。 注意切换到SQL身份验证。 授权# 登录好后新建查询，注意右下角状态栏的标识（student_user），可以用来区分当前的用户。 可以尝试查询一下数据，默认是没有任何权限的。 1SELECT * FROM course 12消息 229，级别 14，状态 5，第 1 行拒绝了对对象 'course' (数据库 'students'，架构 'dbo')的 SELECT 权限。 切换到管理员账户（切换查询即可，不同的查询会对应不同的账户，利用状态栏可以分辨），对学生用户授权。 1GRANT SELECT ON course TO student_user 再次使用学生账户查询： 1SELECT * FROM course 已经可以查询到结果了。 参考：配置数据库对象的权限 注意之前的要求是：根据学号和课程号来查询成绩，显然不能直接授予SELECT权限，这样学生可以查出所有的成绩。可以使用过程封装查询步骤。 12345678CREATE PROC query_grade@sno VARCHAR(50),@cno VARCHAR(50)ASBEGIN SELECT * FROM sc WHERE sno = @sno AND cno = @cnoEND 测试一下： 1EXEC query_grade '201530311042', 'CS2' 1234sno cno grade---------------------------------- ------------------------------ -----------201530311042 CS2 79 接下来就容易了，只要把query_grade的执行权限授予student_user就行了。 1GRANT EXECUTE ON query_grade TO student_user 切换到学生用户测试一下： 1EXEC query_grade '201530311042', 'CS2' 1234sno cno grade---------------------------------- ------------------------------ -----------201530311042 CS2 79 可以查询，尝试查询所有成绩： 1SELECT * FROM sc 123消息 229，级别 14，状态 5，第 1 行拒绝了对对象 'sc' (数据库 'students'，架构 'dbo')的 SELECT 权限。 提示没有权限。 说明# 这篇文章只是对我近期进行的一些数据库实验的总结，其中列出的语句不一定正确，仅供参考。","link":"/posts/sqlserver-summary/"},{"title":"斐波那契数列总结","text":"斐波那契数列是从0，1开始，后面每一项都是由前面两项相加得到。开头几项是0、1、1、2、3、5、8、13……。在OEIS中是A000045数列。需要注意的是斐波那契数列的第零项是0，第一项是1。本文将探讨总结斐波那契数列的相关问题。 递归定义如下： $$ F_n = \\begin{cases} 0, & n = 0 \\\\ 1, & n = 1 \\\\ F_{n-1} + F_{n-2} & n > 1 \\end{cases} $$ 小范围求$f(n)$# $n \\le 39$# 对应题目：牛客网 【编程题】斐波那契数列 在这个范围内的斐波那契数列可以很容易计算出来，速度也非常快(1秒以内)，根据定义可以写出下面的递归程序： 1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;int f(int n) { if (n &lt; 2) return n; return f(n-1) + f(n-2);}int main() { cout &lt;&lt; f(39) &lt;&lt; '\\n'; cerr &lt;&lt; &quot;Time: &quot; &lt;&lt; (double)clock() / CLOCKS_PER_SEC &lt;&lt; '\\n'; return 0;} 运行结果： 1263245986Time: 0.184 注意：提交时需要改成类的版本。 $n \\le 46$# 对应题目：计蒜客T1066 斐波那契数列 看似数据范围仅仅增大了7，但我们继续使用上面的程序计算$f(46)$时，会得到如下结果： 121836311903Time: 4.946 时间已经超出了1秒的限制，考虑优化一下计算方法。实际上在递归调用的过程中，有很多值被重复计算了。我们可以记录下已经算过的值，当下次需要时直接读取，不再重复计算。 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int fib[47];int f(int n) { if (n &lt; 2) return n; else if (fib[n]) return fib[n]; // 已经算过 else return fib[n] = f(n - 1) + f(n - 2);}int main() { int n = 46; // cin &gt;&gt; n; cout &lt;&lt; f(n) &lt;&lt; '\\n'; cerr &lt;&lt; &quot;Time: &quot; &lt;&lt; (double)clock() / CLOCKS_PER_SEC &lt;&lt; '\\n'; return 0;} 再次测试$f(46)$，发现这次计算的非常快！ 121836311903Time: 0.001 $n \\le 100$# 对应题目：力扣 剑指 Offer 10- I. 斐波那契数列 注意到答案开始需要对$10^9+7$取模了，但我们仍然可以使用上面的写法（加个取模）即可通过此题。 点击展开代码 >folded12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;const int M = 1e9 + 7;int fib[101];int f(int n) { if (n &lt; 2) return n; else if (fib[n]) return fib[n]; // 已经算过 else return fib[n] = (f(n - 1) + f(n - 2)) % M;}int main() { int n = 100; // cin &gt;&gt; n; cout &lt;&lt; f(n) &lt;&lt; '\\n'; cerr &lt;&lt; &quot;Time: &quot; &lt;&lt; (double)clock() / CLOCKS_PER_SEC &lt;&lt; '\\n'; return 0;}// 运行结果：// 687995182// Time: 0.001 这次我们尝试换一种写法，不使用数组，利用两个变量递推得出结果。时间复杂度和上面的代码一样，但空间复杂度更加优秀。 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;const int M = 1e9 + 7;int main() { int n = 100, a = 0, b = 1; // cin &gt;&gt; n; while (n--) { a = (a + b) % M; swap(a, b); } cout &lt;&lt; a &lt;&lt; '\\n'; cerr &lt;&lt; &quot;Time: &quot; &lt;&lt; (double)clock() / CLOCKS_PER_SEC &lt;&lt; '\\n'; return 0;}// 运行结果：// 687995182// Time: 0 一开始a代表$f(0)$，每循环一次，a表示的数就往后一位，所以循环n次后，a就表示$f(n)$。 $n \\le 4786$# 对应题目：HHUOJ-1387 大斐波那契数 注：题目仅给出结果不超过1000位。 容易发现C++中的int甚至long long都无法保存这么大的数了，但好在评测系统是支持Python的，考虑到Python写法简单且自带大数，我们可以尝试使用Python来写这题。 前面提到，斐波那契数列后面每一项都是由前面两项相加得到。我们可以根据这条规则来写代码。 1234567from itertools import countf = [0, 1]for i in count(2): f.append(f[-1] + f[-2]) if len(str(f[i])) &gt; 1000: breakfor n in [*open(0)]: print(f[int(n)]) 其中f[-1]表示取序列f中最后一个元素，count(2)产生一个从2开始的无限序列，[*open(0)]表示打开标准输入文件并按行分割成列表。 其他写法# 还有很多有趣的写法来求小范围的斐波那契数列，这里列举几种，就不详细展开了。 Python 生成器 1234567def fib(n): i, a, b = 0, 0, 1 while i &lt; n: yield a a, b = b, a + b i = i + 1print(list(fib(10))) 大范围求$f(n)$# 前面提到的算法的时间复杂度是$O(n)$的，理论上来说可以在1秒以内求出$10^8$以内的值，所以这里的大范围肯定是要比$10^8$还大的。 $n \\le 10^9$# 对应题目：POJ-3070 Fibonacci 注意此题的模数是10000。 题目中已经给出了关于Fibonacci数列的另一个很重要的公式： $$ \\begin{pmatrix} F_{n+1} & F_n \\\\ F_n & F_{n-1} \\end{pmatrix}= \\begin{pmatrix} 1 & 1\\\\ 1 & 0 \\end{pmatrix} ^n $$ 考虑到n比较大，可以使用矩阵快速幂求解。矩阵快速幂是快速幂算法的变形，仍然是利用如下原理： $$ x^y = \\begin{cases} x \\cdot x^{y-1}, & y为奇数 \\\\ x^{y/2} \\cdot x^{y/2}, & y为偶数 \\end{cases} $$ 通常我习惯把它写成while循环结合位运算的形式。时间复杂度为$O(\\log(n))$ 123456789101112131415161718192021222324252627#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int M = 1e4;typedef int mat[2][2];#define FOR(i, n) for(int i = 0; i &lt; n; i++)void muleq(mat &amp;a, mat &amp;b) { mat c{}; FOR(i, 2) FOR(j, 2) FOR(k, 2) c[i][j] = (c[i][j] + a[i][k] * b[k][j] % M) % M; memcpy(a, c, sizeof(a));}int main() { int n; while (cin &gt;&gt; n) { if (n == -1) break; mat a{{1, 1}, {1, 0}}; mat ans{{1, 0}, {0, 1}}; while (n) { if (n &amp; 1) muleq(ans, a); muleq(a, a); n &gt;&gt;= 1; } cout &lt;&lt; ans[1][0] &lt;&lt; '\\n'; } return 0;} 由于POJ的编译器比较老，采用了不那么直观的写法。muleq(a, b)的含义是a = a * b，其中a、b均为矩阵，*为矩阵乘法。 $n \\le 10^{18}$# 对应题目：51Nod 1242 斐波那契数列的第N项 利用上面的做法同样可以通过此题，这里利用运算符重载给出更直观一点的代码。 注意：此题的模数为$10^9+9$。 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const ll M = 1e9 + 9;using Mat = array&lt;array&lt;ll, 2&gt;, 2&gt;;#define FOR(i, n) for(int i = 0; i &lt; n; i++)Mat operator*(const Mat &amp;a, const Mat &amp;b) { Mat c{}; FOR(i, 2) FOR(j, 2) FOR(k, 2) c[i][j] = (c[i][j] + a[i][k] * b[k][j]) % M; return c;}Mat Pow(Mat x, ll y) { Mat ans{{{1, 0}, {0, 1}}}; while (y) { if (y &amp; 1) ans = ans * x; x = x * x; y &gt;&gt;= 1; } return ans;}int main() { ll n = 1e18; // cin &gt;&gt; n; cout &lt;&lt; Pow(Mat{{{1, 1}, {1, 0}}}, n)[0][1] &lt;&lt; '\\n'; cerr &lt;&lt; &quot;Time: &quot; &lt;&lt; (double)clock() / CLOCKS_PER_SEC &lt;&lt; '\\n'; return 0;}// 运行结果：// 209762233// Time: 0.001 $n \\le 10^{10^{6}}$# 类似题目：2019牛客多校5B generator 1 对于这个范围的数，其实上面的算法也是可以解决的，就是实现上需要一些技巧。由于给定的n是一个十进制的数，将他转换成二进制需要花费大量时间，因此我们可以直接使用十进制下的快速幂来计算。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const ll M = 1e9 + 7;using Mat = array&lt;array&lt;ll, 2&gt;, 2&gt;;#define FOR(i, n) for(int i = 0; i &lt; n; i++)string n;int len;Mat operator*(const Mat &amp;a, const Mat &amp;b) { Mat c{}; FOR(i, 2) FOR(j, 2) FOR(k, 2) c[i][j] = (c[i][j] + a[i][k] * b[k][j]) % M; return c;}Mat Pow(Mat x, int y) { Mat ans{{{1, 0}, {0, 1}}}; FOR(t, y) ans = ans * x; return ans;}ll Pow(ll x, ll y) { ll ans = 1; while (y) { if (y &amp; 1) ans = ans * x % M; x = x * x % M; y &gt;&gt;= 1; } return ans;}Mat Pow(Mat x) { Mat ans{{{1, 0}, {0, 1}}}; FOR(i, len) { ans = ans*Pow(x, n[i]-'0'); x = Pow(x, 10); } return ans;}int main() { n = &quot;1&quot; + string(1e6, '0'); len = (int)n.length(); reverse(n.begin(), n.end()); Mat A = Pow(Mat{{{1, 1}, {1, 0}}}); cout &lt;&lt; A[1][0] &lt;&lt; '\\n'; return 0;} 其他写法# 不使用矩阵的矩阵快速幂。由于斐波那契数列的矩阵递推式非常小（$2\\times 2$），我们可以利用函数参数在递归时巧妙的计算。（对应题目：51Nod 1242 斐波那契数列的第N项） 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const ll M = 1e9 + 9;ll f(ll n, ll a = 1, ll b = 0, ll p = 0, ll q = 1) { if (!n) return b; if (n &amp; 1) return f(n-1, (b*q+a*q+a*p)%M, (b*p+a*q)%M, p, q); return f(n/2, a, b, (p*p+q*q)%M, (q*q+2*q*p)%M);}int main() { ll n = 1e18; // cin &gt;&gt; n; cout &lt;&lt; f(n) &lt;&lt; '\\n'; cerr &lt;&lt; &quot;Time: &quot; &lt;&lt; (double)clock() / CLOCKS_PER_SEC &lt;&lt; '\\n'; return 0;}// 运行结果：// 209762233// Time: 0.002 利用循环节计算。当模数给定且n的范围远大于模数时，可以采用找循环节的做法，相比于十进制快速幂会好写很多，但有时循环节是不固定的。 如果不知道或者忘记了如何求斐波那契数列在给定模数下的循环节，可以写一个暴力程序求出。参考下面的代码： 点击展开代码 >folded123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;ll fib(ll m) { ll a = 1, b = 1, c = 1; while (!(a == 0 &amp;&amp; b == 1)) { c++; a = (a + b) % m; swap(a, b); } return c;}int main() { cout &lt;&lt; (int)(1e4) &lt;&lt; ' ' &lt;&lt; fib(1e4) &lt;&lt; '\\n'; cout &lt;&lt; (int)(1e9+7) &lt;&lt; ' ' &lt;&lt; fib(1e9+7) &lt;&lt; '\\n'; cout &lt;&lt; (int)(1e9+9) &lt;&lt; ' ' &lt;&lt; fib(1e9+9) &lt;&lt; '\\n'; cerr &lt;&lt; &quot;Time: &quot; &lt;&lt; (double)clock() / CLOCKS_PER_SEC &lt;&lt; '\\n'; return 0;}// 运行结果：// 10000 15000// 1000000007 2000000016// 1000000009 333333336// Time: 7.443 斐波那契相关问题# 对于其他和斐波那契数列相关的问题，如广义斐波那契数列、斐波那契数列前缀和等，这里归类为斐波那契相关问题。通常需要用到一些斐波那契数列的性质，参考文章：斐波那契数_孙智宏。 广义斐波那契数列# 对应题目：51Nod-1126 求递推序列的第N项 注意：此题下标从1开始。 广义斐波那契数列是斐波那契数列的推广，定义如下： $$ F_n = \\begin{cases} A, & n = 0 \\\\ B, & n = 1 \\\\ C\\cdot F_{n-1} + D \\cdot F_{n-2}, & n > 1 \\end{cases} $$ 当A=0，B=C=D=1是变成普通的斐波那契数列，A=2，B=C=D=1时，变成卢卡斯序列。 广义斐波那契数列的处理方式基本一样。我们可以推一下这个序列的矩阵递推式： $$ \\begin{aligned} \\begin{pmatrix} f_{n+1} \\\\ f_n \\end{pmatrix} & = \\begin{pmatrix} C & D\\\\ 1 & 0 \\end{pmatrix} \\begin{pmatrix} f_n \\\\ f_{n-1} \\end{pmatrix}\\\\ & = \\begin{pmatrix} C & D\\\\ 1 & 0 \\end{pmatrix}^{n} \\begin{pmatrix} B \\\\ A \\end{pmatrix} \\end{aligned} $$ 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const ll M = 7;using Mat = array&lt;array&lt;ll, 2&gt;, 2&gt;;#define FOR(i, n) for(int i = 0; i &lt; n; i++)Mat operator*(const Mat &amp;a, const Mat &amp;b) { Mat c{}; FOR(i, 2) FOR(j, 2) FOR(k, 2) c[i][j] = (c[i][j] + a[i][k] * b[k][j]) % M; return c;}int main() { int a, b, n; cin &gt;&gt; a &gt;&gt; b &gt;&gt; n; Mat m{{{a, b}, {1, 0}}}; Mat ans{{{1, 0}, {0, 1}}}; for (n--; n; n &gt;&gt;= 1) { if (n &amp; 1) ans = ans * m; m = m * m; } cout &lt;&lt; ((ans[1][0] + ans[1][1]) % M + M) % M &lt;&lt; '\\n'; return 0;} 求区间和# 对应题目：HITOJ-2060 Fibonacci Problem Again。 注意：此题斐波那契数列前两项为1，模数为$10^9$。 考虑一般的斐波那契数列区间和，可以直接转化成斐波那契数列求解：$S(n)=f(n+2)-1$，其中$S(n)=\\sum\\limits_{i=0}^n f(i)$。 直接套用一个上面的代码，复杂度$O(log(n))$ 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const ll M = 1e9;ll f(ll n, ll a = 1, ll b = 0, ll p = 0, ll q = 1) { if (!n) return b; if (n &amp; 1) return f(n-1, (b*q+a*q+a*p)%M, (b*p+a*q)%M, p, q); return f(n/2, a, b, (p*p+q*q)%M, (q*q+2*q*p)%M);}int main() { ll a, b; while (cin &gt;&gt; a &gt;&gt; b) { if (a == 0 &amp;&amp; b == 0) break; cout &lt;&lt; (f(b+3)-f(a+2)+M)%M &lt;&lt; '\\n'; } return 0;} 循环节加速# 对应题目：Fibonacci Again 实际上广义斐波那契数列也是有循环节的。利用之前提到的方法，可以直接算出这个序列的循环节为8。而该序列的前8项为[7, 11, 18, 29, 47, 76, 123, 199]，其中能被3整除的有[2, 6] 项，即n % 4 == 2是为yes。 123456789#include &lt;bits/stdc++.h&gt;using namespace std;int main() { int n; while (cin &gt;&gt; n) { cout &lt;&lt; ((n % 4 == 2) ? &quot;yes&quot; : &quot;no&quot;) &lt;&lt; '\\n'; } return 0;} 小范围求循环节# 对应题目：HDU3977 Evil teacher 对于一个给定的模数，如何求出循环节呢？利用枚举的方法显然太慢了，我们可以利用这篇论文：The Period of the Fibonacci Sequence Modulo j.pdf中提到的一些性质来加速求解。 (定理3) 设$j$是一个正数，且$j=\\prod\\limits_{i=1}^s p_i^{k_i}$，其中$p_i$是素数，设$m_i$表示$F_n(\\mod p_i^{k_i})$的循环节，$m$表示$F_n(\\mod j)$的循环节，则有$m=lcm(m_1, m_2, …, m_s)$。 利用这条性质，我们可以先把模数P质因数分解，转换为求模数为$p^k$的情况。 再根据这条推论： 设$G( p )$表示$F_n(\\mod p)$的循环节，其中$p$为质数，则有$G(p^k)=G( p )\\cdot p^{k-1}$。 （详细证明可以参考这篇博客） 此外还有一个小性质：$G( p ) \\le 6p$（证明参考这里）可以帮助我们估算复杂度。 注意到P的最大素因子不超过$10^6$，且只有20组，估算一下最坏情况下的复杂度完全可以通过此题。 点击展开代码 >folded1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e6+5;inline ll lcm(ll a, ll b) { return a / __gcd(a, b) * b; }ll fib_perd(ll m) { // 求Fn mod m 循环节 ll a = 1, b = 1, c = 1; while (!(a == 0 &amp;&amp; b == 1)) { c++; a = (a + b) % m; swap(a, b); } return c;}vector&lt;bool&gt; is_prime;vector&lt;ll&gt; prime;void get_prime() { // 素数筛法 is_prime.resize(N, true); is_prime[0] = is_prime[1] = false; for (ll i = 2; i &lt; N; i++) { if (!is_prime[i]) continue; prime.push_back(i); for (ll j = i * i; j &lt; N; j += i) is_prime[j] = false; }}int main() { get_prime(); int t; cin &gt;&gt; t; for (int i = 1; i &lt;= t; i++) { ll n; cin &gt;&gt; n; ll ans = 1; for (auto p : prime) { // 质因数分解 if (n % p) continue; ll pk = 1; // 保存p^k while (n % p == 0) pk *= p, n /= p; ans = lcm(ans, pk / p * fib_perd(p)); } cout &lt;&lt; &quot;Case #&quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; '\\n'; } return 0;} 通项公式# 上面已经得到了斐波那契数列公式的矩阵形式，要得到通项公式，还需要进一步变换。这里采用线性代数的方法。 $$ \\begin{aligned} \\begin{pmatrix} F_{n+1} \\\\ F_n \\end{pmatrix} & = \\begin{pmatrix} 1 & 1\\\\ 1 & 0 \\end{pmatrix}^n \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} \\end{aligned} $$ 利用对角化计算方阵的幂。 设矩阵$A=\\begin{pmatrix} 1 &amp; 1\\\\ 1 &amp; 0 \\end{pmatrix}$，其特征方程为：$|\\lambda E-A|$，其中$E$为单位矩阵。 计算得： $$ \\begin{aligned} |\\lambda E-A| & = \\left| \\begin{matrix} \\lambda-1 & -1\\\\ -1 & \\lambda \\end{matrix} \\right| \\\\ & = \\lambda^2-\\lambda-1 \\end{aligned} $$ 解得$\\lambda_1=\\frac{1-\\sqrt{5}}{2}$，$\\lambda_2=\\frac{1+\\sqrt{5}}{2}$。 代入特征值$\\lambda_1$，解齐次线性方程组$(\\lambda E - A)X=0$： $$ \\lambda E - A = \\begin{pmatrix} -\\lambda_2 & -1 \\\\ -1 & \\lambda_1 \\end{pmatrix} $$ 将矩阵第一行乘以$\\lambda_1$加到第二行，矩阵变换为： $$ \\begin{pmatrix} -\\lambda_2 & -1 \\\\ 0 & 0 \\end{pmatrix} $$ 即$x_2=-\\lambda_2 x_1$，取$x_1=1$，则其基础解系为$X_1=\\begin{pmatrix}1 \\\\ -\\lambda_2\\end{pmatrix}$。 取特征向量为$\\xi_1=\\begin{pmatrix}1 \\\\ -\\lambda_2\\end{pmatrix}$，对于$\\lambda_2$同理可得$\\xi_2=\\begin{pmatrix}1 \\\\ -\\lambda_1\\end{pmatrix}$。 令 $$ \\begin{aligned} P & = (\\xi_1, \\xi_2)\\\\ & = \\begin{pmatrix}1 & 1\\\\ -\\lambda_2 & -\\lambda_1\\end{pmatrix}\\\\ & = \\begin{pmatrix}1 & 1\\\\ \\lambda_2 & \\lambda_1\\end{pmatrix} \\end{aligned} $$ 利用增广矩阵求逆。 $$ \\begin{aligned} (P|E) & = \\begin{pmatrix} 1 & 1 & 1 & 0\\\\ \\lambda_2 & \\lambda_1 & 0 & 1 \\end{pmatrix} \\\\ & = \\begin{pmatrix} 1 & 1 & 1 & 0\\\\ 0 & -\\sqrt{5} & -\\lambda_2 & 1 \\end{pmatrix} \\\\ & = \\begin{pmatrix} 1 & 0 & \\frac{\\sqrt{5}-1}{2\\sqrt{5}} & \\frac{1}{\\sqrt{5}}\\\\ 0 & -\\sqrt{5} & -\\lambda_2 & 1 \\end{pmatrix} \\\\ & = \\begin{pmatrix} 1 & 0 & \\frac{\\sqrt{5}-1}{2\\sqrt{5}} & \\frac{1}{\\sqrt{5}}\\\\ 0 & 1 & \\frac{1+\\sqrt{5}}{2\\sqrt{5}} & -\\frac{1}{\\sqrt{5}} \\end{pmatrix} \\\\ \\end{aligned} $$ 依次进行的变换为： 第一行乘以$-\\lambda_2$加到第二行 第二行乘以$\\frac{1}{\\sqrt{5}}$加到第一行 第三行乘以$-\\frac{1}{\\sqrt{5}}$ 注：Wolfram验算 可得$P^{-1}=\\begin{pmatrix} \\frac{\\sqrt{5}-1}{2\\sqrt{5}} &amp; \\frac{1}{\\sqrt{5}}\\\\ \\frac{1+\\sqrt{5}}{2\\sqrt{5}} &amp; -\\frac{1}{\\sqrt{5}}\\end{pmatrix}$。 由于$P^{-1}AP=\\begin{pmatrix}\\lambda_1 &amp; 0 \\\\ 0 &amp; \\lambda_2\\end{pmatrix}$，故$A^n=P\\begin{pmatrix}\\lambda_1^n &amp; 0 \\\\ 0 &amp; \\lambda_2^n\\end{pmatrix}P^{-1}$，于是： $$ \\begin{aligned} \\begin{pmatrix} F_{n+1} \\\\ F_n \\end{pmatrix} & = A^{n} \\begin{pmatrix}1 \\\\0\\end{pmatrix}\\\\ & = \\begin{pmatrix}1 & 1\\\\ \\lambda_2 & \\lambda_1\\end{pmatrix} \\begin{pmatrix}(\\lambda_1)^n & 0 \\\\ 0 & (\\lambda_2)^n\\end{pmatrix} \\begin{pmatrix} \\frac{\\sqrt{5}-1}{2\\sqrt{5}}\\\\ \\frac{1+\\sqrt{5}}{2\\sqrt{5}}\\end{pmatrix}\\\\ & = \\begin{pmatrix}1 & 1\\\\ \\lambda_2 & \\lambda_1\\end{pmatrix} \\begin{pmatrix}\\frac{\\sqrt{5}-1}{2\\sqrt{5}}(\\lambda_1)^n \\\\ \\frac{1+\\sqrt{5}}{2\\sqrt{5}}(\\lambda_2)^n\\end{pmatrix} \\end{aligned} $$ 因此： $$ \\begin{aligned} F_n & = \\lambda_2\\cdot \\frac{\\sqrt{5}-1}{2\\sqrt{5}}(\\lambda_1)^n+\\lambda_1\\cdot\\frac{1+\\sqrt{5}}{2\\sqrt{5}}(\\lambda_2)^n\\\\ & = \\frac{1}{\\sqrt{5}}[(\\lambda_2)^n-(\\lambda_1)^n] \\end{aligned} $$ 参考：斐波那契数列通项公式是怎样推导出来的？ - 面无表情的仔仔的回答 - 知乎 利用通项公式计算# 这种方式本质上还是利用快速幂计算，不过不需要矩阵了。 首先考虑一下通项公式中的根号与分式如何处理，假设模数为$M$，以$\\frac{1+\\sqrt{5}}{2}$为例，假设$x\\equiv\\frac{1+\\sqrt{5}}{2}\\pmod{M}$，则有$(2x-1)^2\\equiv5\\pmod{M}$。 以$M=10^9+9$为例，直接暴力求出x。（需要运行几分钟，其实有更快的算法，但是较为复杂，就先不讲了） 1234567M = 10**9 + 9for x in range(1, M): if (2*x-1)**2 % M == 5: print(x)# 运行结果：# 308495997# 691504013 另一个解是$\\frac{1-\\sqrt{5}}{2}$。同理计算出$\\frac{1}{\\sqrt{5}}$的结果为276601605、723398404，通过尝试我们可以找出正确的组合。 对应题目：51Nod1242 斐波那契数列的第N项 这样我们就可以写出非常简短的代码： 12n, m, p, s = int(input()), 10**9+9, 308495997, 723398404print(s*(pow(p,n,m)-pow(m-p+1,n,m))%m) 注：python的pow自带快速幂，时间复杂度仍然是$O(\\log n)$。python实现的取模运算保证结果为非负数，因此减法部分不用考虑负数问题。 斐波那契数列相关难题# 部分题目来自：斐波那契数列的那些题。 这些题目十分有难度，后续会慢慢补上。。。 k次幂求和# 对应题目：51Nod1236 序列求和 V3、ZOJ3774 Power of Fibonacci 不妨设$\\phi=\\frac{1+\\sqrt{5}}{2}$,$\\bar\\phi=\\frac{1-\\sqrt{5}}{2}$。 则有$F_n=\\frac{1}{\\sqrt{5}}(\\phi^n-\\bar\\phi^n)$。 那么：$F_n^k=(\\frac{1}{\\sqrt{5}})^k(\\phi^n-\\bar\\phi^n)^k$。 利用二项式定理展开得： $$ F_n^k=(\\frac{1}{\\sqrt{5}})^k\\sum_{i=0}^kC_k^i(\\phi^n)^{k-i}(-\\bar\\phi^n)^i $$ 求前缀和计算得： $$ \\begin{aligned} S_n & = \\sum_{i=1}^nF_i^k\\\\ & = \\sum_{i=1}^n(\\frac{1}{\\sqrt{5}})^k\\sum_{j=0}^kC_k^j(\\phi^i)^{k-j}(-\\bar\\phi^i)^j\\\\ & = (\\frac{1}{\\sqrt{5}})^k\\sum_{i=1}^n\\sum_{j=0}^k (-1)^j C_k^j \\phi^{i(k-j)} \\bar\\phi^{ij}\\\\ \\end{aligned} $$ 变换求值顺序（将j看成定值）有： $$ S_n = (\\frac{1}{\\sqrt{5}})^k\\sum_{j=0}^k (-1)^j C_k^j \\sum_{i=1}^n (\\phi^{k-j} \\bar\\phi^j)^i\\\\ $$ 不妨设$q=\\phi^{k-j} \\bar\\phi^j$，若$q=1$，则$\\sum\\limits_{i=1}^n (\\phi^{k-j} \\bar\\phi^j)^i=n$，否则利用等比数列求和公式计算得$\\frac{q\\cdot (1-q^n)}{1-q}$。 于是我们预处理出阶乘、以及两个常量的幂次，即可计算，时间复杂度$O(K+TK\\log n)$。 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int N = 1e5 + 5;const ll M = 1e9 + 9;ll phi[N], phj[N], fac[N];#define FOR(i, a, b) for (int i = a; i &lt; b; i++)#define PRE(arr, n) arr[0] = 1; FOR(i, 1, N) arr[i] = arr[i-1]*n%Mll qpow(ll x, ll y) { ll ans = 1; for (; y; y &gt;&gt;= 1) { if (y &amp; 1) ans = ans * x % M; x = x * x % M; } return ans;}inline ll inv(ll x) { return qpow(x, M-2); }int main() { ios::sync_with_stdio(false), cin.tie(0); PRE(fac, i); PRE(phi, 691504013); PRE(phj, 308495997); int t; cin &gt;&gt; t; while (t--) { ll n, k; cin &gt;&gt; n &gt;&gt; k; ll ans = 0; FOR(j, 0, k+1) { ll q = phi[k-j]*phj[j]%M; ll com = fac[k]*inv(fac[j]*fac[k-j]%M)%M; ll prod = (q==1) ? (n%M) : (q*(qpow(q,n)-1)%M*inv(q-1)%M); ans = (j&amp;1) ? (ans-com*prod)%M : (ans+com*prod)%M; } cout &lt;&lt; (ans*qpow(276601605, k)%M+M)%M &lt;&lt; '\\n'; } return 0;} 顺带一提，我还尝试用Python写这题（理论复杂度应该没有问题），发现可以通过51Nod（时限为18s）但是无法通过ZOJ（时限为5s）。从51Nod的测试结果来看，上面的C++程序只跑了不到1s，而Python写法最多要跑10s。 不同语言的时间限制和内存限制是相同的吗？ 是相同的，我们认为选择合适的编程语言也是一项必备技能，所以没有为不同语言设置不同的限制条件。（来自ZOJ） 如果有知道如何优化Python时间的希望能留言告诉我一下。 点击展开代码 >folded12345678910111213141516t, m, fac = int(input()), 10**9+9, [1]for i in range(1, 100001): fac.append(fac[-1]*i%m) # 预处理阶乘inv = lambda x: pow(x, m-2, m) # 计算逆元phi, phibar = [1], [1]for i in range(1, 100001): phi.append(phi[-1]*691504013%m)for i in range(1, 100001): phibar.append(phibar[-1]*308495997%m)for i in range(t): n, k = list(map(int, input().split())) ans = 0 for j in range(k+1): q = phi[k-j]*phibar[j]%m com = fac[k]*inv(fac[j]*fac[k-j]%m)%m prod = n if q==1 else q*(m+1-pow(q, n, m))%m*inv(m+1-q)%m sgn = 1 if j%2==0 else -1 ans = (ans + com*sgn*prod + m) % m print(ans*pow(276601605,k,m)%m) 大范围求循环节# 对应题目：51Nod1195 斐波那契数列的循环节 这题是之前小范围求循环节的加强版，质数的范围最大可以到$10^9$。可以再仔细阅读一下这篇论文：The Period of the Fibonacci Sequence Modulo j.pdf。 主要利用这条性质加速计算： 对于质数$p &gt; 5$，如果5是模p的二次剩余，那么模p意义下的循环节长度是(p-1)的因子，否则是(2p+2)的因子。 利用欧拉判定准则来判断二次剩余。 代码中还用到了一些数论方面的知识，例如素数筛法、质因数分解、枚举因子、判二次剩余。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;// 质数表大小以及小范围常量表const int N = 1e5, pd[6]{0, 1, 3, 8, 6, 20}; ll lcm(ll a, ll b) { return a / __gcd(a, b) * b; }// 矩阵快速幂求斐波那契数列ll fib(ll n, ll mod, ll a = 1, ll b = 0, ll p = 0, ll q = 1) { if (!n) return b; if (n &amp; 1) return fib(n-1, mod, (b*q+a*q+a*p)%mod, (b*p+a*q)%mod, p, q); return fib(n/2, mod, a, b, (p*p+q*q)%mod, (q*q+2*q*p)%mod);}// 检查mod下循环节是否为perdbool check_perd(ll mod, ll perd) { return fib(perd, mod)==0 &amp;&amp; fib(perd+1, mod)==1;}vector&lt;bool&gt; is_prime;vector&lt;ll&gt; prime;// 素数筛法void get_prime() { is_prime.resize(N, true); is_prime[0] = is_prime[1] = false; for (ll i = 2; i &lt; N; i++) { if (!is_prime[i]) continue; prime.push_back(i); for (ll j = i * i; j &lt; N; j += i) is_prime[j] = false; }}// 质因数分解vector&lt;pair&lt;ll, ll&gt;&gt; get_factor(ll n) { vector&lt;pair&lt;ll, ll&gt;&gt; factor; for (auto p : prime) { if (p &gt; n / p) break; if (n % p) continue; int cnt = 0; while (n % p == 0) cnt++, n /= p; factor.emplace_back(p, cnt); } if (n &gt; 1) factor.emplace_back(n, 1); return factor;}// 快速幂ll pow(ll x, ll y, ll mod = 9e18, ll ans = 1) { if (!y) return ans; if (y&amp;1) return pow(x, y-1, mod, ans*x%mod); else return pow(x*x%mod, y&gt;&gt;1, mod, ans);}// 判断n是否为p的二次剩余bool is_quad(ll n, ll p) { return pow(n, (p-1)&gt;&gt;1, p) == 1;}// 枚举因子vector&lt;ll&gt; perm_factor(ll n) { auto factor = get_factor(n); vector&lt;ll&gt; divisor; function&lt;void(ll, int)&gt; dfs = [&amp;](ll d, int i) { if (i == (int)factor.size()) return divisor.push_back(d); for (ll j = 0; j &lt;= factor[i].second; j++) dfs(d * pow(factor[i].first, j), i+1); }; return dfs(1, 0), divisor;}// 求循环节ll fib_pred(ll n) { if (n &lt;= 5) return pd[n]; // 小于等于5的数不满足该性质 ll t = is_quad(5, n) ? (n-1) : (2*n+2); for (auto d : perm_factor(t)) // 枚举所有t的因子 if (check_perd(n, d)) return d; return assert(false), 0;}// 处理每一组数据void solve() { ll n, ans = 1; cin &gt;&gt; n; for (auto f : get_factor(n)) ans = lcm(ans, pow(f.first, f.second-1) * fib_pred(f.first)); cout &lt;&lt; ans &lt;&lt; '\\n';}int main() { ios::sync_with_stdio(false), cin.tie(0); get_prime(); int t = 1; cin &gt;&gt; t; while (t--) solve(); return 0;} 参考博客 最小公倍数# 对应题目：51Nod1355 斐波那契的最小公倍数 找位置# 对应题目：51Nod1145 斐波那契数列 求$f(n)\\mod f(k)$# 对应题目：51Nod1194 Fib(N) mod Fib(K) 广义斐波那契数列求循环节# 对应题目：1263 广义斐波那契数列 参考论文：PeriodRankOrderMMofficial.pdf 斐波那契字符串# 对应题目：51Nod 1146 斐波那契字符串 $\\pi$斐波那契数列# 对应题目：51Nod1149 Pi的递推式","link":"/posts/fibonacci-summary/"},{"title":"怎样花两年时间去面试一个人","text":"最近参加了两场面试，也是挺有感触的。分享一篇与面试相关的文章，里面很多内容即使十年过去了也丝毫不过时，甚至每次读过都有新的感悟。例如里面提到了关于大作业的部分： 一想到作业是要作为简历的一部分的，能不紧张嘛。能不好好做嘛。能不学到点东西嘛？ 我在写数据结构大作业的时候就干过这事，把一个2学分的课程大作业当作一个大项目来完成，提交了800多次commits，给软件加上版本号，发布了Windows、MacOS以及Ubuntu三个系统的软件包，加上持续构建脚本…… 以下内容摘自怎样花两年时间去面试一个人 – 刘未鹏 | Mind Hacks，修正了一些笔误以及将失效链接换成了Web Archive的链接。 Joel Spolsky曾经感叹：招聘难，难于上青天（此处笔者稍加演绎:)）。他有两个辛辣但不乏洞察力的断言：真正的牛人也许一辈子就投大概4次简历，这些家伙一毕业就被好公司抢走了，并且他们的雇主会给他们不赖的待遇，所以他们也不想挪窝。（刚刚去世的Dennis Ritchie就是这样一个人）而“人才”市场上能找到的大多都不是什么人才。招到这帮人轻则费钱重则把你公司搞挂。 （当我把这篇文章给邹欣老师review的时候，他说了另外两点：1. 最好的人也许不投简历，就决定去哪里了。所以要在他们做决定前找到他们。2. 比较差的会投很多次简历，找不到工作的时间越多，投的简历越多，给整个pool 带来很多噪音，top10%的简历也许根本不算全部人的top10%。） 诚然，也许没有哪个行业像IT行业这样，无形资产占据公司的绝大多数资产。拒坊间传言比尔·盖茨就曾经说过类似这样的话：只要允许我带走100个人我可以再造一个微软。这话没搜到原版出处，但是从一个侧面反映了IT公司当中智力资产所占的比例之重。 所以一个自然的推论就是，招聘也许是一个公司决策当中最最重要的一个环节。Joel Spolsky把他在这方面的观察，体会和洞见集结成了一本小册子《Smart and Gets Things Done》，开篇就挑战“产品是公司成败的关键”这个传统观念，他认为创造最适合工程师生活的环境，留下最优秀的人才才是最先最重要的一步，接下来好的产品是水到渠成的事情。国内iapp4me.com创始人郝培强正是这个理念，所以他在微博上说： 我们是小公司，工资开的不高，也不招太多的人，但是电脑都是iMac27，iMac21，Macbook pro15，基本上比很多大公司都好多了。软件没盗版，刚才photoshop的正版我也收了。中午管饭，公司备伞。哈哈。节日假正常放，从不加班，早晨11点上班，下午6点下班。我是有资格说某些大公司的员工苦逼的。 事实上，米国找个人尚且难成这样，搞得Joel还费心费力写本书语重心长地劝企业们要善待好工程师，国内找个人更是难上加难，国内高质量问答社区知乎创始人周源就曾经在知乎上分享他呕心沥血的招人历程，看完真是让人慨叹这年头找个靠谱的人多不容易（这条知乎问答还有很多精彩的跟帖）： 其实从 08 年到现在，我一直想这事能不能有点窍门，或者是实用的方法，结论是几乎没有。我用过的大家都用的方法： 在水木上发贴子（有点效果） 在蓝色理想上发贴子（无效） 在技术邮件组里发贴子（无效） 买 51job/智联 最便宜的服务（有点效果） 给所有可以想到的人打电话，请他们推荐（无效） 给所有和你讨论过创业，喝过点小酒的人打电话（无效） 约前同事私下谈（有效） 我用过的大家可能没有用的方法： 上 twitter，看 XXX 的 follower，一个一个看，看他们的 twitter，博客，Google Reader 分享，想办法搞到邮件，联系，半夜电话骚扰。 上豆瓣，前端后端挑几本重量级的书，去找想看，看过，正在看这本书的人，一个一个看，看他们的活动，博客，Google Reader 分享，想办法搞到邮件，联系，半夜电话骚扰。 找同事，问他们都看什么技术博客，想办法搞到邮件，联系，半夜电话骚扰。 正是这样的不容易，才有不少公司走内部培养的办法，这里的逻辑是：一上来就招到靠谱的人太难了，但找一块靠谱的璞玉然后雕琢雕琢相对就简单很多。这倒是个办法，但这样做的人难免就陷入了纠结：培养好了，人跑了怎么办。这也不能怪招聘的公司，的确是人之常情。其实解决的办法也很简单，培养的时候进行适当引导，让员工发挥自己的主动学习能力，这样不但人得到更多成长，公司也不会觉得投入太多患得患失。所谓师傅领进门修行在个人。 但是，这仍然还是没有解决根本的问题，就是招聘真的很困难。应聘者固然觉得自己是在“海投”，大海捞针一般。而招聘者何尝不也是这种大海捞针的感觉。这就好比两个人谈恋爱，都想和对方好上，但是偏偏就聊不到一块去。 招聘真的很困难。以至于招聘者每年需要绞尽脑汁出新笔试题，以免往年的笔试题早就被人背熟了。出题很费脑子，要出的不太简单也不太难，能够滤掉绝大多数滥竽充数的但又要保证不因题目不公平而滤掉真正有能力的，要考虑审题人的时间成本就只能大多数用选择题，而选择题又是可以猜答案的（极少有人会在选了答案之后还敢在空白的地方写为什么选某答案的原因的）。更悲催的是，有些题目出的连公司的员工们自己都会做错（真的是员工们做错了吗？还是题目本身就出错了？） 笔试完了之后如果还没有被鄙视就要进入面试环节，姑且不说笔试题的种种弊端，就说面试环节，短短几个小时的面试（大多数公司也许连几个小时的面试时间都没有），既需要全面考察基本知识，又要考察编程素养，还要考察（也许最重要的）性格心态。再然后还有一项根本没法考察但却占据程序员相当一部分工作时间的：debug能力。面试官不但得找准问题，不因对方一题答对而妄下结论，也不因一题答错而就扼杀机会，还要以管窥豹，从一朵花看到整个世界，从面试人的举止言谈，分析问题的方式，甚至写程序的笔迹来观察这个人的性格，做事的方式和心态，简直是要面试官具备心理分析师的水准才行。 这厢要招人的雇主苦不堪言，那边找工作的人也是一团乱麻。绝大多数应届生直到毕业也不清楚他们想要去的公司到底需要什么样的能力，或者说，他们到底需要具备什么样的能力才能在应聘季节拥有自己的选择权。中国虽然本科教育环境差，但是同样有很多的人在本科希望整点东西出来，他们有一腔的激情和抱负，有强大的动力，但就是不知道自己需要掌握哪些技能才能满足雇主的要求，求告无门，整年整年苦闷的像没头苍蝇一样乱撞（我就收到过很多次这样的来信，他们往往很想学点东西，但又不知道哪些重要哪些不重要，到底该学到什么程度，不知道导致不确定，不确定导致决策瘫痪，干脆嘛也不动，荒废时间）。 什么叫熟练？什么又叫精通？那么扎实呢？两年的YY经验又意味着什么？能这么简单的量化吗？同样是两年的“实践”有的人能真的学到点东西，有的人也许近似一无所得。那么实习呢？很多人都一定要在简历上弄个实习经验，这个又能说明多少问题呢？大作业呢？得奖呢？有一次我面试一位同学，据简历说编译原理课的大作业得了一等奖，可我一问什么是递归下降，就傻眼了。 这个现实的结果就是，现在绝大多数应届简历而言，也许最具信息量的部分不是“精通XXX，熟悉YYY，掌握ZZZ”，不是“在UUU实习过”，也不是这个项目那个作业，反倒是越来越被认为不重要的一项：毕业学校。毕业学校本不应该是最具信息量的，它之所以最具信息量只是源于一个悲剧的事实：简历上其他条目实在信息量太少了。所以靠谱的面试者往往学会了无视简历上华而不实的内容，只相信面试的时候亲眼所见，扫两眼简历也就罢了，最后还得自己捋起袖子慢慢面。而应聘者也许也知道招聘的也不会细细纠简历上的条目，所以什么词也都敢往上捅，反正先过了HR筛简历这关再说。从经济学角度来讲，应聘者的这种策略是正确的，没有代价（因为目前似乎没有公司会去给已经申请过的人做一个诚信数据库），但至少有可能会带来巨大的收益。应聘成了博彩。而博彩式的应聘给招聘公司带来了巨大的筛选压力。简历成了摆设。 那么招聘这个关系里面的第三者——学校——所处的位置呢？学校更关心的是毕业率和就业率，这似乎是件好事，有这个为目标，那么老师们似乎应该努力让自己的学生多学点东西。可惜就业的质量似乎不是最重要的指标，此其一。其二老师本身大多数没有丰富的业界经验，根本不知道企业真正需要的人才是什么样的，可能花了精力，但却培养不出雇主真正需要的人。另一方面，老师所起的作用很多时候甚至是一个负面的作用，例如布置大作业表面上看上去是培养学生的能力，我们姑且不说抄袭，假设每个人都做了，那么大作业本身能够衡量多少东西呢？能否衡量代码质量，能否衡量团队协作能力？能否衡量交流能力？考虑到大作业用到的东西往往都是书里面现成的，大作业甚至不能衡量学习能力。而学习能力简直算是这个行业最重要的能力没有之一了。 所以，简而言之，如果把人才培养/招聘这件事情本身类比做一个项目，那么这整个项目迄今为止就是一个巨大的失败。为什么这么说呢： 和需求严重脱节：作为人才需求方的雇主的需求到底是什么？绝大多数应聘者都没搞清。更严重的是，这却一点都不是应聘者的错。因为雇主是stakeholder（利益相关者），是雇主自己的责任得去说清楚需求是什么。结果应聘者实现的不是雇主想要的，雇主想要的应聘者没有实现。 应聘者雇来培训自己的人根本不管事：学生交了学费，就相当于雇老师来培训自己，可培训者根本也不了解（或不关心）他的客户们的需求。这里，学生是需求方，老师则是实现方。弄清需求的职责在后者，可后者也弄不清。 学生自己也弄不清：学生自己既是需求方（需要特定技能），也是实现方。可他们自己也弄不清需求到底是什么。 以上三点还不是最严重的，最严重的在下面： 明白需求是什么的也不知道怎么实现：怎么去培养现代IT企业真正需要的人才？特别地，实战能力怎么培养？代码素养怎么培养？协作沟通能力怎么培养？学习能力怎么培养？就算这些都知道怎么培养，又怎么给在象牙塔里头，离催命之日还遥遥无期的学生提供足够的动力呢？而学生自己就算知道该学哪些技能，又怎么知道具体怎么着手？什么是最有效率的学习方法？又如何让自己保持学习的热情？ 以上这些问题，就是当下人才培养/招聘的惨淡现状。简而言之，在雇主和学生之间，横梗着一条巨大的鸿沟，两头都很着急，两头都有动力，但就是没有方法，君住长江头妾住长江尾。像微软谷歌这样的，干脆和高校合作，直接插手本科或硕士的教育，从而保证到时有足够强的候选，某种程度上，这的确是根本解决之道，可一来这代价太大了，非一般企业承受得起，二来这影响面也太小了。 这一切，也许将在未来的5年发生根本的变化。 《Switch: How to Change Things When Change Is Hard》（中译《瞬变》）里面指出，表面上看来非常困难的改变，也许是因为根本就没有抓住要害。在书中作者通过大量案例分析和心理学研究，雄辩地指出以下几点促成改变的关键之处： 触动内心的大象：要改变的人必须要有情感层面的动力。有一些特定的方法能够比另一些方法更能对人的情感产生触动。 给出清晰、明确的目标：目标一定不能含糊，模棱两口的目标让人无所适从，导致决策瘫痪。例如最近我们组在招实习生，我在微博上发了一条招聘信息，其中提到“扎实”的系统底层知识，有同学就写信来问，怎么叫“扎实”。我傻眼了。比尔·盖茨就以目标清晰明确著称，不仅在战略制定上，“每个人桌面上都有一台PC”，而且居然还体现在招聘上——“如果你读完了TAOCP（计算机程序设计艺术），那么就给我投简历吧”。多么清晰，明确的目标啊——虽然高了点，也许这就是比尔·盖茨至今还没被应聘邮件淹没的原因:) 给前进的道路扫清障碍：人是懒惰的，只要有借口就会不想往前。如果既有明确的目标，同时道路又直直指向目标，一览无余，只等你开始往前走，那么便没有借口，一往无前。 那么让我们对照上面看看，可以做什么？ 首先，内心的大象不需要触动，中国有足够多的人足够早就开始焦虑就业的事情，只是不知道往哪使劲，这部分人如果把劲头用到正确的事情上面也许足以满足现在的IT企业人才饥渴了。至于其他人，好吧，也许身边的人开始动起来他们也会被触动。 然后是清晰、明确的目标。这一点上目前雇主们的做法可谓好坏参半，好的一点是大家都强调要有实践经验，要有团队协作精神，坏的一点就在基础知识和技能的要求方面，可谓再含糊不过了：“精通XX语言”，“扎实的XX功底”，“熟悉XX技术”，甚至看上去最具量化感的描述“X年YY经验”其实都根本说明不了多少东西，在信息量方面还不如我家门口菜市场上一家卖酥油饼的店门口挂的横幅——“三天不硬、至少六层！”。 很多朋友也许注意到一个现象，现在企业对招聘者简历的要求也在变得越来越灵活变通，例如ThoughtWorks在招聘的时候就希望招聘者能给出自己的博客地址，博客对IT行业的意义也许胜过其他所有行业，一个积累多年的技术博客比任何简历都更能说明问题。台湾的郭安定也说“为什么写技术博客对新人如此重要”。可惜这个做法也有一个弊端：并不是所有技术牛人都写博客，有人就是只干不说型的，而就算写博客，乃至动手写过一阵子的，写一个常年的博客，也远比你想象的更为困难，因为很多时候，写（说）得靠谱比做得靠谱更难。所以这个过滤器很多时候用不上。 但是这的确表明了一个思考的方向，就是寻找更具鉴别力的过滤器，Stackoverflow Careers 2.0之所以强大，是因为Joel Spolsky和Jeff Atwood这两位常年混社区的资深博主创造性地将一个人在社区的活动历史浓缩成为一系列的量化数值，由于这个历史很长期，所以鉴别力非常高。但它同样也有问题，就是对于应聘者来讲相当花费时间，而且并不是花时间（在Stackoverflow上回答问题）就一定能花到点子上。 到底什么特征才是既通用，又能够有效地鉴别高低应聘者的特征呢？这个特征必须不像博客那样难以实现，同时又必须有足够的区分度。 有的地方在要求填写简历的时候必须填上平时都访问哪些技术网站。恩，很不错的尝试，可区分度仍然还是不够，因为上网站上查东西毕竟只占现阶段大多数应届生的少数信息来源，特别是当我们看重得更多的是应届应聘者的系统性的知识基础的时候，网上的东西虽然丰富，但属于提高班，也更为琐碎，什么是更系统的知识来源呢？答案其实大家都知道—— 书。 我一向认为，很多时候，是否好好看完一本好书，对一个人的提升往往能达到质的区别。就算不好好看完一本好书，马马虎虎看完，只要书是真的好书，也肯定会有很大的提高。我在面试的时候就经常询问对方看过哪些技术书籍，经常上哪些网站，订哪些博客。这里头尤其数书籍这一项的区分度最高。此外，好书和坏书的差别，从本质上，就是学习效率和大方向的差别。一本烂书可以浪费你半年的时间，但一本好书却可以为你带来真正扎实的基础和开阔的视野。人们常常用“内功”来形容扎实的基础，认为学好了内功以后学什么都快，其实一点没错，好的“内功”书不仅讲清楚深刻的原理，而且指明技术的本质，刻画领域的地图。好的书抓住不变量，让人能够触类旁通。好的书不仅介绍知识，而且阐释原则，介绍那些万变不离其宗的东西。读烂书浪费时间，但读好书却节省时间。 象牙塔内的学生受到视野的限制，往往择书不慎，事倍功半，烂书不仅浪费时间，还会打击人的积极性，让人对知识心生恐惧，认为很难掌握，殊不知只是作者没有讲好（或者没有翻译好）。因此，为招聘头疼的公司完全可以给出“应聘俺们公司前必读的十本书”，也不一定要每个公司都不一样，在某个技术子领域有影响力的人，或者创始人们，可以来定义具有代表性的书单。 我们姑且把这个计划叫做“书单计划”，容易看到“书单计划”具备以下几个卓越的优点： 清晰、明确。完全可度量。 防伪：读没读过，随便一问便知。而正因为应聘者也知道这事不像实习经验可以忽悠，所以也不敢乱往简历上捅词。 不在乎是否“泄题”：书单完全公开的，无所谓，本来就是要你去读的。想背题？背书吧。真能背下来说明认真看了。 管你用心不用心读，只要读了，读完了，就有区别。真正的好书，你想不被吸引都难。据我观察很多人就是不知道该去读什么书。 不存在“怎么做”的障碍：所有人都知道怎么读书——一页一页读。 不需要招聘者投入精力：书单在此，就这么简单，您看着办。 评估的负担很大程度转移到了应聘者的身上：是不是认真看完了，有没有心得体会，您自己掂量。没看完别来找我们。 “书单计划”能很大程度上起到强鉴别器的作用，看了就是看了，必然能学到东西，没看就是没看。知道和不知道，区别是本质的。其实很多企业内部培训，根本上其实还不就是叫员工去看之前没看过的书或者资料嘛。最后，除了鉴别作用之外，它还是一个清晰促进的目标，是完全不花精力的培养。 当然，“书单计划”的背后是另一个悲剧的现实，如果不是因为这个现实，这个计划也完全没有必要，那就是，中国IT大学教育当中要求要学的书，和企业真正需要你去读的书相比，不是完全不够用，就是写的不够好，或者更悲剧的就是根本用不上，所以在这个大背景下出来的牛人都是自己淘书自己学的。微软高级开发测试工程师，《Windows用户态程序高效排错》作者熊力就在微博上说过：“我当年毕业的时候总结了一个公式：第一份工作的月薪=大学四年买过的技术书籍价格的总和。” 但是光有“书单计划”还不够，因为**书籍只能管基础知识这一块，一些更难以量化衡量的实战“能力”又怎么办呢？**至少目前为止，除了“练”之外好像还没有特别好的办法。可是在象牙塔里面做的项目，或大作业，真的能起到练的作用吗？前面说了，学生会知道自己最终要交差的不是雇主，而是老师，于是就以老师能够评判的标准来默认要求自己了，老师能够评判编码素养？代码风格？文档？设计？协作？甚至连著名的Joel 12条的第一条“是否用源代码管理系统”都没法通过。所以大多数时候，大作业能起到的作用近乎0。 但是如果这一切是由雇主来评判的，这个“作业”是由雇主来给出的，就完全不一样了。一想到作业是要作为简历的一部分的，能不紧张嘛。能不好好做嘛。能不学到点东西嘛？ 可是这事儿能实现吗？雇主能给学生出大作业吗？也许一两个关系好的高校可以，可是中国那么多学生呢？ 为什么不能呢？如果像书单那样，列出各个技术领域“推荐在学校期间尝试的项目”，至于动不动手做，那是学生自己的问题。做的，自然能够得到锻炼，面试的时候自然能得到更大的优势。 可问题是，面试的人又怎么来评估呢？这不又回到了没法有效评估的怪圈了吗？答案很简单，但这个答案，直到最近几年，才真正成为现实—— GitHub GitHub诞生于08年春天，第一年便产生了4万6千个公共项目，大约一年半之后用户就已经达到10万用户之巨。而到今年（2011年）九月份，GitHub已经迎来了百万级用户。Host超过两百万个项目。（截止2020年10月，Github已经有超过5600万开发者） 增长的太快了！就像Twitter一样。这样疯了一般的增长只能说明一个事实——人们等待这个产品太久了。 Social Coding。 真实的项目，真实的流程，真实的人名，一切代码review, check-in, test, build, document, 甚至讨论，计划，brianstorming，流程，一切的一切，都是项目历史的一部分，都可以像棋局那样复盘。有经验的面试者只要稍稍扫两眼一个人的GitHub历史，挑出几个check-in历史看一看，便完全能够迅速判断这个人是否满足他的要求。不再需要费劲心机地去想题目，去观察，去揣测，去花费大量的时间的同时还只能采样到几个极为有限的点。 不像象牙塔里面大作业，这里有源代码管理系统，自动化build，有check-in，有review，有分工，有合作，最重要的是——这是一个集市，一个超出象牙塔的集市，牛人相互吸引，你可以在互联网上找到和自己拥有共同兴趣的一帮人，真正做起一点事情，而不是交差，不需要受限于几十个人的一个小班级。Here Comes Everybody。 为什么我这么有信心？因为这事儿已经发生了。这个想法也完全不是我原创的。 正如很多事情一样，现在在国内发生的事情，往往是美国那头的历史。今年7月中旬，纽约一家公司的工程师老大发了一篇博客文章：Github is Your New Resume。指出一个惊人但再合理不过的事实：越来越多的IT公司在招聘的时候要求应聘者给出GitHub账号。甚至已经有人为GitHub写了根据GitHub上的历史自动生成简历的工具。 仔细想想，这是必然的趋势，没有比这个再合理的事情了，既然StackOverflow的历史能够作为简历，GitHub的历史不本该就是更好的简历吗：你想要具有实战经验，懂check-in懂review懂test和代码质量的重要性，懂交流和沟通的重要性，你本就应该在一个真实的项目当中去锻炼这些东西，而这些在目前已经完全可以办到。正如邹欣老师所说，你的工作就是最好的面试。 这件事情放在早几年，是完全没法做到的，因为我们那时候还没有GitHub。正如没有Twitter，没有微博之前，很多事情都不会成为可能一样，你有千钧之力，缺乏一个合适的支点，也没法撬动一整个社群。无组织中的组织，具有强大的杠杆效应。 这个事情里面，我唯一提出的东西就是：在目前国内这个现状下，苦闷的招聘者应该主动行动，给出一些建议项目，正如前面提到的书单计划一样，招聘者需要给出的只是引导和清晰明确的目标，剩下的事情，应聘者自然会去完成，这些项目可以是实验项目，也可以是完全能做出点卖钱的东西的项目（如果好好做的话），唯一的不可或缺的前提是，项目不能太小，单人就能完成的项目不理想，一两个月就能完成的项目不理想，最好足够大到能够锻炼到方方面面，偏大一点倒是无所谓的，因为一个尚未完成的项目完全可以作为简历。当然，可以想见的是，真到了那个时候，学生们肯定又是不会满足于仅去做那些已经有许多人做过的项目了。所以这里企业们一开始所建议的项目只是一个《Nudge》，是滚雪球之前需要的一点初始动能。后面的事情，他们自己会完成。 “GitHub计划”同样有一些明显的、甚至不可替代的优点： 清晰、明确，完全可度量。 防伪：同样不担心“泄题”。你伪造不了GitHub历史，伪造不了check-in历史，review comments，文档，交流记录… 它不但是招聘，也是不花精力的培养。善哉善哉。 评估的责任很大程度上交给了应聘者自己。 从你的GitHub旅程开始，你就已经一脚踏进了真正的企业，而企业的面试也已经开始。 书单+GitHub，就相当于一个两年左右的面试。 没有什么面试比持续两年的面试更具有信息量。 书单，加上项目，已经基本上覆盖了所需的全部技能。最妙的是，有太多的人在焦急的等待着他们未来的雇主给出明确的信号，他们想投入精力，去学习和实践，去成为企业需要的人，但是他们就是不知道往什么方向走，所谓有动力没方向。所以，雇主给出了清晰明确的要求，相信对于很多人来说反倒是一个解脱：“终于知道该干什么了”。《编程之美》为什么常居畅销榜？因为它透露了雇主眼中的需求，明确、清晰的需求，可以实现，并且知道怎么去实现的需求。 你提前两年就开始面试和培养未来的候选者，而且还不需要你花出一分精力，而且人家还很乐意，没有比这更完美的面试了。 想一想，以后那些没见过世面的公司看见你拿出GitHub账号给他看，该是多么惊讶同时又觉得多么合理。 而这一切，只是因为两个小小的改变： 由需求方（雇主）给出了清晰、明确的目标。 GitHub这样的平台。 那么，学校/老师在这个事情当中的位置呢？说实话我不知道。没有哪个行业像IT行业这样特殊：没有什么东西不能够（应该）在互联网上学到的。自组织的力量完全大过传统的教育方式。而且，既然雇主都当了领路人了，我不知道还有中间开发商什么事儿。（注：这里说的是软件开发，并非计算机科学研究，后者另当别论） 那么，这个改变会发生吗？多久会发生呢？当然，它在国外已经发生了，所以问这个问题多少有点无趣。但我还是预计很快就会在国内发生，毕竟，不是已经有人要求出示博客，和经常浏览的网站了吗？也许5年左右（4年本科和6年硕士的中间值？））就会深刻改变整个人才培养/招聘的格局。当然，我并不是预言家，所以不要把我的时间估计当真，我能肯定的是，这种方式是必然的大势所趋。 刚才我就收到一位同学邀请我上知乎回答一个问题“找工作的首要原则是什么？”，当然，这个问题的答案是：“弄清雇主的需求到底是什么”。 列一下我所认为的，你面试微软前必须要读的十本书： Code: The Hidden Language of Computer Hardware and Software （《编码的奥秘》） Computer System: A Programmer’s Perspective （《深入理解计算机系统》） / Windows via C/C++ （《Windows核心编程》 / 《程序员的自我修养》 Code Complete 2（《代码大全》）/ The Pragmatic Programmer （《程序员修炼之道》，我也把这本书称为《代码小全》） Programming Pearls （《编程珠玑》） / Algorithms / Algorithm Design / 《编程之美》 The C Programming Language The C++ Programming Language / Programming: Principles and Practice Using C++ / Accelerated C++ The Structure and Interpretation of Computer Programs （《计算机程序的构造和解释》） Clean Code / Implementation Patterns Design Patterns （《设计模式》） / Agile Software Development, Principles, Patterns, and Practices Refactoring （《重构》） （注：1. 以上同一条目下用“/”隔开的表示任选，当然你也可以都读了，相信我，时间是足够的。2. 读这些书并不意味着逐字逐句从第一页读到最后一页——当然你也可以这么做。怎么是聪明高效的读法，可以参考我之前写的关于如何阅读和查找/鉴别书籍/资料的博文） 注意：以上是我个人认为你面试微软开发职位前必须要读的10本书，它不代表我的雇主的观点。它也只是一个初步的书单，肯定会受到我个人经验和眼界的限制。欢迎大家提意见。 此外，IT不同子领域的必读书单可能千差万别，所以在发布之前我把这篇文章发给了一些朋友，他们给出了自己的书单（你是不是能看到一些有趣的共同点呢）： 云风（中国游戏编程先行者，前网易游戏部门资深程序员，简悦创始人）： 如果面试，我会挑以下的我自己读过的书，让人选择他也读过的部分，再了解他对这些书的理解。这些书其实本质上就是两类，对所面对的东西（程序语言也好，操作系统也好，底层设施也好）本身的理解程度。以及另一类：对设计思想和原则的理解： C++编程思想 Effective C++ 深度探索C++对象模型 C++语言的设计和演化 C专家编程 C陷阱与缺陷 C语言接口与实现 Lua程序设计 Linkers and Loaders COM本质论 Windows核心编程 深入解析Windows操作系统 程序员修炼之道 代码大全 UNIX编程艺术 设计模式 代码优化：有效使用内存 深入理解计算机系统 深入理解LINUX内核 TCP/IP 详解 冯大辉（丁香园CTO，贝塔咖啡创始人）： 软件随想录 黑客与画家 重来 UNIX编程艺术 编程人生 洪强宁（豆瓣技术总监）： StackOverflow上有一个程序员必读书单帖子，这里仅列出top10，更多参考这里。 Code Complete 2 The Mythical Man-Month （《人月神话》） Code: The Hidden Language of Computer Hardware and Software （《编码的奥秘》） TAOCP （不解释） The Pragmatic Programmer （《程序员修炼之道》） Design Patterns （《设计模式》） The Structure and Interpretation of Computer Programs （《计算机程序的构造和解释》） Refactoring （《重构》） The C Programming Language Introduction to Algorithms （《算法导论》） 郑昀（窝窝团研发副总裁）： 工程师入门： Code Complete 2 程序员修炼之道 深入理解计算机系统 工程师升级： 设计模式 重构——改善既有代码的设计 工程师转型： 快速软件开发——有效控制与完成进度计划 人月神话 IT项目管理那些事儿 软件随想录 最后期限 走出软件作坊 你的灯亮着吗?——发现问题的真正所在 张峥（微软亚洲研究院副院长）： Algorithms (by Sanjoy Dasgupta, Christos Papadimitriou and Umesh Vazirani) Data Structure and Algorithms The C Programming Language The Design of the UNIX Operating System Compilers （龙书） Computer Architecture: A Quantitative Approach Flow Outliers (why hard work and luck are both important) 邹欣（MSRA创新工程中心首席研发经理）： 关于创新的书籍(http://book.douban.com/doulist/1253169/): The Myths of Innovation The Innovator’s Dilemma The Innovator’s Solution Crossing the Chasm Inside Intuit 盛田昭夫 杰克·韦尔奇自传 梦断代码 Innovation 浪潮之巅 关于“精通”的一篇博客《技能的反面：魔方和模仿》： http://www.cnblogs.com/xinz/archive/2011/08/07/2129751.html 在我教的《现代软件工程》课上，除了教科书，每个学生要看另一本相关的书籍并写读书分析。这个博客有一些同学的读书报告: http://www.cnblogs.com/OMG-Team/archive/2011/10/25/2223247.html 读好书是如此的重要，因为好书往往带领你去到更好的书，更大的世界。","link":"/posts/interview-2year/"},{"title":"2020 年「计算机科学与工程学院」新生赛总结","text":"第一次作为出题人参与一场算法竞赛，感受还是很不同的。相比与参赛者，少了一些紧张刺激新鲜感，当然也少了一些自闭。 比赛在SCUT CODE上举行，总体而言这个系统做的还是挺不错的，响应迅速，功能齐全。唯一要吐槽的就是题目竟然只能添加不能删除！添加比赛需要一些玄之又玄的操作。还有Special Judge也是非常难配置，还缺少了交互功能。第一场由于没有放特别简单的签到题导致大量选手爆0，导致第二场人数锐减。。。不过第二场比赛的题目最后经过调整还是简单了许多的。下面按难度总结一下这次比赛的题目，目前题目已经全部开放了，可以在题库中找到提交。 第一场比赛链接 第二场比赛链接 所有相关题目的题库链接： 658. 垃圾邮件 661. 一个小游戏 662. Overload 663. 乒乓球 664. 超人高中生的基建计划 665. 灰之魔女的旅行 666. 艾尔奇亚的国王 667. umi炒饭 668. Dirichlet卷积 669. 1-2 心与心之间的距离，永不点亮的音乐会 670. 序列构造 671. 爆炸就是艺术 672. Tree 673. 猪灵的胜利之舞 674. Merge Stone 675. 学园都市的神秘代码 676. 世界棋盘 677. 谜拟Q plus 678. 射击训练 679. 小斯巴达们的历练 680. 主人和雷姆拉姆的秘密 682. 爆炸就是艺术2 683. 乒乓球2 射击训练# 题意：统计有多少个点在圆内。 利用距离公式计算即可，浮点数可以直接输出。 C++ Python 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;double sqr(double x) { return x * x;}int main() { int a, b, r, n, cnt = 0; cin &gt;&gt; a &gt;&gt; b &gt;&gt; r &gt;&gt; n; for (int i = 0; i &lt; n; i++) { double x, y; cin &gt;&gt; x &gt;&gt; y; if (sqr(x-a)+sqr(y-b) &lt;= sqr(r)) cnt++; } cout &lt;&lt; double(cnt)/n &lt;&lt; '\\n';}1234567a, b, r = map(int, input().split())n = int(input())cnt = 0for _ in range(n): x, y = map(float, input().split()) if (x-a)**2+(y-b)**2&lt;=r*r: cnt += 1print(cnt/n) Overload# 题意：一颗以1为根的树，给定每个节点到父亲节点的距离，求到根节点的最大距离。 用dfs或bfs将树遍历一遍即可，也可以用带权并查集计算。 C++ (DFS) C++ (BFS) 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;int main() { int n, fa; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; G(n+1); vector&lt;int&gt; d(n+1); for (int i = 2; i &lt;= n; i++) { cin &gt;&gt; fa &gt;&gt; d[i]; G[fa].push_back(i); } function&lt;void(int)&gt; dfs=[&amp;](int u) { for (auto v : G[u]) { d[v] += d[u]; dfs(v); } }; dfs(1); cout &lt;&lt; *max_element(d.begin(), d.end()) &lt;&lt; '\\n'; return 0;}123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;int main() { int n, fa; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; G(n+1); vector&lt;int&gt; d(n+1); for (int i = 2; i &lt;= n; i++) { cin &gt;&gt; fa &gt;&gt; d[i]; G[fa].push_back(i); } queue&lt;int&gt; Q; Q.push(1); while (!Q.empty()) { int u = Q.front(); Q.pop(); for (auto v : G[u]) { d[v] += d[u]; Q.push(v); } } cout &lt;&lt; *max_element(d.begin(), d.end()) &lt;&lt; '\\n'; return 0;} 乒乓球# 乒乓球# 此题未加入比赛，乒乓球2为本题的简化版本。 题意：求$\\prod\\frac{p_i}{100} \\mod 1000000007$。 在模意义下求值，利用费马小定理与快速幂算法计算。 C++ Python 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll M = 1e9 + 7;ll qpow(ll x, ll y) { ll ans = 1; while (y) { if (y &amp; 1) ans = ans * x % M; x = x * x % M; y &gt;&gt;= 1; } return ans;}int main() { int n; cin &gt;&gt; n; ll ans = 1; for (int i = 1; i &lt;= n; i++) { ll x; cin &gt;&gt; x; ans = ans * x % M; } cout &lt;&lt; ans*qpow(100, n*(M-2))%M &lt;&lt; '\\n'; return 0;}12345from functools import reducen, m = int(input()), 10**9+7a = list(map(int, input().split(' ')))x = reduce((lambda x,y:x*y%m), a)print(x*pow(100,n*(m-2),m)%m) python自带的pow（注意不是math.pow）第三个参数可以传mod，复杂度为快速幂复杂度。 乒乓球2# 题意就是输出一列数的最小值和最大值。 这应该是整场比赛中最简单的题目了，只要能熟练掌握一种编程语言（C/C++/Java/Python）都应该能写出这题。 具体实现细节可以参考代码。 C++ Python Java 1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main() { int n, Min = 100001, Max = 0; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { int x; cin &gt;&gt; x; if (x &gt; Max) Max = x; if (x &lt; Min) Min = x; } cout &lt;&lt; Min &lt;&lt; ' ' &lt;&lt; Max &lt;&lt; '\\n'; return 0;}123input()a = list(map(int, input().split()))print(min(a), max(a))注：在算法竞赛中Java通常要使用优化的读入方法，但为了简单起见，这里直接用Scanner类读入。 1234567891011121314import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(), min = 100001, max = 0; for (int i = 0; i &lt; n; i++) { int x = sc.nextInt(); if (x &gt; max) max = x; if (x &lt; min) min = x; } System.out.printf(&quot;%d %d\\n&quot;, min, max); sc.close(); }} 从比赛中提交的代码来看，没有通过此题大多数情况是由于没有初始化变量。 学园都市的神秘代码# 题意：简化下面的代码。 点击展开代码 >folded12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;const int mod = 998244353;int main() { int ans = 0; long long n; cin &gt;&gt; n; for (long long i = 1; i &lt;= n; ++i) { for (long long j = 1; j &lt;= n / i; ++j) { for (long long k = 1; k &lt;= j; ++k) { long long temp = k; while (!(j % temp == 0 &amp;&amp; k % temp == 0)) { temp--; } if (temp == 1) { ans = (ans + 1) % mod; } } } } cout &lt;&lt; ans &lt;&lt; endl;} 做出这题不难，只需要把题目中的代码输入到电脑中，运行找找规律就能发现答案是n×(n+1)/2。 小技巧：在模意义下除2不用求逆元，可以转换成$(mod+1)/2$。 常见出错原因：n%mod*(n+1)%mod导致溢出！ C++ Python 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;using ll=long long;const ll mod = 998244353;int main() { int T; cin &gt;&gt; T; while (T--) { ll n; cin &gt;&gt; n; n %= mod; cout &lt;&lt; n*(n+1)%mod*((mod+1)/2)%mod &lt;&lt; endl; } return 0;}123for _ in range(int(input())): n = int(input()) print(n*(n+1)//2%998244353) 一个小游戏# 题意：一个n×m的01矩阵，每次可以选择以（1，1）为左上角，（x，y）为右下角的矩形翻转，（x，y）必须为1。L先手M后手，无法翻转的人输。 可以发现，每一步无论如何选择，（1，1）是必定要被翻转的。最终局面全0为必败态，反推可知（1，1）处为1是必胜态，为0是必败态。 C++ Python 1234567#include &lt;bits/stdc++.h&gt;using namespace std;int main() { int x; cin &gt;&gt; x &gt;&gt; x &gt;&gt; x; cout &lt;&lt; (x ? &quot;Laurent&quot; : &quot;Makoto&quot;) &lt;&lt; endl;}12input()print('Laurent' if input().split(' ')[0] == '1' else 'Makoto') 垃圾邮件# 题意：给一个长度为n的字符串s，有q次询问。每次临时将下标p的字符改为c，比较区间$[L_1, R_1]$和$[L_2, R_2]$的子串是否相同。 此题数据较弱，导致有一些假做法。 C++（字符串哈希） C++（string） 期望的做法是使用字符串哈希，每次询问可以做到O(1)。 $hs[n]$表示字符串$s[1…n]$的哈希值，$bn[n]$表示$base^n$，均采用unsigned long long自然溢出。 子串$s[l…r]$的哈希值为$hs[r]-hs[l-1]\\times bn[r-l+1]$。 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;const int base = 131;typedef unsigned long long ull;ull tr(char c) { return c-'a'+1; }int main(){ ios::sync_with_stdio(false), cin.tie(0); int n, q; cin &gt;&gt; n &gt;&gt; q; string s; cin &gt;&gt; s; vector&lt;ull&gt; hs(n+1), bn(n+1); bn[0] = 1; for (int i = 1; i &lt;= n; i++) { bn[i] = bn[i-1]*base; hs[i] = hs[i-1]*base+tr(s[i-1]); } while (q--) { int l1, r1, l2, r2, p; char c; cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2 &gt;&gt; p &gt;&gt; c; ull h1 = hs[r1]-hs[l1-1]*bn[r1-l1+1]; ull h2 = hs[r2]-hs[l2-1]*bn[r2-l2+1]; if (l1 &lt;= p &amp;&amp; p &lt;= r1) h1 += (tr(c)-tr(s[p-1])) * bn[r1-p]; if (l2 &lt;= p &amp;&amp; p &lt;= r2) h2 += (tr(c)-tr(s[p-1])) * bn[r2-p]; cout &lt;&lt; (h1 == h2 ? &quot;yes&quot; : &quot;no&quot;) &lt;&lt; '\\n'; } return 0;}1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ ios::sync_with_stdio(false), cin.tie(0); int n, q; cin &gt;&gt; n &gt;&gt; q; string s; cin &gt;&gt; s; while (q--) { int l1, r1, l2, r2, p; char c; cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2 &gt;&gt; p &gt;&gt; c; swap(c, s[p-1]); if (s.substr(l1-1, r1-l1+1)==s.substr(l2-1, r2-l2+1)) cout &lt;&lt; &quot;yes\\n&quot;; else cout &lt;&lt; &quot;no\\n&quot;; swap(c, s[p-1]); } return 0;} 超人高中生的基建计划# 题意：n个点，i、j边权为i|j(i位或j），求最小生成树。 分析：显然边权不可能小于本身点的编号。对于奇数点，与1连最划算，边权为本身。剩下的点中除了$(10000)_2$这种的，都可以做到边权为本身。用log2统计这类点的数量。 答案就是$\\frac{n\\times (n+1)}{2}-1+\\lfloor\\log_2n\\rfloor$ C++ Python 12345678#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ long long n; cin &gt;&gt; n; cout &lt;&lt; n*(n+1)/2-1+(int)log2(n) &lt;&lt; '\\n'; return 0;}123from math import log2n = int(input())print(n*(n+1)//2-1+int(log2(n))) 灰之魔女的旅行# 题意：一颗以1为根的树，每次可以选则一个未访问的点，访问该点及其子节点。先选择1节点，问最多能选择几次。 本题输入数据量较大，可以使用ios::sync_with_stdio(false), cin.tie(0);关闭流同步以加速cin输入。或者使用scanf/getchar/fread等方法。 树形DP 自底向上贪心 树形DP入门题，类似题目：P1352 没有上司的舞会。 设$f[i][0]$表示不选择节点$i$的最大答案，$f[i][1]$表示选择节点$i$的最大答案。 转移：$f[i][0]=\\sum max(f[i.son][1], f[i.son][0])$ $f[i][1]=\\sum f[i.son][0]$ 初始值$f[i][1]=1$，答案为$f[1][1]$。 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false), cin.tie(0); int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; G(n+1); for (int i = 1; i &lt; n; i++) { int u, v; cin &gt;&gt; u &gt;&gt; v; G[u].push_back(v), G[v].push_back(u); } vector&lt;array&lt;int, 2&gt;&gt; f(n+1); function&lt;void(int, int)&gt; dfs=[&amp;](int u, int p) { f[u][1] = 1; for (auto v : G[u]) { if (v == p) continue; dfs(v, u); f[u][0] += max(f[v][0], f[v][1]); f[u][1] += f[v][0]; } }; dfs(1, 0); cout &lt;&lt; f[1][1] &lt;&lt; '\\n'; return 0;}由于输入保证为一棵树，即有子节点数目大于等于父节点数目，因此从叶子节点往上贪心选择可以保证最优。 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ ios::sync_with_stdio(false), cin.tie(0); int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; G(n+1); for (int i = 1; i &lt; n; i++) { int u, v; cin &gt;&gt; u &gt;&gt; v; G[u].push_back(v); G[v].push_back(u); } vector&lt;bool&gt; vis(n+1); int ans = 1; vis[1] = true; for (auto v : G[1]) vis[v] = true; function&lt;void(int, int)&gt; dfs=[&amp;](int u, int fa) { for (auto v : G[u]) if (v != fa) dfs(v, u); if (!vis[u]) vis[u] = vis[fa] = true, ans++; }; dfs(1, 0); cout &lt;&lt; ans &lt;&lt; '\\n'; return 0;} merge stone# 分析：【多叉哈夫曼树】【贪心】 参考代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt; //pb_ds库#define LL long long using namespace std;struct node{ LL w,h; node(LL W, LL H){ w=W,h=H; }};bool operator&lt;(node a, node b){ if(a.w!=b.w) return a.w&gt;b.w; return a.h&gt;b.h; //如果长度相等，高度小的优先} //构造小根堆的操作。__gnu_pbds::priority_queue &lt;node, std::less&lt;node&gt;, __gnu_pbds::pairing_heap_tag&gt; q; //优先队列int n,k,cnt;LL temp,maxh,ans;int main(){ scanf(&quot;%d&quot;,&amp;n); k = 3; for(int i=1; i&lt;=n; i++){ scanf(&quot;%lld&quot;,&amp;temp); q.push(node(temp,1)); } if((n-1)%(k-1) != 0) cnt=k-1-(n-1)%(k-1); //判断是否要补空节点 for (int i=1; i&lt;=cnt; i++) q.push(node(0,1)); //补空节点 cnt+=n; //cnt为根节点个数(最初每个根节点都为其本身） while(cnt&gt;1){ temp=maxh=0; for(int i=1; i&lt;=k; i++){ temp+=q.top().w; maxh=max(maxh,q.top().h); q.pop(); } ans+=temp; //维护带权路径长度之和 q.push(node(temp, maxh+1)); //合并，高度为最高子树高度+1 cnt-=k-1; //减少根节点 } printf(&quot;%lld\\n\\n&quot;,ans); return 0; 心与心之间的距离，永不点亮的音乐会# 此题因为数据原因未加入正赛，放在了热身赛。 题意：问两颗二叉搜索树上是否存在两个和为x的值。（分别位于两棵树上） 分析：【双指针】期望复杂度O(n)，然而用set就可以过。。 参考代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#pragma comment(linker, “/STACK:1024000000,1024000000”)#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define S 100000char bf[S], *p1 = bf, *p2 = bf;#define nc() (p1==p2&amp;&amp;(p2=(p1=bf)+fread(bf,1,S,stdin),p2==p1)?-1:*p1++)inline ll read() { ll x = 0, f = 1; char ch = nc(); for (; (ch &lt; '0' || ch &gt; '9') &amp;&amp; (ch != '-'); ch = nc()); if (ch == '-')ch = nc(), f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; x = x * 10 + ch - 48, ch = nc()); return f * x;}#define N 500050int t[N][2], n, m, tot;ll val[N], a[N], b[N];void dfs(int x) { if (t[x][0] &gt; 0)dfs(t[x][0]); a[++tot] = x; if (t[x][1] &gt; 0)dfs(t[x][1]);}void dfs2(int x) { if (t[x][0] &gt; 0)dfs2(t[x][0]); b[++tot] = x; if (t[x][1] &gt; 0)dfs2(t[x][1]);}inline void solve() { int flag = 0; n = read(), m = read(); ll x = read(); for (int i = 1; i &lt;= n; ++i) { val[i] = read(); t[i][0] = read(), t[i][1] = read(); } tot = 0, dfs(1); for (int i = 1; i &lt;= n; ++i)a[i] = val[a[i]]; for (int i = 1; i &lt;= m; ++i) { val[i] = read(); t[i][0] = read(), t[i][1] = read(); } tot = 0, dfs2(1); for (int i = 1; i &lt;= m; ++i)b[i] = val[b[i]]; int l = 1, r = m; while (l &lt;= n &amp;&amp; r &gt;= 1) { while (a[l] + b[r] &gt; x &amp;&amp; r &gt;= 1)--r; if (a[l] + b[r] == x &amp;&amp; r &gt;= 1) { flag = 1; break; } ++l; } puts(flag ? &quot;yes&quot; : &quot;no&quot;);}int main() { // freopen(&quot;./data/10.in&quot;, &quot;r&quot;, stdin); int T = 1; scanf(&quot;%d&quot;, &amp;T); while (T--)solve();} convolution# 【Dirichlet卷积】 参考代码： 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int M = 1e9 + 7;ll qpow(ll x, ll y) { ll ans = 1; while (y) { if (y &amp; 1) ans = ans * x % M; x = x * x % M; y &gt;&gt;= 1; } return ans;}int main() { ios::sync_with_stdio(false), cin.tie(0); // freopen(&quot;data.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;data.out&quot;, &quot;w&quot;, stdout); int t; cin &gt;&gt; t; while (t--) { int m; cin &gt;&gt; m; ll ans = 1; for (int i = 1; i &lt;= m; i++) { ll p, q; cin &gt;&gt; p &gt;&gt; q; ans = ans * ((p + p * q % M - q + M) % M * qpow(p, q - 1) % M) % M; } cout &lt;&lt; ans &lt;&lt; '\\n'; } return 0;} 小斯巴达们的历练# 分析： 【最短路】【Dijkstra算法】 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;#define maxn 201000 struct qnode{ int x;LL c; qnode(int _x=0,int _c=0):x(_x),c(_c){} bool operator &lt; (const qnode &amp;y) const { return c&gt;y.c; }};priority_queue&lt;qnode&gt; q;struct node{ int y,nt;LL c;}a[maxn*2];int len,first[maxn];void ins(int x,int y,LL c){ len++;a[len].y=y;a[len].c=c; a[len].nt=first[x];first[x]=len;}LL d[4][maxn];int c[maxn];bool vis[maxn];LL mymin(LL x,LL y){return (x&lt;y)?x:y;}void dfs(int S,int tt){ memset(d[tt],-1,sizeof(d[tt])); memset(vis,false,sizeof(vis)); d[tt][S]=0; while (!q.empty()) q.pop(); q.push(qnode(S,0)); vis[S]=true; while (!q.empty()) { qnode now = q.top(); q.pop(); int x=now.x; for (int k=first[x];k!=-1;k=a[k].nt) { int y=a[k].y; if (d[tt][y]==-1 || d[tt][y]&gt;=d[tt][x]+a[k].c) { d[tt][y]=d[tt][x]+a[k].c; if (tt&gt;0 &amp;&amp; c[y]&lt;3) continue; if (!vis[y]) { q.push(qnode(y,d[tt][y])); vis[y]=true; } } } vis[x]=false; }}queue&lt;int&gt; qans;int main(){ //freopen(&quot;01.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;01.out&quot;,&quot;w&quot;,stdout); int n,m,i,t,x,y,s[4];LL ans,z; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); t=-1; for (i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;c[i]); if (c[i]==1) t=i; } len=0;memset(first,-1,sizeof(first)); for (i=1;i&lt;=m;i++) { scanf(&quot;%d%d%lld&quot;,&amp;x,&amp;y,&amp;z); ins(x,y,z);ins(y,x,z); } for (i=1;i&lt;=3;i++) scanf(&quot;%d&quot;,&amp;s[i]); for (i=1;i&lt;=3;i++) { dfs(s[i],i); /*for (int j=1;j&lt;=n;j++) printf(&quot;%d &quot;,d[i][j]); printf(&quot;\\n&quot;);*/ } dfs(t,0); /*for (int j=1;j&lt;=n;j++) printf(&quot;%d &quot;,d[0][j]); printf(&quot;\\n&quot;);*/ ans=-1; while (!qans.empty()) qans.pop(); for (i=1;i&lt;=n;i++) { if (d[0][i]==-1 || d[1][i]==-1 || d[2][i]==-1 || d[3][i]==-1) continue; if (ans==-1 || ans&gt;d[0][i]+d[1][i]+d[2][i]+d[3][i]) { ans=d[0][i]+d[1][i]+d[2][i]+d[3][i]; while (!qans.empty()) qans.pop(); qans.push(i); } else if (ans==d[0][i]+d[1][i]+d[2][i]+d[3][i]) qans.push(i); //printf(&quot;%d %d\\n&quot;,i,ans); } printf(&quot;%lld\\n&quot;,ans); //while (!qans.empty()) {printf(&quot;%d &quot;,qans.front());qans.pop();} return 0;}/*5 63 3 3 3 11 4 21 5 12 4 42 5 33 4 14 5 21 2 35 53 3 3 2 11 5 12 4 42 5 33 4 14 5 21 2 36 113 1 3 2 3 31 2 31 3 11 4 21 5 42 3 42 4 12 6 43 4 24 5 34 6 35 6 13 5 6*/ 序列构造# 题意：构造一个长度为 n 的整数序列，使得该序列的和与积相等，且恰好等于 n。 构造法# 参考证明：每日一题【1050】和积相等 情形一 n=4k+1 时，可以分成 2k 个 −1，2k 个 1，1 个 4k+1． 情形二 n=8k 时，可以分成 2k 个 −1，6k−2 个 1，1 个 2，1 个 4k． 情形三 n=8k+12 时，可以分成 2k+1 个 −1，6k+9 个 1，1 个 −2，1 个 4k+6． 情形四 n=4 时，|ai|∈{1,2,4}，其中 i=1,2,3,4，且只有可能取 1 个 4 或 2 个 2，容易验证都不可行． 情形五 n=4k+2 时，由于a1⋅a2⋯an≡2(mod4),于是 a1,a2,⋯,an 为 1 个偶数和 4k+1 个奇数，它们的和为奇数，矛盾． 情形六 n=4k+3 时，a1,a2,⋯,an 为 4k+3 个奇数，设其中模 4 余 1 的有 m 个，模 4 余 3 的有 4k+3−m 个，因此a1+a2+⋯+an≡m−(4k+3−m)≡2m+1≡3(mod4),于是 m 为奇数，进而a1⋅a2⋯an≡$1^m⋅(−1)^{4k+3−m}$≡1(mod4),矛盾． 综上所述，所有具有性质 Q 的正整数构成的集合为{x∣x≡0,1,4,5(mod8),x≠4,x∈N∗}. C++ Python 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;void print(int t, int x) { while (t--) cout &lt;&lt; x &lt;&lt; ' ';}int main() { int n; cin &gt;&gt; n; int nm = n % 8; if (n == 4||nm==2||nm==3||nm==6||nm==7) { cout &lt;&lt; &quot;no\\n&quot;; return 0; } cout &lt;&lt; &quot;yes\\n&quot;; if (n % 4 == 1) { int k = n / 4; print(2*k, -1); print(2*k, 1); print(1, 4*k+1); } else if (n % 8 == 0) { int k = n / 8; print(2*k, -1); print(6*k-2, 1); print(1, 2); print(1, 4*k); } else if (n % 8 == 4) { int k = (n-12)/8; print(2*k+1, -1); print(6*k+9, 1); print(1, -2); print(1, 4*k+6); } cout &lt;&lt; '\\n'; return 0;}12345678910111213141516171819n = int(input())if n == 4 or n%8 in [2,3,6,7]: print('no')else: print('yes') if n % 4 == 1: k = n // 4 print('1 -1 '*(2*k), end='') print(4*k+1) elif n % 8 == 0: k = n // 8 print('1 '*(6*k-2), end='') print('-1 '*(2*k), end='') print(2, 4*k) elif n % 8 == 4: k = (n-12)//8 print('1 '*(6*k+9), end='') print('-1 '*(2*k+1), end='') print(-2, 4*k+6) 搜索法# 由$\\lfloor\\log_210^5\\rfloor=16$可知，序列中最多有16个绝对值大于1的数，剩下的数用1或-1填充。 于是可以考虑搜索，dfs(num, target)尝试用target个大于1的数构造一个乘积为num的序列，满足乘积后check检查是否能通过填充1或-1来满足和也为n。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;int n, cnt, yinshu[maxn];bool found;void check() { int sum = 0; for (int i = 1; i &lt;= cnt; i++) sum += yinshu[i]; int need = n - sum; int remain = n - cnt; if (remain &gt;= need &amp;&amp; ((remain - need) % 4) == 0) { found = 1; cout &lt;&lt; &quot;yes\\n&quot;; int xx = (remain - need) / 4; for (int i = 1; i &lt;= xx; i++) cout &lt;&lt; &quot;-1 -1 1 1 &quot;; for (int i = 1; i &lt;= need; i++) cout &lt;&lt; &quot;1 &quot;; for (int i = 1; i &lt; cnt; i++) cout &lt;&lt; yinshu[i] &lt;&lt; ' '; cout &lt;&lt; yinshu[cnt] &lt;&lt; '\\n'; }}void dfs(int num, int target) { if (found) return; if (cnt == target - 1) { yinshu[++cnt] = num; check(); if (!found) cnt--; return; } for (int x = 2; x * x &lt;= num; x++) { if (num % x) continue; int y = num / x; yinshu[++cnt] = x; dfs(y, target); if (found) return; else cnt--; }}int main() { cin &gt;&gt; n; found = 0; for (int i = 1; i &lt;= 16; i++) { cnt = 0; dfs(n, i); if (found) break; } if (found == 0) cout &lt;&lt; &quot;no\\n&quot;;} 爆炸就是艺术# 爆炸就是艺术2# 题意：给n个TNT的坐标，一个TNT可以引爆上下左右以及本身位置的TNT。点燃代价为到原点距离，求最小代价。 判断点是否存在可以用map/set/hash，找连通块可以用bfs/dfs/dsu，做法非常多。注意实现细节，有重复的点。 map+dsu 数据生成器 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;void solve() { int n; cin &gt;&gt; n; vector&lt;pair&lt;int, int&gt;&gt; p(n); map&lt;pair&lt;int, int&gt;, int&gt; st; vector&lt;long long&gt; w(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; p[i].first &gt;&gt; p[i].second; st[p[i]] = i; w[i] = 1ll*p[i].first*p[i].first+1ll*p[i].second*p[i].second; } vector&lt;int&gt; f(n); for (int i = 0; i &lt; n; i++) f[i] = i; function&lt;int(int)&gt; Find = [&amp;](int x) { return x == f[x] ? x : f[x] = Find(f[x]); }; for (int i = 0; i &lt; n; i++) { int dx[]{0, -1, 1, 0, 0}, dy[]{0, 0, 0, -1, 1}; for (int j = 0; j &lt; 5; j++) { auto pos = st.find({p[i].first+dx[j], p[i].second+dy[j]}); if (pos == st.end()) continue; int a = Find(pos-&gt;second), b = Find(i); if (a != b) { f[a] = b; w[b] = min(w[b], w[a]); } } } long long ans = 0; for (int i = 0; i &lt; n; i++) if (i == Find(i)) ans += (long long)sqrt(w[i]); cout &lt;&lt; ans &lt;&lt; endl;}int main() { int T; cin &gt;&gt; T; while (T--) solve(); return 0;}123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &quot;testlib.h&quot;#include &lt;iostream&gt;using namespace std;int testIndex = 0;void nextTest() { testIndex++; freopen((&quot;data/&quot;+to_string(testIndex)+&quot;.in&quot;).c_str(), &quot;w&quot;, stdout);}void randTest(int mint=1, int maxt=10, int minn=1, int maxn=1e5, int minx=-1e9, int maxx=1e9, int miny=-1e9, int maxy=1e9) { nextTest(); int T = rnd.next(mint, maxt); cout &lt;&lt; T &lt;&lt; endl; while (T--) { int n = rnd.next(minn, maxn); cout &lt;&lt; n &lt;&lt; endl; while (n--) { cout &lt;&lt; rnd.next(minx, maxx) &lt;&lt; ' ' &lt;&lt; rnd.next(miny, maxy) &lt;&lt; endl; } }}int main(int argc, char* argv[]) { registerGen(argc, argv, 1); nextTest(); cout &lt;&lt; 1 &lt;&lt; endl; cout &lt;&lt; 3 &lt;&lt; endl; cout &lt;&lt; 0 &lt;&lt; ' ' &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; 1 &lt;&lt; ' ' &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; 0 &lt;&lt; ' ' &lt;&lt; 8 &lt;&lt; endl; nextTest(); cout &lt;&lt; 2 &lt;&lt; endl; cout &lt;&lt; 1 &lt;&lt; endl; cout &lt;&lt; 0 &lt;&lt; ' ' &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; 1 &lt;&lt; endl; cout &lt;&lt; (int)1e9 &lt;&lt; ' ' &lt;&lt; (int)1e9 &lt;&lt; endl; randTest(1, 1, 1, 1e2, 1, 1e4, 1, 1e4); randTest(1, 10, 1, 1e4, -1e5, 1e5, -1e5, 1e5); randTest(10, 10, 1, 1e4, -1e5, 1e5, -1e5, 1e5); randTest(); randTest(); randTest(10, 10, 1e5, 1e5, -10, 10, -1e9, 1e9); randTest(10, 10, 1e5, 1e5, -1e9, 1e9, -10, 10); randTest(10, 10, 1e5, 1e5, -10, 10, -10, 10); randTest(10, 10, 1e5, 1e5, 1e9, 1e9, -1e9, -1e9); return 0;} 爆炸就是艺术# 此题未加入比赛，爆炸就是艺术2为本题的简化版本。 题意：给出平面上n个点的坐标，点i爆炸的代价为i到原点的距离（向下取整），点i爆炸会同时让与点i距离小于等于7的点爆炸。问爆炸所有点的最小代价。 分析：类似平面最近点对的方法建图。然后用并查集缩点。 对每个点扫描半径7以内的其他点的做法容易被卡。（虽然已经开到3s了） 建图具体做法参考：平面最近点对——非分治算法 最近点对建图+dsu fread+hash+dsu 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;const int K = 7;typedef long long ll;struct Point { int x, y, i; Point(int x = 0, int y = 0, int i = 0) : x(x), y(y), i(i) {} bool operator&lt;(const Point &amp;o) const { return x &lt; o.x || (x == o.x &amp;&amp; y &lt; o.y); } bool operator==(const Point &amp;o) const { return x == o.x &amp;&amp; y == o.y &amp;&amp; i == o.i; }};struct cmpy { bool operator()(const Point &amp;a, const Point &amp;b) const { return a.y &lt; b.y; }};ll dis2(const Point &amp;a, const Point &amp;b) { return (ll)(a.x - b.x) * (a.x - b.x) + (ll)(a.y - b.y) * (a.y - b.y);}void solve() { int n; cin &gt;&gt; n; vector&lt;Point&gt; p(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; p[i].x &gt;&gt; p[i].y; } sort(p.begin(), p.end()); p.erase(unique(p.begin(), p.end()), p.end()); n = (int)p.size(); for (int i = 0; i &lt; n; i++) p[i].i = i; multiset&lt;Point, cmpy&gt; s; vector&lt;int&gt; par(n); vector&lt;ll&gt; w(n); for (int i = 0; i &lt; n; i++) w[i] = (ll)p[i].x * p[i].x + (ll)p[i].y * p[i].y; for (int i = 0; i &lt; n; i++) par[i] = i; function&lt;int(int)&gt; Find = [&amp;](int x) { return x == par[x] ? x : par[x] = Find(par[x]); }; for (int i = 0, l = 0; i &lt; n; i++) { while (l &lt; i &amp;&amp; p[i].x - p[l].x &gt; K) s.erase(s.find(p[l++])); auto lowy = s.lower_bound(Point(p[i].x, p[i].y - K)); for (auto it = lowy; it != s.end() &amp;&amp; it-&gt;y - p[i].y &lt;= K; it++) { if (dis2(*it, p[i]) &lt;= K * K) { int u = p[i].i, v = it-&gt;i; int fu = Find(u), fv = Find(v); if (fu != fv) { w[fv] = min(w[fv], w[fu]); par[fu] = fv; } } } s.insert(p[i]); } ll ans = 0; for (int i = 0; i &lt; n; i++) if (Find(i) == i) ans += (ll)sqrt(w[i]); cout &lt;&lt; ans &lt;&lt; '\\n';}int main() { ios::sync_with_stdio(false), cin.tie(0); int T; cin &gt;&gt; T; while (T--) solve(); return 0;}123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;struct In { static const int N = 5e7; char s[N], *p; size_t c; In() { c = fread(s, 1, N, stdin), p = s; }} in;template &lt;typename T&gt;In&amp; operator&gt;&gt;(In &amp;i, T &amp;x) { char *&amp;p = i.p; while (*p != '-' &amp;&amp; (*p &lt; '0' || *p &gt; '9')) p++; if (p == i.s + i.c) return i; bool sgn = false; if (*p == '-') sgn = true, p++; for (x = 0; *p &gt;= '0' &amp;&amp; *p &lt;= '9'; p++) x = x * 10 + *p - '0'; if (sgn) x = -x; return i;}struct hash_tables { static const int sz = 1000037; int head[sz], nxt[sz], mark, tmmark[sz], key2[sz], len; ll key[sz]; void clear() { len = 0; mark++; } void add(ll s, int v) { int val = s % sz; if (val &lt; 0) val += sz; if (tmmark[val] != mark) tmmark[val] = mark, head[val] = -1; nxt[len] = head[val], head[val] = len, key[len] = s, key2[len] = v; len++; } int count(ll s) { int val = s % sz; if(val &lt; 0) val += sz; if(tmmark[val] != mark) return 0; for(int j = head[val]; j != -1; j = nxt[j]) if(key[j] == s) return key2[j]; return 0; }}g;const int maxn = 100005;int par[maxn], x[maxn], y[maxn]; ll w[maxn];int find(int x) {return x==par[x]?x:par[x]=find(par[x]);}vector&lt;pair&lt;int,int&gt;&gt; v;int main() { g.clear(); for(int dx=-7;dx&lt;=7;++dx) { for(int dy=0;dy&lt;=7;++dy) { if(dx*dx+dy*dy&lt;=49) v.push_back({dx,dy}); } } int t; in &gt;&gt; t; while(t--) { int n; in &gt;&gt; n; for(int i=1;i&lt;=n;++i) par[i]=i; for(int i=1;i&lt;=n;++i) { in &gt;&gt; x[i] &gt;&gt; y[i]; g.add(y[i]^((ll)x[i]&lt;&lt;32), i); w[i]=1ll*x[i]*x[i]+1ll*y[i]*y[i]; } for(int i=1;i&lt;=n;++i) { for(auto &amp;p:v) { int xx=x[i]+p.first,yy=y[i]+p.second; ull id = yy^((ll)xx&lt;&lt;32); int tmp = 0; if((tmp=g.count(id))) { int a=find(tmp),b=find(i); if(a!=b) par[a]=b, w[b]=min(w[b],w[a]); } } } ll ans=0; for(int i=1;i&lt;=n;++i) if(i==find(i)) ans+=(ll)sqrt(w[i]); cout &lt;&lt; ans &lt;&lt; '\\n'; g.clear(); }} tree# 【树形dp】 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4 + 1;typedef long long ll;int ca[maxn], dis[2][3][maxn], son[2][2][maxn]; // ca[i] = 0 代表i节点属于A类，ca[i] = 1代表i节点属于B类 // dis[i][j][k] // i: 0, 1 分别代表A和B // j: 0, 1, 2 分别代表最远距离和次远距离，以及不经过以k为根节点的子树，但经过其父节点的最长路径// k: 代表当前节点的编号// dis[0][0][k] 代表节点k到其子树中最远的A类节点的距离// dis[1][1][k] 代表节点k到其子树中次远的B类节点的距离// son[1][0][k] 代表节点k到其子树中最远的B类节点的路上经过的儿子struct node{ int v, w;};vector&lt;node&gt; e[maxn];void init(int n){ for(int i = 0; i &lt;= n; i++){ ca[i] = 0; e[i].clear(); dis[0][0][i] = dis[0][1][i] = dis[1][0][i] = dis[1][1][i] = 0; dis[0][2][i] = dis[1][2][i] = 0; son[0][0][i] = son[0][1][i] = son[1][0][i] = son[1][1][i] = 0; }}void get_ca(int val, int num){ int index; for(int i = 1; i &lt;= num; i++) { cin &gt;&gt; index; ca[index] = val; }}void add_edge(int u, int v, int w){ e[u].push_back({v, w}); e[v].push_back({u, w});}void dfs1(int u, int fa){ for(auto i: e[u]){ int v = i.v, w = i.w, tmp_son, d; if(v == fa) continue; dfs1(v, u); //A类 tmp_son = v; if(dis[0][0][v] == 0) d = (ca[v] == 0) * w; else d = dis[0][0][v] + w; if(d &gt; dis[0][0][u]){ swap(d, dis[0][0][u]); swap(tmp_son, son[0][0][u]); } if(d &gt; dis[0][1][u]){ swap(d, dis[0][1][u]); swap(tmp_son, son[0][1][u]); } //B类 tmp_son = v; if(dis[1][0][v] == 0) d = (ca[v] == 1) * w; else d = dis[1][0][v] + w; if(d &gt; dis[1][0][u]){ swap(d, dis[1][0][u]); swap(tmp_son, son[1][0][u]); } if(d &gt; dis[1][1][u]){ swap(d, dis[1][1][u]); swap(tmp_son, son[1][1][u]); } }}void dfs2(int u, int fa){ for(auto i: e[u]){ int v = i.v, w = i.w; if(v == fa) continue; //A类 if(v == son[0][0][u]) dis[0][2][v] = max(dis[0][1][u], dis[0][2][u]) + w; else dis[0][2][v] = max(dis[0][0][u], dis[0][2][u]) + w; //B类 if(v == son[1][0][u]) dis[1][2][v] = max(dis[1][1][u], dis[1][2][u]) + w; else dis[1][2][v] = max(dis[1][0][u], dis[1][2][u]) + w; dfs2(v, u); }}inline bool read(int &amp;num) { char in;bool IsN=false; in=getchar(); if(in==EOF) return false; while(in!='-'&amp;&amp;(in&lt;'0'||in&gt;'9')) in=getchar(); if(in=='-'){ IsN=true;num=0;} else num=in-'0'; while(in=getchar(),in&gt;='0'&amp;&amp;in&lt;='9'){ num*=10,num+=in-'0'; } if(IsN) num=-num; return true;}int main(){ // freopen(&quot;game.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;game.out&quot;, &quot;w&quot;, stdout); int t; read(t); while (t--) { int n, m, u, v, w; read(n), read(m); init(n + m); get_ca(0, n); get_ca(1, m); for(int i = 1; i &lt;= n + m - 1; i++){ read(u), read(v), read(w); add_edge(u, v, w); } dfs1(1, 0); dfs2(1, 0); ll da = 0, db = 0; for(int i = 1; i &lt;= n + m; i++){ if(ca[i] == 0) da += max(dis[0][0][i], dis[0][2][i]); else db += max(dis[1][0][i], dis[1][2][i]); } if(da &gt; db) printf(&quot;A\\n&quot;); else if (da == db) printf(&quot;T\\n&quot;); else printf(&quot;B\\n&quot;); }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;using namespace std;#define N 20200#define ll long long#define SS 100000char bf[SS], *p1 = bf, *p2 = bf;#define nc() (p1==p2&amp;&amp;(p2=(p1=bf)+fread(bf,1,SS,stdin),p2==p1)?-1:*p1++)inline int read() { int x = 0, f = 1; char ch = nc(); for (; (ch &lt; '0' || ch &gt; '9') &amp;&amp; (ch != '-'); ch = nc()); if (ch == '-')ch = nc(), f = -1; for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; x = x * 10 + ch - 48, ch = nc()); return f * x;}int n, m, cnt, last[N], sz[N], fa[N], son[N], top[N], dep[N], Dep, who, x[N], y[N], id[N], a1, b1, a2, b2;struct edge { int to, next, w;} e[N &lt;&lt; 1];inline void add(int u, int v, int w) { e[++cnt] = {v, last[u], w}, last[u] = cnt; e[++cnt] = {u, last[v], w}, last[v] = cnt;}void dfs(int x, int fa, int d, int f) { dep[x] = d; for (int i = last[x], y; i; i = e[i].next) if ((y = e[i].to) != fa)dfs(y, x, d + e[i].w, f); if (id[x] == f)if (Dep &lt; dep[x])Dep = dep[x], who = x;}void dfs1(int x, int d) { sz[x] = 1, dep[x] = d; for (int i = last[x], y; i; i = e[i].next) if ((y = e[i].to) != fa[x]) { fa[y] = x, dfs1(y, d + e[i].w), sz[x] += sz[y]; if (sz[son[x]] &lt; sz[y])son[x] = y; }}void dfs2(int x, int d) { top[x] = d; if (son[x])dfs2(son[x], d); for (int i = last[x], y; i; i = e[i].next)if ((y = e[i].to) != fa[x] &amp;&amp; y != son[x])dfs2(y, y);}inline int lca(int l, int r) { if (l == r)return l; for (; top[l] != top[r]; dep[top[l]] &lt; dep[top[r]] ? r = fa[top[r]] : l = fa[top[l]]); return dep[l] &lt; dep[r] ? l : r;}inline int dis(int l, int r) { return dep[l] + dep[r] - (dep[lca(l, r)] &lt;&lt; 1); }inline void solve() { n = read(), m = read(); for (int i = 1; i &lt;= n + m; ++i)last[i] = sz[i] = fa[i] = son[i] = top[i] = dep[i] = cnt = 0; for (int i = 1; i &lt;= n; ++i)x[i] = read(), id[x[i]] = 1; for (int i = 1; i &lt;= m; ++i)y[i] = read(), id[y[i]] = 2; for (int i = 1; i &lt; n + m; ++i) { int u = read(), v = read(), w = read(); add(u, v, w); } Dep = 0, dep[0] = 0, dfs(1, 0, 0, 1), b1 = who; Dep = 0, dep[0] = 0, dfs(b1, 0, 0, 1), a1 = who; Dep = 0, dep[0] = 0, dfs(1, 0, 0, 2), b2 = who; Dep = 0, dep[0] = 0, dfs(b2, 0, 0, 2), a2 = who; dep[0] = 0, dfs1(1, 0), dfs2(1, 1); ll da = 0, db = 0; for (int i = 1; i &lt;= n; ++i) da += max(dis(a1, x[i]), dis(b1, x[i])); for (int i = 1; i &lt;= m; ++i) db += max(dis(a2, y[i]), dis(b2, y[i])); if (da &gt; db) puts(&quot;A&quot;); else if (da &lt; db) puts(&quot;B&quot;); else puts(&quot;T&quot;);}int main() { int T = 1; scanf(&quot;%d&quot;, &amp;T); while (T--) { solve(); }} 猪灵的胜利之舞# 题意：$f[3]=4, f[4]=7, f[n]=f[n-1]+f[n-2]$，求$\\frac{f[n]}{2^n}$ 十进制快速幂# 二进制快速幂与十进制快速幂的对比（伪代码） 十进制 二进制 123456ans = 1while (y != 0) { ans = ans * pow(x, y%10); x = pow(x, 10); y = y / 10;}123456ans = 1while (y != 0) { ans = ans * pow(x, y%2); x = pow(x, 2); y = y / 2;} 十进制快速幂和二进制快速幂在原理上是一样的，不过二进制快速幂通常实现为位运算，而十进制则用字符串来处理。 循环节# 斐波那契数列在1e9+7下循环节为2e9+16，这题答案就是斐波那契数列的第n项加上n-2项。 循环节可以通过如下程序暴力找出： 1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main() { int a = 1, b = 1, m = 1e9 + 7; long long cnt = 0; while(true) { cnt++; a = (a + b) % m; swap(a, b); if (a == 1 &amp;&amp; b== 1) break; } cout &lt;&lt; cnt &lt;&lt; '\\n'; cerr &lt;&lt; &quot;Time: &quot; &lt;&lt; (double)clock()/CLOCKS_PER_SEC &lt;&lt; '\\n';} 运行结果： 122000000016Time: 6.851 参考代码# 十进制快速幂 循环节 数据生成器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int N = 1e6 + 5;const ll M = 1e9 + 7;using Mat = array&lt;array&lt;ll, 2&gt;, 2&gt;;#define FOR(i, n) for(int i = 0; i &lt; n; i++)string n;int len;Mat operator*(const Mat &amp;a, const Mat &amp;b) { Mat c{}; FOR(i, 2) FOR(j, 2) FOR(k, 2) c[i][j] = (c[i][j] + a[i][k] * b[k][j]) % M; return c;}Mat Pow(Mat x, int y) { Mat ans{{{1, 0}, {0, 1}}}; FOR(t, y) ans = ans * x; return ans;}ll Pow(ll x, int y) { ll ans = 1; FOR(t, y) ans = ans * x % M; return ans;}ll Pow(ll x, ll y) { ll ans = 1; while (y) { if (y &amp; 1) ans = ans * x % M; x = x * x % M; y &gt;&gt;= 1; } return ans;}Mat Pow(Mat x) { Mat ans{{{1, 0}, {0, 1}}}; FOR(i, len) { ans = ans*Pow(x, n[i]-'0'); x = Pow(x, 10); } return ans;}ll Pow(ll x) { ll ans = 1; FOR(i, len) { ans = ans*Pow(x, n[i]-'0')%M; x = Pow(x, 10); } return ans;}int main() { cin &gt;&gt; n; len = (int)n.length(); reverse(n.begin(), n.end()); Mat A = Pow(Mat{{{1, 1}, {1, 0}}}); A = A * Mat{{{1, 0}, {2, 0}}}; cout &lt;&lt; A[1][0] * Pow(Pow(2ll), M-2) % M; return 0;}12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int mod = 1e9+7;const int T = 2e9+16;inline pair&lt;ll,ll&gt; read() { char c=getchar();ll x=0,y=0; while(c&lt;'0'||c&gt;'9') c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9')x=(x*10+c-'0')%T,y=(y*10+c-'0')%(mod-1),c=getchar(); return {x,y};}ll fpow(ll a,ll b){ll r=1;for(a%=mod;b;b&gt;&gt;=1){if(b&amp;1)r=r*a%mod;a=a*a%mod;}return r;}ll fib(ll n) { function&lt;ll(ll,ll,ll,ll,ll)&gt; f = [&amp;](ll a,ll b,ll p,ll q,ll n) -&gt; ll { if(!n) return b; if(n&amp;1) return f((b*q+a*q+a*p)%mod,(b*p+a*q)%mod,p,q,n-1); return f(a,b,(p*p+q*q)%mod,(q*q+2*q*p)%mod,n/2); }; return f(1,0,0,1,n);}int main() { pair&lt;ll,ll&gt; p=read(); ll n=p.first+T,n2=p.second; cout&lt;&lt;(fib(n+1)+fib(n-1))%mod*fpow((mod+1)/2,n2)%mod&lt;&lt;endl;}1234567891011121314151617181920212223242526272829303132#include &quot;testlib.h&quot;#include &lt;iostream&gt;using namespace std;int testIndex = 0;void nextTest() { testIndex++; freopen((&quot;data/&quot;+to_string(testIndex)+&quot;.in&quot;).c_str(), &quot;w&quot;, stdout);}int main(int argc, char* argv[]) { registerGen(argc, argv, 1); for (int i = 3; i &lt;= 5; i++) { nextTest(); cout &lt;&lt; i &lt;&lt; endl; } nextTest(); cout &lt;&lt; rnd.next(&quot;[1-9][0-9]{1,10}&quot;) &lt;&lt; endl; nextTest(); cout &lt;&lt; rnd.next(&quot;[1-9][0-9]{10,100}&quot;) &lt;&lt; endl; nextTest(); cout &lt;&lt; rnd.next(&quot;[1-9][0-9]{100,1000}&quot;) &lt;&lt; endl; nextTest(); cout &lt;&lt; rnd.next(&quot;[1-9][0-9]{1000,10000}&quot;) &lt;&lt; endl; nextTest(); cout &lt;&lt; rnd.next(&quot;[1-9][0-9]{10000,100000}&quot;) &lt;&lt; endl; nextTest(); cout &lt;&lt; rnd.next(&quot;[1-9][0-9]{100000,999999}&quot;) &lt;&lt; endl; nextTest(); cout &lt;&lt; rnd.next(&quot;[1-9][0-9]{999999}&quot;) &lt;&lt; endl; nextTest(); cout &lt;&lt; rnd.next(&quot;1[0]{1000000}&quot;) &lt;&lt; endl; return 0;} 艾尔奇亚的国王# 题意：A有 n 个筹码，可以从$[l_1, r_1]$区间随机选整数。 B有 m 个筹码，可以从$[l_2, r_2]$区间随机选整数。 数字大的人拿走数字小的人的筹码，（数字相同算平局），没有筹码的人算输。 求A、B赢的概率。 12345678910111213141516171819202122232425262728293031323334353637#include &quot;bits/stdc++.h&quot;using namespace std;typedef long long ll;const int maxn=1e6+7;double p,k,q,sum;double f[maxn];int n,l1,r1,m,l2,r2;void getf(int pos,double x){ if(pos==n+m) f[pos]=1; else { double tx=p/(1-k-q*x); getf(pos+1,tx); f[pos]=tx*f[pos+1]; }}int main(){ while(scanf(&quot;%d%d%d%d%d%d&quot;,&amp;n,&amp;l1,&amp;r1,&amp;m,&amp;l2,&amp;r2)==6) { p=k=q=sum=0; for(int i=l1;i&lt;=r1;i++) { for(int j=l2;j&lt;=r2;j++) { if(i&gt;j) p+=1; else if(i==j) k+=1; else q+=1; sum+=1; } } p/=sum;k/=sum;q/=sum; getf(1,0); printf(&quot;%.3f %.3f\\n&quot;,f[n],1.0-f[n]); }} umi炒饭# 题意：给n个点的坐标以及权值，问一个长w宽h的矩形内的点权值之和的最大值。 前置知识：线段树、扫描线 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &quot;bits/stdc++.h&quot;using namespace std;typedef long long ll;const int maxn=1e4+7;struct Node{ int x,y,val; bool operator &lt; (const Node &amp;tmp) const { if(y==tmp.y) return x&lt;tmp.x; else return y&lt;tmp.y; }};Node node[maxn&lt;&lt;1];int n,w,h,cnt;int tx[maxn&lt;&lt;1],ty[maxn&lt;&lt;1],tree[maxn&lt;&lt;2],lazy[maxn&lt;&lt;2];void build(int root,int l,int r){ if(l&gt;=r) { tree[root]=0; lazy[root]=0; return; } int mid=(l+r)&gt;&gt;1; int lrt=root&lt;&lt;1; int rrt=lrt+1; build(lrt,l,mid); build(rrt,mid+1,r); tree[root]=0; lazy[root]=0;}void pushdown(int root){ if(lazy[root]) { int lrt=root&lt;&lt;1; int rrt=lrt+1; lazy[lrt]+=lazy[root]; lazy[rrt]+=lazy[root]; tree[lrt]+=lazy[root]; tree[rrt]+=lazy[root]; lazy[root]=0; }}void add(int ql,int qr,int val,int root,int l,int r){ if(l&gt;=ql&amp;&amp;r&lt;=qr) { tree[root]+=val; lazy[root]+=val; return; } pushdown(root); int mid=(l+r)&gt;&gt;1; int lrt=root&lt;&lt;1; int rrt=lrt+1; if(qr&lt;=mid) add(ql,qr,val,lrt,l,mid); else if(ql&gt;mid) add(ql,qr,val,rrt,mid+1,r); else add(ql,qr,val,lrt,l,mid),add(ql,qr,val,rrt,mid+1,r); tree[root]=max(tree[lrt],tree[rrt]);}int query(int ql,int qr,int root,int l,int r){ if(l&gt;=ql&amp;&amp;r&lt;=qr) { return tree[root]; } pushdown(root); int mid=(l+r)&gt;&gt;1; int lrt=root&lt;&lt;1; int rrt=lrt+1; if(qr&lt;=mid) return query(ql,qr,lrt,l,mid); else if(ql&gt;mid) return query(ql,qr,rrt,mid+1,r); else return query(ql,qr,lrt,l,mid)+query(ql,qr,rrt,mid+1,r);}int main(){ while(scanf(&quot;%d%d%d&quot;,&amp;n,&amp;w,&amp;h)==3) { cnt=0; for(int i=1;i&lt;=n;i++) { scanf(&quot;%d%d%d&quot;,&amp;node[i].x,&amp;node[i].y,&amp;node[i].val); tx[++cnt]=node[i].x; ty[cnt]=node[i].y; node[i+n].x=node[i].x; node[i+n].y=node[i].y+h+1; node[i+n].val=-node[i].val; tx[++cnt]=node[i+n].x; ty[cnt]=node[i+n].y; } sort(node+1,node+1+n+n); sort(tx+1,tx+1+cnt); sort(ty+1,ty+1+cnt); int cx=unique(tx+1,tx+1+cnt)-tx-1; int cy=unique(ty+1,ty+1+cnt)-ty-1; build(1,1,cx); int ans=0; for(int i=1,j=1;i&lt;=cy;i++) { while(j&lt;=2*n&amp;&amp;node[j].y&lt;=ty[i]) { int ql=lower_bound(tx+1,tx+1+cx,node[j].x)-tx; int qr=upper_bound(tx+1,tx+1+cx,node[j].x+w)-tx-1; add(ql,qr,node[j].val,1,1,cx); j++; } ans=max(ans,tree[1]); } printf(&quot;%d\\n&quot;,ans); }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124//#pragma GCC optimize(2)#include&lt;bits/stdc++.h&gt;using namespace std;//#include&lt;ext/pb_ds/assoc_container.hpp&gt;//#include&lt;ext/pb_ds/tree_policy.hpp&gt;//#include&lt;ext/pb_ds/hash_policy.hpp&gt;//#include&lt;ext/pb_ds/trie_policy.hpp&gt;//#include&lt;ext/pb_ds/priority_queue.hpp&gt;//#include&lt;ext/rope&gt;//using namespace __gnu_cxx;//using namespace __gnu_pbds;//void err(istream_iterator&lt;string&gt; it){cerr&lt;&lt;endl;}//template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args){cerr &lt;&lt; *it &lt;&lt; &quot; = &quot; &lt;&lt; a &lt;&lt; &quot; , &quot;;err(++it, args...);}//#define error(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); }#define mem(a,b) memset((a),b,sizeof((a)))#define fpre(x) cout&lt;&lt;fixed&lt;&lt;setprecision(x)#define clr(v) (v).clear()#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define pli pair&lt;ll,int&gt;#define pll pair&lt;ll,ll&gt;#define mp make_pair#define eb emplace_back#define pb emplace_back#define ll long long#define ld long double#define ull unsigned long long#define uint unsigned int#define ushort unsigned short#define IOS ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)#define lowbit(i) (i&amp;(-i))#define lson (rt&lt;&lt;1)#define rson lson|1#define fi first#define se secondconst ld eps=1e-10;const ld pi=acos(-1);inline int dcmp(ld x){ if(x&lt;-eps) return -1; if(x&gt;eps) return 1; return 0;}//-----------------------------------------------headconst int maxn=1e5+5;int t[maxn&lt;&lt;2];int lzy[maxn&lt;&lt;2];void build(int l,int r,int rt){ t[rt]=lzy[rt]=0; if(l==r) return; int m=(l+r)&gt;&gt;1; build(l,m,lson); build(m+1,r,rson);}void pd(int rt){ if(lzy[rt]) { int v=lzy[rt]; t[lson]+=v; t[rson]+=v; lzy[lson]+=v; lzy[rson]+=v; lzy[rt]=0; }}void upd(int L,int R,int v,int l,int r,int rt){ if(L&lt;=l&amp;&amp;r&lt;=R) { t[rt]+=v; lzy[rt]+=v; return; } pd(rt); int m=(l+r)&gt;&gt;1; if(m&gt;=L) upd(L,R,v,l,m,lson); if(m&lt;R) upd(L,R,v,m+1,r,rson); t[rt]=max(t[lson],t[rson]);}pair&lt;pii,ll&gt;a[maxn];int main(){ int n,w,h; while(cin&gt;&gt;n&gt;&gt;w&gt;&gt;h) { assert(n&gt;=0&amp;&amp;n&lt;=10000); assert(w&gt;=1&amp;&amp;w&lt;=20000); assert(h&gt;=1&amp;&amp;w&lt;=20000); build(1,1e5,1); for(int i=0;i&lt;n;++i) { cin&gt;&gt;a[i].fi.fi&gt;&gt;a[i].fi.se&gt;&gt;a[i].se; assert(a[i].fi.fi&gt;=-1e4&amp;&amp;a[i].fi.fi&lt;=1e4); assert(a[i].fi.se&gt;=-1e4&amp;&amp;a[i].fi.se&lt;=1e4); assert(a[i].se&gt;=1&amp;&amp;a[i].se&lt;=1e5); a[i].fi.fi+=3e4+1; a[i].fi.se+=3e4+1; } sort(a,a+n); int mx=0; for(int i=0,j=0;i&lt;n;++i) { upd(a[i].fi.se-h,a[i].fi.se,a[i].se,1,1e5,1); while(a[i].fi.fi-w&gt;a[j].fi.fi) { upd(a[j].fi.se-h,a[j].fi.se,-a[j].se,1,1e5,1); ++j; } mx=max(mx,t[1]); } cout&lt;&lt;mx&lt;&lt;endl; }} 谜拟Q plus# 分析：【贪心】【dp】【二分】 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e3+10;int n,Q,num1,num2;long long dp[N],rem[N];struct Tp1{ long long a,b; bool operator &lt;(const Tp1 &amp;op)const{ return (a==op.a)?b&gt;op.b:a&lt;op.a; }}tp1[N];struct Tp2{ long long a,b; bool operator &lt;(const Tp2 &amp;op)const{ return (b==op.b)?a&lt;op.a:b&gt;op.b; }}tp2[N];struct hh{ long long x,id,ans;}q[N];bool cmp(hh a,hh b){ return a.x&lt;b.x;}bool cmp2(hh a,hh b){ return a.id&lt;b.id;}int find(long long x){ int l,r,mid,ret=0; l=1;r=num2; while(l&lt;=r) { mid=l+r&gt;&gt;1; if(dp[mid]&lt;=x) ret=max(ret,mid),l=mid+1; else r=mid-1; } return ret;}int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); if(x&lt;=y) tp1[++num1]=(Tp1){x,y}; else tp2[++num2]=(Tp2){x,y}; } sort(tp1+1,tp1+num1+1); sort(tp2+1,tp2+num2+1); memset(dp,127/3,sizeof(dp)); dp[0]=0; for(int i=num2;i&gt;=1;i--){ for(int j=num2-i+1;j&gt;=1;j--){ if(dp[j-1]&gt;tp2[i].b) dp[j]=min(dp[j],dp[j-1]-tp2[i].b+tp2[i].a); else dp[j]=min(dp[j],1+tp2[i].a); } } scanf(&quot;%d&quot;,&amp;Q); for(int i=1;i&lt;=Q;i++) cin&gt;&gt;q[i].x,q[i].id=i,q[i].ans=-1; sort(q+1,q+1+Q,cmp); int pos,x,tans; pos=x=tans=0; pos=1; for(int i=1;i&lt;=num1;i++) rem[i]=rem[i-1]-tp1[i].a+tp1[i].b; for(int i=1;i&lt;=num1;i++) { //cout&lt;&lt;&quot;___&quot;&lt;&lt;q[pos].x&lt;&lt;&quot; &quot;&lt;&lt;tp1[i].a-x&lt;&lt;endl; while(pos&lt;=Q&amp;&amp;q[pos].x&lt;=tp1[i].a-x) q[pos++].ans=tans; x+=-tp1[i].a+tp1[i].b;tans++; //cout&lt;&lt;i&lt;&lt;&quot;*&quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;pos&lt;&lt;&quot; &quot;&lt;&lt;tp1[i].a&lt;&lt;&quot; &quot;&lt;&lt;tp1[i].b&lt;&lt;endl; if(pos&gt;Q) break; } for(int i=1;i&lt;=Q;i++) if(q[i].ans==-1) q[i].ans=num1; sort(q+1,q+1+Q,cmp2); /*for(int i=1;i&lt;=Q;i++) cout&lt;&lt;q[i].ans&lt;&lt;&quot; &quot;;cout&lt;&lt;endl; for(int i=1;i&lt;=num2;i++) cout&lt;&lt;dp[i]&lt;&lt;&quot; &quot;;cout&lt;&lt;endl; */ for(int i=1;i&lt;=Q;i++){ printf(&quot;%lld\\n&quot;,q[i].ans+find(rem[q[i].ans]+q[i].x)); }} 世界棋盘# 分析【min25筛法】【杜教筛】 参考代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;typedef long long ll;const int maxn = 1e5 + 7;const int mod = 998244353;ll n, k, sqr, nsqr;int p[maxn], cntp;ll prep[maxn];bool np[maxn];void sieve(int x){ for(int i = 2; i &lt;= x; ++i){ if(!np[i]){ p[++cntp] = i; prep[cntp] = prep[cntp - 1] + i; } for(int j = 1; j &lt;= cntp &amp;&amp; i * p[j] &lt;= x; ++j){ np[i * p[j]] = true; if(i % p[j] == 0){ break; } } }}ll w[maxn], cntw, h[maxn], s[maxn];int ID(ll x){ return x &lt;= nsqr ? cntw - x + 1 : n / x;}void calw(){ cntw = sqr + nsqr - 1; for(int i = 1; i &lt;= sqr; ++i){ w[i] = n / i; } for(int i = sqr + 1; i &lt;= cntw; ++i){ w[i] = w[i - 1] - 1; } for(int i = 1; i &lt;= cntw; ++i){ h[i] = w[i] * (w[i] + 1) / 2 - 1; } for(int i = 1; i &lt;= cntp; ++i){ for(int j = 1; j &lt;= cntw &amp;&amp; 1ll * p[i] * p[i] &lt;= w[j]; ++j){ h[j] -= p[i] * (h[ID(w[j] / p[i])] - prep[i - 1]); } } for (int i = cntp; i &gt;= 1; --i) { for (int j = 1; j &lt;= cntw &amp;&amp; 1ll * p[i] * p[i] &lt;= w[j]; ++j) { for (ll k = p[i]; 1ll * k * p[i] &lt;= w[j]; k *= p[i]) { s[j] += s[ID(w[j] / k)] + h[ID(w[j] / k)] - prep[i - 1]; } } }}ll S(ll x, ll k){ if(x &lt;= 2 || p[k] &gt; x){ return 0; } ll ans = 0; for(int i = k; i &lt;= cntp &amp;&amp; 1ll * p[i] * p[i] &lt;= x; ++i){ for(ll j = p[i];1ll * j * p[i] &lt;= x; j *= p[i]){ ans = (ans + h[ID(x / j)] - prep[i - 1] + S(x / j, i + 1)) % mod; } } return ans;}ll g[maxn];ll G(ll x){ if (x &lt;= 1) { return x; } int id = ID(x); if(g[id]){ return g[id]; } ll ans = (1 + s[id] + h[id]) % mod; for(ll l = 2, r; l &lt;= x; l = r + 1){ r = x / (x / l); ans = (ans - (r - l + 1) * G(x / l) % mod + mod) % mod; } return g[id] = ans;}int main(){ scanf(&quot;%lld&quot;, &amp;n); sqr = sqrt(n); nsqr = n / sqr; sieve(sqr); calw(); ll ans = 0; for(ll l = 1, r; l &lt;= n; l = r + 1){ r = n / (n / l); ans = (ans + (n / l) * (n / l) % mod * (G(r) - G(l - 1) + mod) % mod) % mod; } printf(&quot;%lld\\n&quot;, ans);} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include&lt;bits/stdc++.h&gt;using namespace std;typedef double db;typedef long long ll;#define fi first#define se second#define all(x) (x).begin(), (x).end()const int mod = 998244353;int power_mod(int a, int b) { int r = !!a; for(; b; b &gt;&gt;= 1, a = (ll) a * a % mod) if(b &amp; 1) r = (ll) r * a % mod; return r;}const int N = 1e5 + 1000;bitset&lt;N&gt; np;int p[N&gt;&gt;2], pn;ll pg[N&gt;&gt;2], ph[N&gt;&gt;2]; // pg(n) = \\sum_{i=1}^n g[p[i]]void sieve(int sz) { for(int i = 2; i &lt;= sz; i++) { if(!np[i]) { ++pn; p[pn] = i; pg[pn] = (pg[pn - 1] + 1) % mod; ph[pn] = (ph[pn - 1] + i) % mod; } for(int j = 1; j &lt;= pn &amp;&amp; i * p[j] &lt;= sz; j++) { np[i * p[j]] = 1; if(i % p[j] == 0) { break; } } }}int _id[N*2], m;ll n;ll w[N * 2];ll Pg[N * 2], Ph[N * 2]; // Pg(n) = \\sum_{i=1}^{w[n]} g[i] [i in Prime ]int id(ll x) { return x &lt; N ? x : n / x + N;}int Id(ll x) { return _id[id(x)];}typedef __int128 i16;ll G[N * 2], H[N * 2];/****** G(n) = \\sum_{i = 1}^{w[n]} -mu[i]*** H(n) = \\sum_{i = 1}^{w[n]} -mu[i] * minp[i] G(n, j) = \\sum_{i = 1}^n [minp[i] &gt;= p[j] and i not in Prime] -mu[i] = G(n, j + 1) + mu[p[j]] * (G(n / p[j], j + 1) + Pg(n / p[j]) - pg(j - 1)) H(n, j) = \\sum_{i = 1}^n [minp[i] &gt;= p[j] and i not in Prime] -mu[i]*minp[i] = H(n, j + 1) - p[j] * (G(n / p[j], j + 1) + Pg(n / p[j]) - pg(j - 1))*** ans = \\sum_{i = 1}^n (n/i)^2 * mu[i] * (1 - minp[i]) = \\sum_{i = 1}^n (n/i)^2 * (H(n) - G(n))***/void init(int sz) { sieve(sz); m = 0; for(ll l = 1, r; l &lt;= n; l = r + 1) { r = n / (n / l); w[++m] = n / l; _id[id(w[m])] = m; Pg[m] = (w[m] - 1) % mod; Ph[m] = ((i16) w[m] * (w[m] + 1) / 2 - 1) % mod; } for(int j = 1; j &lt;= pn; j++) { for(int i = 1; i &lt;= m &amp;&amp; (ll) p[j] * p[j] &lt;= w[i]; i++) { int k = Id(w[i] / p[j]); Pg[i] = (Pg[i] - (Pg[k] - pg[j - 1])) % mod; Ph[i] = (Ph[i] - p[j] * (Ph[k] - ph[j - 1])) % mod; } } for(int j = pn; j &gt;= 1; j--) { for(int i = 1; i &lt;= m &amp;&amp; (ll) p[j] * p[j] &lt;= w[i]; i++) { int k = Id(w[i] / p[j]); G[i] = (G[i] - (G[k] + Pg[k] - pg[j])) % mod; H[i] = (H[i] - p[j] * (G[k] + Pg[k] - pg[j])) % mod;// cout &lt;&lt; w[i] &lt;&lt; ' ' &lt;&lt; p[j] &lt;&lt; ' ' &lt;&lt; G[i] &lt;&lt; &quot; ha &quot; &lt;&lt; endl; } } for(int i = 1; i &lt;= m; i++) { G[i] = (G[i] + Pg[i] - 1) % mod; H[i] = (H[i] + Ph[i]) % mod; if(G[i] &lt; 0) G[i] += mod; if(H[i] &lt; 0) H[i] += mod; } /* cout &lt;&lt; m &lt;&lt; &quot; JDH &quot; &lt;&lt; endl; for(int i = 1; i &lt;= m; i++) { cout &lt;&lt; w[i] &lt;&lt; ' ' &lt;&lt; G[i] &lt;&lt; ' ' &lt;&lt; H[i] &lt;&lt; '\\n'; }*/}/*** \\sum_{i=1}^n \\sum_{d|i} mu[d] * maxp[i / d] = sum_{i=1}^n mu[i] * (1 - minp[i]) ***/ll Muf(ll n) { if(n == 0) return 0; int k = Id(n); ll ret = H[k] - G[k]; if(ret &lt; 0) ret += mod; return ret;}int main() {#ifdef local freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); cin &gt;&gt; n; ll B = sqrt(n) + 10; init(B); ll ret = 0, last = 0; for(ll l = 1, r; l &lt;= n; l = r + 1) { r = n / (n / l); ll cur = Muf(r); ret = (ret + (i16) (n / l) * (n / l) % mod * (cur - last)) % mod; last = cur;// cout &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; ' ' &lt;&lt; ret &lt;&lt; endl; }/* for(int i = 1; i &lt;= m; i++) { cout &lt;&lt; w[i] &lt;&lt; ' ' &lt;&lt; Muf(w[i]) &lt;&lt; ' ' &lt;&lt; Pg[i] &lt;&lt; ' ' &lt;&lt; Ph[i] &lt;&lt; endl;; }*/ if(ret &lt; 0) ret += mod; cout &lt;&lt; ret &lt;&lt; '\\n'; return 0;}","link":"/posts/scutpc2020-summary/"},{"title":"给VNote添加任务系统","text":"VNote是一款专为Markdown设计的Vim风格笔记应用程序。目前使用已经两年多了，平时用来记录、摘抄都挺方便的。略有不方便的地方就是VNote不能方便地运行一些外部工具，例如： 通过Git进行笔记的版本控制 将多个终端的笔记通过坚果云进行同步 将写好的Markdown文档通过Hexo渲染预览并发布 调用外部编辑器如Typora或是VS Code进行进一步编辑 在本文中，我将为VNote设计实现一个任务系统来运行外部工具，从而解决上面这些问题。 这些常用的功能大多可以通过运行命令行工具来完成，鉴于它们的常用性，有必要将其集成在VNote内部，这样无需在需要调用外部工具时输入命令行，或是编写代码。在 VNote 2.10 版本中，添加了调用Git的功能。但局限性较大，无法进行扩展。 相关介绍# 目前许多文本编辑器或是IDE都有执行外部命令的功能，它们的可配置性较高。例如VSCode的Tasks 、Sublime Text的Build Systems 、IntelliJ IDEA的External Tools 、Qt Creator的External Tools 以及Visual Studio的External tools 。VNote的任务系统主要参考的是VSCode的Tasks ，并结合了其它实现的一些优点。由于VNote v2版本代码不再维护，且v3版本已处于beta阶段，因此任务系统首先考虑在v3版本添加。此外，由于内容较多，下面列出的一些功能仅仅是设计阶段的一些想法，并未完全实现。尚未实现的功能均有所标注。 要知道运行什么任务、如何运行，必须进行配置。综合来看，目前的配置方式主要分为两大类：编写配置文件、图形化配置界面。其中VSCode采用的是.vscode/tasks.json配置文件，Sublime Text采用的是name.sublime-build配置文件，均为类似JSON格式的配置文件。配置文件示例如下所示： VSCode配置文件 Sublime Text配置文件 1234567891011121314151617181920{ // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ { &quot;label&quot;: &quot;Run tests&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;./scripts/test.sh&quot;, &quot;windows&quot;: { &quot;command&quot;: &quot;.\\\\scripts\\\\test.cmd&quot; }, &quot;group&quot;: &quot;test&quot;, &quot;presentation&quot;: { &quot;reveal&quot;: &quot;always&quot;, &quot;panel&quot;: &quot;new&quot; } } ]}123456789101112{ &quot;shell_cmd&quot;: &quot;g++ \\&quot;${file}\\&quot; -o \\&quot;${file_path}/${file_base_name}\\&quot;&quot;, &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;, &quot;working_dir&quot;: &quot;${file_path}&quot;, &quot;selector&quot;: &quot;source.c++&quot;, &quot;variants&quot;: [ { &quot;name&quot;: &quot;Run&quot;, &quot;shell_cmd&quot;: &quot;g++ \\&quot;${file}\\&quot; -o \\&quot;${file_path}/${file_base_name}\\&quot; &amp;&amp; \\&quot;${file_path}/${file_base_name}\\&quot;&quot; } ]} 其余IDE大多采用图形化配置，如下图所示。 考虑到目前VNote也是主要采用JSON格式的配置文件，因此任务系统也通过JSON文件进行配置。后续会考虑在设置里添加图形化配置方式。 下载开发版本# 目前任务系统仍然处于开发过程中，可以在此查看相关代码。 通过下面的按钮可以下载包含任务系统功能的测试版本： Windows x64Windows x86macOSLinux 如果你对VSCode Task熟悉，想知道它们之间有什么区别，可以直接查看对比VSCode Task。 快速上手# Hello World# 一个最简单的示例莫过于在屏幕上输出helloworld了。通过右上角的设置菜单打开用户配置文件夹。 在tasks文件夹内新建一个hello.json文件，输入如下内容。 123{ &quot;command&quot;: &quot;echo helloworld&quot;} 保存文件后，可以发现主菜单多了一个hello菜单项，点击该菜单项即可运行上述任务。 运行任务时会自动弹出下方的输出面板，在输出面板可以查看任务运行过程中的输出信息。如果你看到了helloworld显示在下方的输出面板中，说明任务运行成功了。在默认情况下，VNote会把命令传递给系统默认的命令解释器（Windows平台使用PowerShell.exe，Linux和macOS平台使用/bin/bash）执行，并接收输出的结果显示在输出面板上。对于支持的所有配置项及其含义，请参考任务配置。 自定义菜单项# 对于每个任务，VNote会自动在主界面生成一个菜单项与之对应，默认使用文件名或命令值作为菜单名称。通过label、icon以及shortcut可以指定任务的名称（Hello）、图标（tasks-solid.svg）以及快捷键（Alt+H, T）。 123456789{ &quot;label&quot;: &quot;Hello&quot;, &quot;icon&quot;: &quot;tasks-solid.svg&quot;, &quot;shortcut&quot;: &quot;Alt+H, T&quot;, &quot;command&quot;: &quot;echo&quot;, &quot;args&quot;: [ &quot;Hello tasks!&quot; ]} 此时主界面的菜单项会加上图标及快捷键。按快捷键Alt+H, T即可运行该任务。 提示：尽量使用SVG格式的图标，VNote会根据当前主题调整图标颜色，以达到更好的显示效果。 任务同时还可以包含若干个子任务，支持无限层级的嵌套，在菜单栏中展示为多级子菜单。如下是一个Hello Tasks任务，包含三个子任务Hello Cat、Hello Dove和Hello Fish。 123456789101112131415161718192021222324252627{ &quot;label&quot;: &quot;Hello Tasks&quot;, &quot;icon&quot;: &quot;tasks-solid.svg&quot;, &quot;shortcut&quot;: &quot;Alt+H, T&quot;, &quot;command&quot;: &quot;echo&quot;, &quot;args&quot;: [&quot;Hello tasks!&quot;], &quot;tasks&quot;: [ { &quot;label&quot;: &quot;Hello Cat&quot;, &quot;icon&quot;: &quot;cat-solid.svg&quot;, &quot;shortcut&quot;: &quot;Alt+H, C&quot;, &quot;args&quot;: [&quot;Hello cat!&quot;] }, { &quot;label&quot;: &quot;Hello Dove&quot;, &quot;icon&quot;: &quot;dove-solid.svg&quot;, &quot;shortcut&quot;: &quot;Alt+H, D&quot;, &quot;args&quot;: [&quot;Hello dove!&quot;] }, { &quot;label&quot;: &quot;Hello Fish&quot;, &quot;icon&quot;: &quot;fish-solid.svg&quot;, &quot;shortcut&quot;: &quot;Alt+H, F&quot;, &quot;args&quot;: [&quot;Hello fish!&quot;] } ]} 上面的子任务没有配置command但依然可以执行，这是因为子任务会从父任务中继承大部分常见属性（如type、command、args）。 注意：请尽量不要在包含子任务的任务中配置命令，因为菜单项的点击操作默认实现为展开下一级菜单，从而导致无法通过点击菜单项来触发任务执行，但仍然可以通过快捷键方式执行任务。 特殊字符处理# 当命令或参数包含特殊字符（如空格）时通常需要进行特殊的处理，由于不同命令解释器的语法大相径庭，没有统一的处理方法。默认情况下，VNote会进行如下处理。 当满足下面所有条件时，VNote会自动在参数两端加上双引号。 当不指定type或type为shell 同时指定command和args 参数中包含空格 当满足下面所有条件时，VNote会用空格分隔将命令和参数合并成一个字符串并在两端加上双引号，同时转义内部的双引号。 当不指定type或type为shell 当shell为bash 例如在Linux下运行之前的Hello Tasks 示例，命令将被处理成：（可在运行日志中查看） run task &quot;/bin/bash&quot; (&quot;-c&quot;, &quot;echo \\\\\\&quot;Hello tasks!\\\\\\&quot;&quot;) 输出结果两端会出现多余的双引号，通过仅指定command或用process方式启动任务可以手动处理特殊字符。 启动外部程序# 默认情况下command会作为shell命令执行（即默认type为shell），通过指定type为process可以将command作为外部程序运行。下面是一个示例，在Typora或VS Code中打开当前文件。其中${file}是一个变量，会在运行时替换为当前打开的文件路径。关于变量的更多信息，请参考变量替换。 Windows Linux 1234567891011121314151617{ &quot;type&quot;: &quot;process&quot;, &quot;label&quot;: &quot;Open File with&quot;, &quot;args&quot;: [&quot;${file}&quot;], &quot;tasks&quot;: [ { &quot;label&quot;: &quot;Typora&quot;, &quot;icon&quot;: &quot;Typora.svg&quot;, &quot;command&quot;: &quot;C:\\\\Programs\\\\Typora0.9.98\\\\x64\\\\Typora.exe&quot; }, { &quot;label&quot;: &quot;VS Code&quot;, &quot;icon&quot;: &quot;vscode.svg&quot;, &quot;command&quot;: &quot;C:\\\\Users\\\\tootal\\\\AppData\\\\Local\\\\Programs\\\\Microsoft VS Code\\\\Code.exe&quot; } ]} 1234567891011121314151617{ &quot;type&quot;: &quot;process&quot;, &quot;label&quot;: &quot;Open File with&quot;, &quot;args&quot;: [&quot;${file}&quot;], &quot;tasks&quot;: [ { &quot;label&quot;: &quot;Typora&quot;, &quot;icon&quot;: &quot;Typora.svg&quot;, &quot;command&quot;: &quot;/usr/bin/typora&quot; }, { &quot;label&quot;: &quot;VS Code&quot;, &quot;icon&quot;: &quot;vscode.svg&quot;, &quot;command&quot;: &quot;/usr/bin/code&quot; } ]} 由于VNote默认不包含控制台窗口，因此启动一些命令行程序时可能会出现问题，此时可以通过shell命令启动一个单独的窗口来解决。对于Windows可以用start vim.exe，对于Linux平台可以用gnome-terminal、konsole或xterm等。 1234567891011{ &quot;label&quot;: &quot;Vim&quot;, &quot;icon&quot;: &quot;vim.svg&quot;, &quot;type&quot;: &quot;process&quot;, &quot;command&quot;: &quot;gnome-terminal&quot;, &quot;args&quot;: [ &quot;--execute&quot;, &quot;vim&quot;, &quot;${file}&quot; ]} 多语言与多平台# 任务配置文件支持针对特定平台进行配置，通过windows、linux或osx属性可以指定Windows、Linux、macOS平台下特定的配置。平台特定配置会对基础配置进覆盖，但tasks配置会进行合并。例如可以将上面的启动外部程序的配置文件合并，使其在Windows平台和Linux平台均能正常工作。 123456789101112131415161718192021222324252627{ &quot;type&quot;: &quot;process&quot;, &quot;label&quot;: &quot;Open File with&quot;, &quot;args&quot;: [&quot;${file}&quot;], &quot;tasks&quot;: [ { &quot;label&quot;: &quot;Typora&quot;, &quot;icon&quot;: &quot;Typora.svg&quot;, &quot;windows&quot;: { &quot;command&quot;: &quot;C:\\\\Programs\\\\Typora0.9.98\\\\x64\\\\Typora.exe&quot; }, &quot;linux&quot;: { &quot;command&quot;: &quot;/usr/bin/typora&quot; } }, { &quot;label&quot;: &quot;VS Code&quot;, &quot;icon&quot;: &quot;vscode.svg&quot;, &quot;windows&quot;: { &quot;command&quot;: &quot;C:\\\\Users\\\\tootal\\\\AppData\\\\Local\\\\Programs\\\\Microsoft VS Code\\\\Code.exe&quot; }, &quot;linux&quot;: { &quot;command&quot;: &quot;/usr/bin/code&quot; } } ]} 任务配置文件也支持多语言配置，对于label、command、args属性，除字符串外还可传入一个LocaleString对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849{ &quot;label&quot;: { &quot;en_US&quot;: &quot;Hello&quot;, &quot;zh_CN&quot;: &quot;你好&quot; }, &quot;icon&quot;: &quot;tasks-solid.svg&quot;, &quot;command&quot;: &quot;echo&quot;, &quot;tasks&quot;: [ { &quot;label&quot;: { &quot;en_US&quot;: &quot;Cat&quot;, &quot;zh_CN&quot;: &quot;猫&quot; }, &quot;icon&quot;: &quot;cat-solid.svg&quot;, &quot;shortcut&quot;: &quot;Alt+H, C&quot;, &quot;args&quot;: [ { &quot;en_US&quot;: &quot;Hello cat!&quot;, &quot;zh_CN&quot;: &quot;你好，猫！&quot; } ] }, { &quot;label&quot;: { &quot;en_US&quot;: &quot;Dove&quot;, &quot;zh_CN&quot;: &quot;鸽子&quot; }, &quot;icon&quot;: &quot;dove-solid.svg&quot;, &quot;shortcut&quot;: &quot;Alt+H, D&quot;, &quot;args&quot;: [ { &quot;en_US&quot;: &quot;Hello dove!&quot;, &quot;zh_CN&quot;: &quot;你好，鸽子！&quot; } ] }, { &quot;label&quot;: &quot;Fish&quot;, &quot;icon&quot;: &quot;fish-solid.svg&quot;, &quot;shortcut&quot;: &quot;Alt+H, F&quot;, &quot;args&quot;: [ { &quot;en_US&quot;: &quot;Hello fish!&quot;, &quot;zh_CN&quot;: &quot;你好，鱼！&quot; } ] } ]} 注意：切换VNote语言后需要重启才能生效。 任务运行出错# 当任务运行出错时，会在输出面板显示错误消息，例如： 1[Task Typora error occurred with code 0] 其中错误代码的含义如下： 错误代码 含义 0 任务启动失败，可能是命令或参数错误。 1 任务启动成功，但在运行时崩溃了。 2 任务运行超时。 3 尝试读取时出现错误。 4 尝试写入时出现错误。 5 未知错误。 笔记本任务配置# 有些任务并不是每个笔记本都需要执行的，例如“通过Hexo渲染预览并发布”通常仅在特定的笔记本需要，此时可以创建一个笔记本层级的任务配置。VNote任务系统支持如下三个层级的配置文件： 全局任务配置：配置文件保存在全局配置文件夹中，软件安装时自动添加。例如C:\\Users\\tootal\\AppData\\Roaming\\VNote\\VNote\\tasks文件夹下的*.json文件。 用户任务配置：配置文件保存在用户配置文件夹中，由用户自行添加。例如C:\\Users\\tootal\\AppData\\Local\\VNote\\VNote\\tasks文件夹下的*.json文件。 笔记本任务配置：配置文件保存在笔记本文件夹中，由用户自行添加。例如C:\\Users\\tootal\\Documents\\vnote_notebooks\\testtask\\vx_notebook\\tasks文件夹下的*.json文件。 注意：笔记本层级的任务，如果之前不存在tasks文件夹，需要新建一个并刷新笔记本。 任务配置# 在VNote启动时会自动加载任务配置文件，配置文件修改后需要重新启动VNote生效。在上述文件夹及其子文件夹下的*.json文件均会被识别为任务配置文件。一个任务可以包含若干个子任务，在界面上显示为多级菜单项。任务配置文件与VSCode的相似而略有不同，一个任务包含如下配置项： [x] version，配置文件版本，默认值为最新版本。 [ ] id，任务标号，用于任务依赖及快捷键设置。 [x] label，任务名称（可翻译），根任务的默认值为文件名，子任务的默认值为command。 [x] type，任务类型，可以是process或shell，表示执行一个单独的程序还是执行一个shell命令，默认值为shell。 [x] command，任务命令（可翻译），需要执行的命令，可选，默认值为空表示不执行。 [x] args，任务参数（可翻译）。 [x] options，任务运行配置。 [x] cwd，任务工作目录。缺失时依次尝试下列值： 当前笔记本根目录 当前文件所在目录 当前任务配置文件所在目录。 [x] env，任务运行时环境变量。 [x] shell，shell配置，仅当任务类型为shell时生效。 [x] executable，shell可执行文件。 [x] args，shell启动参数 [x] tasks，子任务配置。 [x] inputs，输入变量配置。 [x] id，输入变量id。【必要】 [x] type，输入变量类型，可以是下列值，默认值为promptString。 promptString，弹出一个输入框 pickString，弹出一个选择框（尚未完全实现） [x] description，输入变量描述（可翻译）。 [x] default，输入变量默认值 （可翻译），当输入变量类型为pickString时，options需要包含default。 [x] password，输入模式，布尔值，默认值为false，仅当输入变量类型为promptString时生效。 [x] options，输入选项（可翻译），仅当输入变量类型为promptString时生效。 [x] windows，Windows平台特定配置。 [x] linux，Linux平台特定配置。 [x] osx，macOS平台特定配置。 [ ] dependsOn，任务依赖。 [ ] dependsOrder，任务依赖顺序，可以是parallel或sequence，默认值为parallel。 [ ] presentation，输出配置。 [ ] reveal，控制输出面板。可以是always（总是显示输出面板），never（从不显示输出面板），silent（仅当有输出时显示），默认值为always。 [ ] clear，控制是否清除之前任务的输出，布尔值，默认值为false。 [ ] runOptions，任务运行时配置。 [ ] runOn，任务触发方式，可以是下列值。 default，手动触发。 notebookOpen，打开笔记本时触发（仅支持笔记本级别的任务配置）。 notebookClose，关闭笔记本时触发（仅支持笔记本级别的任务配置）。 appOpen，打开VNote时触发。 appClose，关闭VNote时触发。 所有配置项除注明【必要】外均为可选，标注有（可翻译）的配置项可以传入一个字符串或一个指定locale的对象。子任务会从父任务中继承除label、inputs和tasks以外的值。平台特定配置中的tasks会进行合并，其余配置会被覆盖。配置项缺失时采用默认值。具体用法可参考下方示例或文章末尾处的完整的配置文件格式。 在不同平台下会使用不同的默认shell，对于Windows平台默认使用PowerShell.exe，Linux和macOS平台则默认使用/bin/bash。对于一些常见的shell提供了默认的启动参数。 Shell Shell args cmd.exe [“/C”] PowerShell.exe [“-Command”] /bin/bash [“-c”] 一个配置好的任务可以通过如下方式进行调用： [x] 主界面菜单项。在软件主菜单界面添加一个任务菜单项，其下列出一些功能以及通过配置文件定义的任务。触发该菜单项即可运行对应的任务。这也是目前主流的做法。 [x] 快捷键。如果需要频繁运行某个任务，可以为其定义一个快捷键。 [ ] 通用入口。在VNote v2版本中存在的一个功能，类似于VSCode或Sublime Text的快速命令面板，但目前在v3版本尚未迁移。 [ ] 自动调用。默认情况下只有手动触发才能调用工具，但有时在恰当的时机自动运行工具可能会非常方便。例如打开笔记本时自动与云端进行同步，关闭笔记本时自动提交所有修改到版本控制系统。这样不仅缩短了操作流程，还可以避免忘记运行。 变量替换# 在配置文件中获取当前运行时的一些参数是非常有用的，例如当前打开的笔记本，正在编辑或查看的文件。参考VSCode提供的变量，VNote的任务系统配置同样采用${variableName}的语法，支持以下类型的变量， [x] 预定义变量，提供上下文信息，如${notebookFolder}、${file}。 [x] 幻词变量，如${magic:datetime}、${magic:random}。 [x] 环境变量，提供系统环境变量，如${env:USERNAME}、${env:JAVA_HOME}。 [x] 配置变量，提供VNote配置信息，如${config:core.locale}。 [x] 输入变量，提供简单的交互功能，如${input:who}。 [x] Shell变量，获取Shell命令的结果，如${shell:}，对于复杂的命令可以使用输出变量。 对于同一个配置项中出现的同一个输入变量仅求值一次。暂不支持嵌套变量替换。 预定义变量# 以如下情况为例。 当前笔记本名称为test-task，根目录为C:\\Users\\tootal\\Documents\\vnote_notebooks\\testtask。 当前打开的文件C:\\Users\\tootal\\Documents\\vnote_notebooks\\testtask\\test2\\note.md。 当前选中的文字为第二行的a test。 ${notebookFolder}，当前打开的笔记本文件夹路径，如C:\\Users\\tootal\\Documents\\vnote_notebooks\\testtask。 ${notebookFolderBasename}，当前打开的笔记本文件夹名，如testtask。 ${notebookName}，当前打开的笔记本名，如test-task。 ${notebookDescription}，当前打开的笔记本描述，如This notebook for task test.。 ${file}，当前打开的文件路径，如C:\\Users\\tootal\\Documents\\vnote_notebooks\\testtask\\test2\\note.md。 ${fileNotebookFolder}，当前打开的文件所在的笔记本文件夹路径，如C:\\Users\\tootal\\Documents\\vnote_notebooks\\testtask。 ${relativeFile}，当前打开的文件相对于${fileNotebookFolder}的路径，如test2\\note.md。 ${fileBasename}，当前打开的文件名，如note.md。 ${fileBasenameNoExtension}，当前打开的文件名（不含扩展名），如note。 ${fileDirname}，当前打开的文件所在的文件夹路径，如C:\\Users\\tootal\\Documents\\vnote_notebooks\\testtask\\test2。 ${fileExtname}，当前打开的文件的扩展名（包含点），如.md。 ${cwd}，当前任务开始运行时的工作目录，如C:\\Users\\tootal\\Documents\\vnote_notebooks\\testtask。 ${lineNumber}，当前光标所在处的行号，如2。 ${selectedText}，当前选中的文本，如a test。 ${execPath}， VNote可执行文件的路径，如C:\\Programs\\vnote3\\vnote.exe。 ${pathSeparator}，当前操作系统所用的路径分隔符，如\\。 ${taskFile}，当前正在运行的任务配置文件路径。 ${taskDirname}，当前正在运行的任务配置文件所在的文件夹路径。 ${notebookTaskFolder}，当前笔记本任务配置文件夹路径，如C:\\Users\\tootal\\Documents\\vnote_notebooks\\testtask\\vx_notebook\\tasks。 ${userTaskFolder}，VNote用户任务配置文件夹路径，如C:\\Users\\tootal\\AppData\\Local\\VNote\\VNote\\tasks。 ${appTaskFolder}，VNote全局任务配置文件夹路径，如C:\\Users\\tootal\\AppData\\Roaming\\VNote\\VNote\\tasks。 ${userThemeFolder}，VNote用户主题文件夹路径，如C:\\Users\\tootal\\AppData\\Local\\VNote\\VNote\\themes。 ${appThemeFolder}，VNote全局主题文件夹路径，如C:\\Users\\tootal\\AppData\\Roaming\\VNote\\VNote\\themes。 ${userDocsFolder}，VNote用户文档文件夹路径，如C:\\Users\\tootal\\AppData\\Local\\VNote\\VNote\\docs。 ${appDocsFolder}，VNote全局文档文件夹路径，如C:\\Users\\tootal\\AppData\\Roaming\\VNote\\VNote\\docs。 TODO: ${lineNumber}、${selectedText}尚未实现。 变量基本与VSCode兼容。注意变量替换只在以下配置项中有效：command、args、options.cwd、options.env。如果变量的值不存在，则会被替换为空字符串。注意变量中的路径会使用平台相关的路径分隔符。 幻词变量# 通过${magic:word}的语法可以引用幻词变量，下面列出了VNote支持的所有幻词及其含义： d, the day as number without a leading zero (1 to 31) dd, the day as number with a leading zero (01 to 31) ddd, the abbreviated localized day name (e.g. Mon to Sun) dddd, the long localized day name (e.g. Monday to Sunday) M, the month as number without a leading zero (1 to 12) MM, the month as number with a leading zero (01 to 12) MMM, the abbreviated localized month name (e.g. Jan to Dec) MMMM, the long localized month name (e.g. January to December) yy, the year as two digit number (00 to 99) yyyy, the year as four digit number h, the hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display) hh, the hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display) H, the hour without a leading zero (0 to 23 even with AM/PM display) HH, the hour with a leading zero (00 to 23 even with AM/PM display) m, the minute without a leading zero (0 to 59) mm, the minute with a leading zero (00 to 59) s, the second without a leading zero (0 to 59) ss, the second with a leading zero (00 to 59) z, the milliseconds without leading zeroes (0 to 999) zzz, the milliseconds with leading zeroes (000 to 999) AP, use AM/PM display (AM or PM) A, use AM/PM display (AM or PM) ap, use am/pm display (am or pm) a, use am/pm display (am or pm) t, the timezone (e.g. CEST) random, a random number random_d, dynamic version of random date, yyyy-MM-dd, da, yyyyMMdd time, hh:mm:ss datetime, date time dt, da-time note, name of current note no, complete base name of current note att, relative path of current note’s attachment folder w, the week number (1 to 53) 例如： ${magic:datetime} → 2021-01-29 12:59:03 ${magic:random} → 56 TODO: att、random_d尚未实现。 环境变量# 可以用${env:Name}的语法引用系统定义的环境变量。 一些常见的环境变量如下所示： Windows Linux MacOS ${env:ComSpec} → C:\\Windows\\system32\\cmd.exe ${env:NUMBER_OF_PROCESSORS} → 6 ${env:TEMP} → C:\\Users\\tootal\\AppData\\Local\\Temp HOME LOGNAME SHELL PATH 配置变量# 用${config:core.locale}的语法引用VNote的配置变量。以下面的配置文件为例： 123456789{ &quot;core&quot;: { &quot;locale&quot;: &quot;en_US&quot; }, &quot;metadata&quot;: { &quot;version&quot;: &quot;3.0.0-beta.6&quot; }} ${config:core.locale} → en_US ${config:metadata.version} → 3.0.0-beta.6 配置变量只能返回字符串类型的值，对于Array和Object返回空字符串、其余类型返回字符串结果。仅支持object.key的语法，不支持object[&quot;key&quot;]，对于数组类型，支持array[0]的语法。 输入变量# 上面的变量在一般情况下已经足够使用，但它们无法在运行时动态调整参数。例如要求在运行git commit时手动输入一些信息。参考VSCode Tasks的Input variables，VNote同样提供类似的功能。通过${input:varid}的语法可以引用一个输入变量。 如下任务配置文件prompt.json可以弹出一个输入框，并将输入的内容在输出面板输出。 1234567891011{ &quot;command&quot;: &quot;echo&quot;, &quot;args&quot;: [&quot;${input:what}&quot;], &quot;inputs&quot;: [ { &quot;id&quot;: &quot;what&quot;, &quot;type&quot;: &quot;promptString&quot;, &quot;description&quot;: &quot;Type something, it will show in output panel.&quot; } ]} 运行效果如下图所示： Shell变量# 通过${shell:commandString}可以获取一些简单的Shell命令的结果，执行时会先通过系统默认的shell执行 commandString ，将结果作为变量值进行替换。对于较复杂的命令，请使用输出变量。 例如： ${shell:git rev-parse --abbrev-ref HEAD} → master ${shell:whoami} → tootal ${shell:dig github.com -4 +short} → 52.69.186.44 shell的工作目录与任务工作目录相同。变量解析超过1秒后，会中断任务的执行。 输入输出# 任务运行结果及错误信息可以通过输出面板进行查看，目前输出面板会依次尝试使用下列编码来显示输出： UTF-8 System UTF-16 GB18030 虽然有了输入变量可以进行一定程度的交互，但仍然不能很好的处理一些特殊情况。例如一些任务运行时需要进行多次输入确认、一些任务需要在后台保持运行等。VNote任务系统没有内置相关功能，但仍然可以通过启动一个额外的命令窗口来解决这些问题。下面以两个简单的示例来说明如何运行需要交互输入和后台运行的任务。 交互输入# 下面是一个用C++编写的猜数小游戏，接下来将通过任务配置在VNote中编译、运行。 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int main() { int low = 1, high = 20; cout &lt;&lt; &quot;Guess a number between &quot; &lt;&lt; low &lt;&lt; &quot; and &quot; &lt;&lt; high &lt;&lt; &quot;.\\n&quot;; srand(time(0)); int num = rand() % 20 + 1, x; while (true) { cin &gt;&gt; x; if (x &gt; num) cout &lt;&lt; &quot;It's too high.\\n&quot;; else if (x &lt; num) cout &lt;&lt; &quot;It's too low\\n&quot;; else { cout &lt;&lt; &quot;It is just fine\\n&quot;; break; } } return 0;} 新建一个任务配置文件run.json，内容如下： Windows Linux macOS 123{ &quot;command&quot;: &quot;g++ \\&quot;${file}\\&quot; -o \\&quot;${fileBasenameNoExtension}\\&quot;; if ($?) { start cmd \\&quot;/c `\\&quot;${fileBasenameNoExtension}`\\&quot; &amp; pause\\&quot; }&quot;} 注意尽管命令较长，但不能将其拆分成command和args，否则可能由于转义字符导致任务执行失败。运行效果如下图所示： TODOTODO 后台运行# 下面的例子演示了如何在笔记本根目录启动一个http服务器，并打开浏览器访问。 若笔记本根目录下没有index.html文件，可以新建一个，内容如下： 123456789&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;VNote Task&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;HTTP server start successfully.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 新建一个任务配置文件http.json，内容如下： Windows Linux macOS 123{ &quot;command&quot;: &quot;start cmd.exe \\&quot;/c python -m http.server\\&quot; ; start http://localhost:8000&quot;} 运行效果如下图所示： TODOTODO 任务示例# 前面展示的一些任务示例较为简单，下面包含四个较完善的任务示例，用来解决文章开头的四个问题。 [x] 通过Git进行笔记的版本控制 [ ] 将多个终端的笔记通过坚果云进行同步 [ ] 将写好的Markdown文档通过Hexo渲染预览并发布 [ ] 调用外部编辑器如Typora或是VS Code进行进一步编辑 所有任务均支持多语言与多平台。 Git# 通过Git进行版本控制是目前主流的选择，利用任务可以将一些Git的常用操作（如初始化、提交、上传、下载、查看日志）集成到VNote内部，大大方便了日常使用。如果目前笔记本尚未进行Git版本控制，需要先进行初始化，相当于命令git init。默认的分支名为main。 查看当前状态，相当于命令git status。 提示：查看状态时，中文文件名可能会显示为十六进制，这是由于Git默认会对值大于0x80的字符进行转义，可以使用git config --global core.quotepath false关闭转义，详细信息可参考core.quotePath。 提交可以把所有文件加入版本库中并生成一个记录，类似于命令git add . 与git commit同时执行。此时会弹出窗口请求输入提交信息，默认的提交信息是：更新笔记于 ${magic:datetime}，后面的变量表示当前时间。也可使用快捷键Alt+G, Alt+C执行提交。 提交后需要手动配置云端库如Github等（利用git remote命令），便可使用快捷的菜单命令进行上传下载，相当于执行git push与git pull命令，默认的merge策略是rebase。通过日志可以查看目前的版本记录。 任务代码可在Github上查看。 常见问题# 为何不采用系统环境变量ComSpec或SHELL的值作为默认shell？ 默认shell可以很大程度地减小配置文件的大小，大部分任务配置也会按照默认的shell语法来书写。系统环境变量可能会被用户或其它程序在不经意间修改，从而导致大量已有的任务配置失效。 配置格式# 参考VSCode Task的配置格式，定义VNote任务系统配置文件的格式如下。目前还在开发过程中，因此格式还在逐步调整。 v0.1.0 v0.1.1 v0.1.2 v0.1.3 v0.1.4 v0.1.5 v0.1.6 v0.1.7 v0.1.0# 根task的默认label就是文件名，子label默认用数字从0开始编号。 123456789101112131415161718192021222324interface TaskConfiguration extends TaskDescription { /** * The configuration's version number */ version: '0.1.0';}interface TaskDescription { /** * The command to be executed. Can be an external program or a shell * command. */ command: string; /** * The task's name. Can be omitted. */ label?: string; /** * The configuration of the available tasks. */ tasks?: TaskDescription[];} 没有新增内容，规定一下默认值的处理方法： version，不指定则采用最新的version。 command，不指定则不运行。 label，默认采用文件名，子task采用数字编号（0-index） tasks，指定子task。 123456789101112131415161718192021222324interface TaskConfiguration extends TaskDescription { /** * The configuration's version number */ version?: '0.1.1';}interface TaskDescription { /** * The command to be executed. Can be an external program or a shell * command. */ command?: string; /** * The task's name. Can be omitted. */ label?: string; /** * The configuration of the available tasks. */ tasks?: TaskDescription[];} v0.1.2# 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283interface TaskConfiguration extends TaskDescription { /** * The configuration's version number */ version?: '0.1.2';}interface TaskDescription { /** * The type of a custom task. Tasks of type &quot;shell&quot; are executed * inside a shell (e.g. bash, cmd, powershell, ...) * If omitted `shell` is used. */ type?: 'shell' | 'process'; /** * The command to be executed. Can be an external program or a shell * command. Can be omitted. */ command?: string; /** * The arguments passed to the command. Can be omitted. */ args?: string[]; /** * The task's name. * If root label omitted the file name is used. */ label?: string; /** * The command options used when the command is executed. Can be omitted. */ options?: CommandOptions; /** * The configuration of the available tasks. */ tasks?: TaskDescription[];}/** * Options to be passed to the external program or shell */export interface CommandOptions { /** * The current working directory of the executed program or shell. * If omitted try the following valus in turn. * - the current notebook's root * - the directory of current file * - the directory of executing task file */ cwd?: string; /** * The environment of the executed program or shell. If omitted * the parent process' environment is used. */ env?: { [key: string]: string }; /** * Configuration of the shell when task type is `shell` */ shell?: { /** * The shell to use. * If omitted, the OS-specific shell is used. * - `cmd.exe` for windows * - `/bin/bash` for linux or macOS */ executable: string; /** * The arguments to be passed to the shell executable to run in command mode. * If omitted, the default value is used. * - ['/D', '/S', '/C'] for `cmd.exe` * - ['-c'] for `/bin/bash` */ args?: string[]; };} v0.1.3# 支持了翻译、平台相关配置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113interface TaskConfiguration { /** * The configuration's version number * If omitted latest version is used. */ version?: '0.1.3'; /** * Windows specific task configuration */ windows?: TaskConfiguration; /** * macOS specific task configuration */ osx?: TaskConfiguration; /** * Linux specific task configuration */ linux?: TaskConfiguration; /** * The type of a custom task. Tasks of type &quot;shell&quot; are executed * inside a shell (e.g. bash, cmd, powershell, ...) * If omitted, the parent type is used * If no parent specific, the `shell` is used. */ type?: 'shell' | 'process'; /** * The command to be executed. Can be an external program or a shell * command. Can be omitted. */ command?: string; /** * The arguments passed to the command. Can be omitted. */ args?: string[]; /** * The task's name. * If task has no parent, the file name is used. * If task has command, the command is used. */ label?: string | TranslatableString; /** * The command options used when the command is executed. Can be omitted. */ options?: CommandOptions; /** * The configuration of the available tasks. * Tasks will not be inherited. * Tasks in OS-specific will be merged. */ tasks?: TaskConfiguration[];}/** * Options to be passed to the external program or shell */interface CommandOptions { /** * The current working directory of the executed program or shell. * If omitted try the following valus in turn. * - the parent task working dir * - the current notebook's root * - the directory of current file * - the directory of executing task file */ cwd?: string; /** * The environment of the executed program or shell. * If omitted the parent process' environment is used. */ env?: { [key: string]: string }; /** * Configuration of the shell when task type is `shell` */ shell?: { /** * The shell to use. * If omitted, the parent shell is used * If no parent specific, the OS-specific shell is used. * - `PowerShell.exe` for windows * - `/bin/bash` for linux or macOS */ executable: string; /** * The arguments to be passed to the shell executable to run in command mode. * If omitted, the parent shell is used * If no parent specific, the default value is used. * - ['/D', '/S', '/C'] for `cmd.exe` * - ['-Command'] for `PowerShell.exe` * - ['-c'] for `/bin/bash` */ args?: string[]; };}/** * Localization */interface TranslatableString { en_US?: string, zh_CN?: string} v0.1.4# 支持输入变量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155interface TaskConfiguration { /** * The configuration's version number * If omitted latest version is used. */ version?: '0.1.4'; /** * Windows specific task configuration */ windows?: TaskConfiguration; /** * macOS specific task configuration */ osx?: TaskConfiguration; /** * Linux specific task configuration */ linux?: TaskConfiguration; /** * The type of a custom task. Tasks of type &quot;shell&quot; are executed * inside a shell (e.g. bash, cmd, powershell, ...) * If omitted, the parent type is used * If no parent specific, the `shell` is used. */ type?: 'shell' | 'process'; /** * The command to be executed. Can be an external program or a shell * command. Can be omitted. */ command?: string; /** * The arguments passed to the command. Can be omitted. */ args?: string[]; /** * The task's name. * If task has no parent, the file name is used. * If task has command, the command is used. */ label?: TranslatableString; /** * The command options used when the command is executed. Can be omitted. */ options?: CommandOptions; /** * The configuration of the available tasks. * Tasks will not be inherited. * Tasks in OS-specific will be merged. */ tasks?: TaskConfiguration[]; /** * The configuration of the input variables. */ inputs?: InputConfiguration[];}/** * Options to be passed to the external program or shell */interface CommandOptions { /** * The current working directory of the executed program or shell. * If omitted try the following valus in turn. * - the parent task working dir * - the current notebook's root * - the directory of current file * - the directory of executing task file */ cwd?: string; /** * The environment of the executed program or shell. * If omitted the parent process' environment is used. */ env?: { [key: string]: string }; /** * Configuration of the shell when task type is `shell` */ shell?: { /** * The shell to use. * If omitted, the parent shell is used * If no parent specific, the OS-specific shell is used. * - `PowerShell.exe` for windows * - `/bin/bash` for linux or macOS */ executable: string; /** * The arguments to be passed to the shell executable to run in command mode. * If omitted, the parent shell is used * If no parent specific, the default value is used. * - ['/D', '/S', '/C'] for `cmd.exe` * - ['-Command'] for `PowerShell.exe` * - ['-c'] for `/bin/bash` */ args?: string[]; };}/** * Localization */interface LocaleString { en_US?: string, zh_CN?: string}type TranslatableString = string | LocaleString;/** * Configuration of input variables */interface InputConfiguration { /** * Input variable id */ id: string, /** * the type of input variable * if omitted, `promptString` is used. */ type?: 'promptString' | 'pickString', /** * Provides context for the input. */ description?: TranslatableString, /** * Default value that will be used if the user doesn't enter something else. * If type is pickString, it must be one of the option values. */ default?: TranslatableString, /** * Only avaliable when type is promptString * Set to true to input with a password prompt that will not show the typed value. */ password?: boolean, /** * Only avaliable when type is pickString * An array of options for the user to pick from. */ options?: TranslatableString[]} v0.1.5# 支持可翻译的命令字符串及参数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154interface TaskConfiguration { /** * The configuration's version number * If omitted latest version is used. */ version?: '0.1.5'; /** * Windows specific task configuration */ windows?: TaskConfiguration; /** * macOS specific task configuration */ osx?: TaskConfiguration; /** * Linux specific task configuration */ linux?: TaskConfiguration; /** * The type of a custom task. Tasks of type &quot;shell&quot; are executed * inside a shell (e.g. bash, cmd, powershell, ...) * If omitted, the parent type is used * If no parent specific, the `shell` is used. */ type?: 'shell' | 'process'; /** * The command to be executed. Can be an external program or a shell * command. Can be omitted. */ command?: TranslatableString; /** * The arguments passed to the command. Can be omitted. */ args?: TranslatableString[]; /** * The task's name. * If task has no parent, the file name is used. * If task has command, the command is used. */ label?: TranslatableString; /** * The command options used when the command is executed. Can be omitted. */ options?: CommandOptions; /** * The configuration of the available tasks. * Tasks will not be inherited. * Tasks in OS-specific will be merged. */ tasks?: TaskConfiguration[]; /** * The configuration of the input variables. */ inputs?: InputConfiguration[];}/** * Options to be passed to the external program or shell */interface CommandOptions { /** * The current working directory of the executed program or shell. * If omitted try the following valus in turn. * - the parent task working dir * - the current notebook's root * - the directory of current file * - the directory of executing task file */ cwd?: string; /** * The environment of the executed program or shell. * If omitted the parent process' environment is used. */ env?: { [key: string]: string }; /** * Configuration of the shell when task type is `shell` */ shell?: { /** * The shell to use. * If omitted, the parent shell is used * If no parent specific, the OS-specific shell is used. * - `PowerShell.exe` for windows * - `/bin/bash` for linux or macOS */ executable: string; /** * The arguments to be passed to the shell executable to run in command mode. * If omitted, the parent shell is used * If no parent specific, the default value is used. * - ['/D', '/S', '/C'] for `cmd.exe` * - ['-Command'] for `PowerShell.exe` * - ['-c'] for `/bin/bash` */ args?: string[]; };}/** * Localization */interface LocaleString { en_US?: string, zh_CN?: string}type TranslatableString = string | LocaleString;/** * Configuration of input variables */interface InputConfiguration { /** * Input variable id */ id: string, /** * the type of input variable * if omitted, `promptString` is used. */ type?: 'promptString' | 'pickString', /** * Provides context for the input. */ description?: TranslatableString, /** * Default value that will be used if the user doesn't enter something else. * If type is pickString, it must be one of the option values. */ default?: TranslatableString, /** * Only avaliable when type is promptString * Set to true to input with a password prompt that will not show the typed value. */ password?: boolean, /** * Only avaliable when type is pickString * An array of options for the user to pick from. */ options?: TranslatableString[]} v0.1.6# 支持了图标icon和快捷键shortcut。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166interface TaskConfiguration { /** * The configuration's version number * If omitted latest version is used. */ version?: '0.1.6'; /** * Windows specific task configuration */ windows?: TaskConfiguration; /** * macOS specific task configuration */ osx?: TaskConfiguration; /** * Linux specific task configuration */ linux?: TaskConfiguration; /** * The type of a custom task. Tasks of type &quot;shell&quot; are executed * inside a shell (e.g. bash, cmd, powershell, ...) * If omitted, the parent type is used * If no parent specific, the `shell` is used. */ type?: 'shell' | 'process'; /** * The command to be executed. Can be an external program or a shell * command. Can be omitted. */ command?: TranslatableString; /** * The arguments passed to the command. Can be omitted. */ args?: TranslatableString[]; /** * The task's name. * If task has no parent, the file name is used. * If task has command, the command is used. */ label?: TranslatableString; /** * The task's icon. * task icon will not be inherited */ icon?: string; /** * The task's shortcut. * task icon will not be inherited */ shortcut?: string; /** * The command options used when the command is executed. Can be omitted. */ options?: CommandOptions; /** * The configuration of the available tasks. * Tasks will not be inherited. * Tasks in OS-specific will be merged. */ tasks?: TaskConfiguration[]; /** * The configuration of the input variables. */ inputs?: InputConfiguration[];}/** * Options to be passed to the external program or shell */interface CommandOptions { /** * The current working directory of the executed program or shell. * If omitted try the following valus in turn. * - the parent task working dir * - the current notebook's root * - the directory of current file * - the directory of executing task file */ cwd?: string; /** * The environment of the executed program or shell. * If omitted the parent process' environment is used. */ env?: { [key: string]: string }; /** * Configuration of the shell when task type is `shell` */ shell?: { /** * The shell to use. * If omitted, the parent shell is used * If no parent specific, the OS-specific shell is used. * - `PowerShell.exe` for windows * - `/bin/bash` for linux or macOS */ executable: string; /** * The arguments to be passed to the shell executable to run in command mode. * If omitted, the parent shell is used * If no parent specific, the default value is used. * - ['/D', '/S', '/C'] for `cmd.exe` * - ['-Command'] for `PowerShell.exe` * - ['-c'] for `/bin/bash` */ args?: string[]; };}/** * Localization */interface LocaleString { en_US?: string, zh_CN?: string}type TranslatableString = string | LocaleString;/** * Configuration of input variables */interface InputConfiguration { /** * Input variable id */ id: string, /** * the type of input variable * if omitted, `promptString` is used. */ type?: 'promptString' | 'pickString', /** * Provides context for the input. */ description?: TranslatableString, /** * Default value that will be used if the user doesn't enter something else. * If type is pickString, it must be one of the option values. */ default?: TranslatableString, /** * Only avaliable when type is promptString * Set to true to input with a password prompt that will not show the typed value. */ password?: boolean, /** * Only avaliable when type is pickString * An array of options for the user to pick from. */ options?: TranslatableString[]} v0.1.7# 支持环境变量多语言。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166interface TaskConfiguration { /** * The configuration's version number * If omitted latest version is used. */ version?: '0.1.7'; /** * Windows specific task configuration */ windows?: TaskConfiguration; /** * macOS specific task configuration */ osx?: TaskConfiguration; /** * Linux specific task configuration */ linux?: TaskConfiguration; /** * The type of a custom task. Tasks of type &quot;shell&quot; are executed * inside a shell (e.g. bash, cmd, powershell, ...) * If omitted, the parent type is used * If no parent specific, the `shell` is used. */ type?: 'shell' | 'process'; /** * The command to be executed. Can be an external program or a shell * command. Can be omitted. */ command?: TranslatableString; /** * The arguments passed to the command. Can be omitted. */ args?: TranslatableString[]; /** * The task's name. * If task has no parent, the file name is used. * If task has command, the command is used. */ label?: TranslatableString; /** * The task's icon. * task icon will not be inherited */ icon?: string; /** * The task's shortcut. * task icon will not be inherited */ shortcut?: string; /** * The command options used when the command is executed. Can be omitted. */ options?: CommandOptions; /** * The configuration of the available tasks. * Tasks will not be inherited. * Tasks in OS-specific will be merged. */ tasks?: TaskConfiguration[]; /** * The configuration of the input variables. */ inputs?: InputConfiguration[];}/** * Options to be passed to the external program or shell */interface CommandOptions { /** * The current working directory of the executed program or shell. * If omitted try the following valus in turn. * - the parent task working dir * - the current notebook's root * - the directory of current file * - the directory of executing task file */ cwd?: string; /** * The environment of the executed program or shell. * If omitted the parent process' environment is used. */ env?: { [key: string]: TranslatableString }; /** * Configuration of the shell when task type is `shell` */ shell?: { /** * The shell to use. * If omitted, the parent shell is used * If no parent specific, the OS-specific shell is used. * - `PowerShell.exe` for windows * - `/bin/bash` for linux or macOS */ executable: string; /** * The arguments to be passed to the shell executable to run in command mode. * If omitted, the parent shell is used * If no parent specific, the default value is used. * - ['/D', '/S', '/C'] for `cmd.exe` * - ['-Command'] for `PowerShell.exe` * - ['-c'] for `/bin/bash` */ args?: string[]; };}/** * Localization */interface LocaleString { en_US?: string, zh_CN?: string}type TranslatableString = string | LocaleString;/** * Configuration of input variables */interface InputConfiguration { /** * Input variable id */ id: string, /** * the type of input variable * if omitted, `promptString` is used. */ type?: 'promptString' | 'pickString', /** * Provides context for the input. */ description?: TranslatableString, /** * Default value that will be used if the user doesn't enter something else. * If type is pickString, it must be one of the option values. */ default?: TranslatableString, /** * Only avaliable when type is promptString * Set to true to input with a password prompt that will not show the typed value. */ password?: boolean, /** * Only avaliable when type is pickString * An array of options for the user to pick from. */ options?: TranslatableString[]}","link":"/posts/vnote-task/"}],"tags":[{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Qt","slug":"Qt","link":"/tags/Qt/"},{"name":"ACM","slug":"ACM","link":"/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","link":"/tags/Codeforces/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"二叉树","slug":"二叉树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"Minecraft","slug":"Minecraft","link":"/tags/Minecraft/"},{"name":"编程","slug":"编程","link":"/tags/%E7%BC%96%E7%A8%8B/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"爬虫","slug":"爬虫","link":"/tags/%E7%88%AC%E8%99%AB/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"LIS","slug":"LIS","link":"/tags/LIS/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"PDF","slug":"PDF","link":"/tags/PDF/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"博客","slug":"博客","link":"/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"斐波那契数列","slug":"斐波那契数列","link":"/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"VNote","slug":"VNote","link":"/tags/VNote/"},{"name":"技术","slug":"技术","link":"/tags/%E6%8A%80%E6%9C%AF/"}],"categories":[{"name":"计算机","slug":"计算机","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"大学课程","slug":"大学课程","link":"/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/"},{"name":"算法竞赛","slug":"计算机/算法竞赛","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"C++程序设计","slug":"大学课程/C-程序设计","link":"/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/C-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"Web程序设计","slug":"大学课程/Web程序设计","link":"/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/Web%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"技术","slug":"计算机/技术","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%8A%80%E6%9C%AF/"},{"name":"数学分析","slug":"大学课程/数学分析","link":"/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/"},{"name":"Java程序设计","slug":"大学课程/Java程序设计","link":"/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/Java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"数据库","slug":"大学课程/数据库","link":"/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]}